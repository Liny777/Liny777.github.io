<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Java Basics - Undateable</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="Undateable"><meta name="msapplication-TileImage" content="/img/logo1.png"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Undateable"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="description" content="Java基础知识高频问题   😲😲😲                 Java语言的三大特性是什么？       重载与重写的区别?       接口和抽象类的区别是什么？       Java中的内部类说一下?       说一下final关键字的作用?       说一下String，StringBuilder和StringBuffer的区别?       说一下Java中的&amp;#x3D;&amp;#x3D;与eaq"><meta property="og:type" content="blog"><meta property="og:title" content="Java Basics"><meta property="og:url" content="http://example.com/2022/10/08/String/"><meta property="og:site_name" content="Undateable"><meta property="og:description" content="Java基础知识高频问题   😲😲😲                 Java语言的三大特性是什么？       重载与重写的区别?       接口和抽象类的区别是什么？       Java中的内部类说一下?       说一下final关键字的作用?       说一下String，StringBuilder和StringBuffer的区别?       说一下Java中的&amp;#x3D;&amp;#x3D;与eaq"><meta property="og:locale" content="en_US"><meta property="og:image" content="http://example.com/img/3.svg"><meta property="article:published_time" content="2022-10-08T08:00:18.000Z"><meta property="article:modified_time" content="2022-11-09T08:46:45.230Z"><meta property="article:author" content="Liny"><meta property="article:tag" content="Java"><meta property="twitter:card" content="summary"><meta property="twitter:image:src" content="http://example.com/img/3.svg"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://example.com/2022/10/08/String/"},"headline":"Java Basics","image":[],"datePublished":"2022-10-08T08:00:18.000Z","dateModified":"2022-11-09T08:46:45.230Z","author":{"@type":"Person","name":"Liny"},"publisher":{"@type":"Organization","name":"Undateable","logo":{"@type":"ImageObject","url":"http://example.com/img/logo2.png"}},"description":"Java基础知识高频问题   😲😲😲                 Java语言的三大特性是什么？       重载与重写的区别?       接口和抽象类的区别是什么？       Java中的内部类说一下?       说一下final关键字的作用?       说一下String，StringBuilder和StringBuffer的区别?       说一下Java中的&#x3D;&#x3D;与eaq"}</script><link rel="canonical" href="http://example.com/2022/10/08/String/"><link rel="icon" href="/img/logo1.png"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v6.0.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/css/justifiedGallery.min.css"><!--!--><!--!--><style>.pace{-webkit-pointer-events:none;pointer-events:none;-webkit-user-select:none;-moz-user-select:none;user-select:none}.pace-inactive{display:none}.pace .pace-progress{background:#3273dc;position:fixed;z-index:2000;top:0;right:100%;width:100%;height:2px}</style><script src="https://cdn.jsdelivr.net/npm/pace-js@1.2.4/pace.min.js"></script><!--!--><!--!--><!-- hexo injector head_end start --><script>
  (function () {
      function switchTab() {
          if (!location.hash) {
            return;
          }

          const $tabMenu = document.querySelector(`a[href="${location.hash}"]`);
          if (!$tabMenu) {
            return;
          }

          const $tabMenuContainer = $tabMenu.parentElement.parentElement;
          Array.from($tabMenuContainer.children).forEach($menu => $menu.classList.remove('is-active'));
          Array.from($tabMenuContainer.querySelectorAll('a'))
              .map($menu => document.getElementById($menu.getAttribute("href").substring(1)))
              .forEach($content => $content.classList.add('is-hidden'));

          if ($tabMenu) {
              $tabMenu.parentElement.classList.add('is-active');
          }
          const $activeTab = document.querySelector(location.hash);
          if ($activeTab) {
              $activeTab.classList.remove('is-hidden');
          }
      }
      switchTab();
      window.addEventListener('hashchange', switchTab, false);
  })();
  </script><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body class="is-2-column"><nav class="navbar navbar-main"><div class="container navbar-container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo2.png" alt="Undateable" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/resume">Resume</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Liny777/Liny777.github.io"><i class="fab fa-github"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-8-widescreen"><div class="card"><div class="card-image"><span class="image is-7by3"><img class="fill" src="/img/3.svg" alt="Java Basics"></span></div><article class="card-content article" role="article"><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item">Posted&nbsp;<time dateTime="2022-10-08T08:00:18.000Z" title="2022/10/8 16:00:18">2022-10-08</time></span><span class="level-item">Updated&nbsp;<time dateTime="2022-11-09T08:46:45.230Z" title="2022/11/9 16:46:45">2022-11-09</time></span><span class="level-item"><a class="link-muted" href="/categories/BackEnd/">BackEnd</a></span><span class="level-item">an hour read (About 8428 words)</span></div></div><h1 class="title is-3 is-size-4-mobile">Java Basics</h1><div class="content"><h2 id="Java基础知识高频问题"><a href="#Java基础知识高频问题" class="headerlink" title="Java基础知识高频问题"></a>Java基础知识高频问题</h2><details>
  <summary>😲😲😲</summary>
  <div>
    <ol>
        <li>Java语言的三大特性是什么？</li>
      <li>重载与重写的区别?</li>
      <li>接口和抽象类的区别是什么？</li>
      <li>Java中的内部类说一下?</li>
      <li>说一下final关键字的作用?</li>
      <li>说一下String，StringBuilder和StringBuffer的区别?</li>
      <li>说一下Java中的==与eaquels的区别?</li>
      <li>Java访问修饰符有哪些？都有什么区别？</li>
      <details>
      <summary>
        追问
      </summary>
        <div>怎么获取private修饰的变量</div>
        </details>  
      <li>.Java中的异常体系说一下？</li>
      <details>
      <summary>
        追问
      </summary>
        <div>异常的处理方式？</div>
        </details>    
      <li>.Java中的深拷贝和浅拷贝说一下？</li>
      <details>
      <summary>
        追问
      </summary>
        <div>浅拷贝与深拷贝的特点是什么？</div>
        </details>
    </ol>
  </div>
</details>
<span id="more"></span>

<h3 id="1-面向对象三大特征"><a href="#1-面向对象三大特征" class="headerlink" title="1. 面向对象三大特征"></a>1. 面向对象三大特征</h3><img src="/2022/10/08/String/1.png" class="" title="This is an image">

<h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装是指将<strong>对象的属性私有化，提供一些可以访问属性的方法</strong>，我们可以通过访问这些方法得到对象的属性。</p>
<h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p>继承是指某<strong>新类继承已经存在的类，该新类拥有被继承的类的所有属性和方法，并且新类可以根据自己的情况拓展属性或方法。其中新类被称为子类，原存在的类被称为父类。</strong><br>1、子类拥有父亲类对象所有的属性和方法（包括私有属性和私有方法），但是父类中私有属性和方法子类是无法访问，只是拥有。<br>2、子类可以拥有自己属性和方法，即子类可以对父类进行拓展。<br>3、子类可以用自己的方式实现父类的方法。</p>
<ul>
<li>子类不能直接访问父类的私有属性，子类只能在父类中写一个public的getXXX的方法来获取父类中的private属性，子类就调用父类的getXXX来获取private属性</li>
<li>在子类的构造方法中通过super()方法调用父类的构造方法来继承到父类的私有域。</li>
<li>构造子类的同时，为子类构造出跟父类相同的域。如此就在子类的对象中，也拥有了父类声明的域了</li>
</ul>
<h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态是同一个行为具有多个不同表现形式或形态的能力。<strong>多态就是同一个接口，使用不同的实例而执行不同操作。</strong></p>
<p>多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。【摘自JavaGuide】</p>
<p><strong>在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>封装：封装起来，只提供访问接口</p>
<p>继承：新继承已有的，然后根据自己情况拓展</p>
<p>多态：同一个行为不同表现形式（比如飞，各种飞行姿势等）- 接口 和 继承来实现</p>
<hr>
<h3 id="2-重载和重写"><a href="#2-重载和重写" class="headerlink" title="2. 重载和重写"></a>2. 重载和重写</h3><img src="/2022/10/08/String/2.png" class="" title="This is an image">

<p><strong>重载</strong>：重载是发生在同一个类中，具有相同的方法名，但是有不同的参数，参数的个数不一样、参数的位置不一样、这叫做重载，常见的就比如构造方法，有参构造和无参构造。</p>
<p><strong>重写</strong>：发生在当子类继承父类时，对父类中的一些方法根据自己的需求进行重写操作。</p>
<p>父类方法被默认修饰时，只能在同一包中，被其子类被重写，如果不在同一包则不能重写。</p>
<p>父类的方法被protoeted时，不仅在同一包中，被其子类被重写，还可以不同包的子类重写。</p>
<h5 id="重写方法的规则："><a href="#重写方法的规则：" class="headerlink" title="重写方法的规则："></a>重写方法的规则：</h5><p>1）、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。</p>
<p>2）、返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。</p>
<p>3）、访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private）</p>
<p>4）、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：<br>父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。</p>
<h5 id="重载的规则："><a href="#重载的规则：" class="headerlink" title="重载的规则："></a>重载的规则：</h5><p>1）、必须具有不同的参数列表；</p>
<p>2）、可以有不同的返回类型，只要参数列表不同就可以了；</p>
<p>3）、可以有不同的访问修饰符；</p>
<p>4）、可以抛出不同的异常；</p>
<h5 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h5><p>重写：只有内容和权限可以不一样，其他必须一样</p>
<p>重载：函数名字一样，其他都可以不一样</p>
<hr>
<h3 id="3-抽象类和接口的区别"><a href="#3-抽象类和接口的区别" class="headerlink" title="3. 抽象类和接口的区别"></a>3. 抽象类和接口的区别</h3><img src="/2022/10/08/String/3.png" class="" title="This is an image">

<p>接口（Interface）和抽象类（Abstract class）是支持抽象类定义的两种机制。抽象是对类的抽象。</p>
<p><strong>接口</strong>是<strong>公开</strong>的，不能有私有的方法或变量，接口中的所有方法<strong>都没有方法体</strong>，通过关键字<strong>interface</strong>实现。接口是对行为的抽象。抽象类是一种模版，接口是一种行为规范。</p>
<p><strong>抽象类</strong>是可以有私有方法或私有变量的，通过把类或者类中的方法声明为<strong>abstract</strong>来表示一个类是抽象类，被声明为抽象的方法<strong>不能包含方法体</strong>。子类实现方法必须含有相同的或者更低的访问级别（public-&gt;protected-&gt;private)。抽象类的子类为父类中所有抽象方法的具体实现，否则也是抽象类。<br>特点：</p>
<ul>
<li>被abstract修饰，没有方法体的方法称为抽象方法；</li>
<li>抽象方法必须存在于抽象类中，不能存在于非抽象类；</li>
<li>抽象方法必须在其子类中实现，除非子类也是抽象类；</li>
<li>如果一个类中含有抽象方法，该类一定是抽象类，该类必须被abstract修饰；</li>
<li>如果一个类是抽象类，该类可以含有抽象方法和非抽象方法</li>
<li>如果一个类为抽象类，则该类不能被实例化，必须通过该类的非抽象子类进行实例化</li>
</ul>
<p><strong>相同点</strong>：<br>（1）：都不能被实例化<br>（2）：接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。</p>
<p><strong>不同点：</strong></p>
<p>（1）：接口只有定义，不能有方法的实现，但java1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。<br>（2）：实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。<br>（3）：接口强调特定功能的实现，而抽象类强调所属关系。<br>（4）：接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）<br>（5）：接口被用于常用的功能，便于日后维护和添加删除，而抽象类更倾向于充当公共类的角色，不适用于日后重新对立面的代码修改。从设计层面来说，抽象是对类的抽象，是一种设计模版，而接口是对行为的抽象，是一种行为的规范。</p>
<h5 id="总结：-1"><a href="#总结：-1" class="headerlink" title="总结："></a>总结：</h5><p>接口：行为约束，只约束行为类别，不约束行为内容，implements，没有构造方法，一个类实现多个接口</p>
<p>抽象：代码复用，extends，有构造方法，一个类继承一个抽象</p>
<p>同：都不能实例化，不能private</p>
<hr>
<h3 id="4-Final修饰类、方法、字段分别起到的作用？"><a href="#4-Final修饰类、方法、字段分别起到的作用？" class="headerlink" title="4. Final修饰类、方法、字段分别起到的作用？"></a>4. Final修饰类、方法、字段分别起到的作用？</h3><img src="/2022/10/08/String/4.png" class="" title="This is an image">

<h5 id="总结：-2"><a href="#总结：-2" class="headerlink" title="总结："></a>总结：</h5><p>类：不能被继承，成员方法被隐式地指定为final方法。<br>方法：不能被重写</p>
<p>字段</p>
<p>常量：不能修改</p>
<p>变量&#x2F;引用型：不能指向其他人</p>
<h3 id="5-String-VS-StringBuffer-VS-StringBuilder"><a href="#5-String-VS-StringBuffer-VS-StringBuilder" class="headerlink" title="5. String VS StringBuffer VS StringBuilder"></a>5. String VS StringBuffer VS StringBuilder</h3><img src="/2022/10/08/String/5.png" class="" title="This is an image">

<h5 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h5><p>String：不可变，原理final，private final char value[]，操作少量</p>
<p>StringBuffer：可变，继承自AbstractStringBuilder，加了同步锁，唯一一个线程安全，多线程选择他</p>
<p>StringBuilder：可变，继承自AbstractStringBuilder，单线程，</p>
<h3 id="6-说一下Java中的-x3D-x3D-与eaquels的区别"><a href="#6-说一下Java中的-x3D-x3D-与eaquels的区别" class="headerlink" title="6. 说一下Java中的&#x3D;&#x3D;与eaquels的区别"></a>6. 说一下Java中的&#x3D;&#x3D;与eaquels的区别</h3><img src="/2022/10/08/String/6.png" class="" title="This is an image">

<h5 id="x3D-x3D"><a href="#x3D-x3D" class="headerlink" title="&#x3D;&#x3D;"></a>&#x3D;&#x3D;</h5><p>对于基本类型和引用类型 &#x3D;&#x3D; 的作用效果是不同的，如下所示：</p>
<ul>
<li>基本类型：比较的是值是否相同；</li>
<li>引用类型：比较的是引用是否相同；</li>
</ul>
<p>1、比较的是操作符两端的操作数是否是同一个对象。</p>
<p>2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。</p>
<p>3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如：</p>
<p>int a&#x3D;10 与 long b&#x3D;10L 与 double c&#x3D;10.0都是相同的（为true），因为他们都指向地址为10的堆。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">x</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">y</span> <span class="operator">=</span> <span class="string">&quot;string&quot;</span>;</span><br><span class="line"><span class="type">String</span> <span class="variable">z</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;string&quot;</span>);</span><br><span class="line">System.out.println(x==y); <span class="comment">// true</span></span><br><span class="line">System.out.println(x==z); <span class="comment">// false</span></span><br><span class="line">System.out.println(x.equals(y)); <span class="comment">// true</span></span><br><span class="line">System.out.println(x.equals(z)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<hr>
<h5 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h5><p>equals 本质上就是 &#x3D;&#x3D;，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。</p>
<p>首先来看默认情况下 equals 比较一个有相同值的对象，代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Cat</span> <span class="variable">c1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;王磊&quot;</span>);</span><br><span class="line"><span class="type">Cat</span> <span class="variable">c2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>(<span class="string">&quot;王磊&quot;</span>);</span><br><span class="line">System.out.println(c1.equals(c2)); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>

<p>输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object obj)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (<span class="built_in">this</span> == obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来 equals 本质上就是 &#x3D;&#x3D;。</p>
<p>同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下：</p>
<p><strong>value哪来的？？？</strong> – String底层是数组，value可以拿到String的char数组。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">anotherString</span> <span class="operator">=</span> (String)anObject;</span><br><span class="line">        <span class="type">int</span> <span class="variable">n</span> <span class="operator">=</span> value.length;</span><br><span class="line">        <span class="keyword">if</span> (n == anotherString.value.length) &#123;</span><br><span class="line">            <span class="type">char</span> v1[] = value;</span><br><span class="line">            <span class="type">char</span> v2[] = anotherString.value;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (n-- != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (v1[i] != v2[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>源码里String的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">equals</span><span class="params">(Object anObject)</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="built_in">this</span> == anObject) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (anObject <span class="keyword">instanceof</span> String) &#123;</span><br><span class="line">    String = aString = (String)anObject;</span><br><span class="line">    <span class="keyword">if</span>(coder() == aString.coder()) &#123;</span><br><span class="line">      <span class="keyword">return</span> isLatin1() ? StringLatin1.equals(value, aString.value) : StringUTF16.equals(value, aString.value);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。</p>
<p>equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是&#x3D;&#x3D;的判断。</p>
<p>String s&#x3D;”abce”是一种非常特殊的形式,和new 有本质的区别。它是java中唯一不需要new 就可以产生对象的途径。</p>
<p>以String s&#x3D;”abce”;形式赋值在java中叫直接量,它是在常量池中而不是象new一样放在压缩堆中。这种形式的字符串，在JVM内部发生字符串拘留，即当声明这样的一个字符串后，JVM会在常量池中先查找有有没有一个值为”abcd”的对象。</p>
<p>如果有，就会把它赋给当前引用.即原来那个引用和现在这个引用指点向了同一对象，如果没有，则在常量池中新创建一个“abcd””，下一次如果有Strings1&#x3D;”abcd”；又会将s1指向“abcd”这个对象，即以这形式声明的字符串，只要值相等，任何多个引用都指向同一对象。</p>
<p>而String s&#x3D;new String（”abcd”）；和其它任何对象一样.每调用一次就产生一个对象，只要它们调用。</p>
<p>也可以这么理解：String str&#x3D;”hello”；先在内存中找是不是有“hello”这个对象，如果有，就让str指向那个“hello”。</p>
<p>如果内存里没有”hello”，就创建一个新的对象保存”hello”.String str&#x3D;new String（“hello”）就是不管内存里是不是已经有”hello”这个对象，都新建一个对象保存”hello”。</p>
<h5 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h5><p>&#x3D;&#x3D;：对象地址，基本数据类型 &#x3D;&#x3D; 比较的是值，引用数据类型&#x3D;&#x3D;比较的是内存地址</p>
<p>equals：没有重写，同&#x3D;&#x3D;。重写了，则是比较内容是否相同，而不是地址。</p>
<h5 id="插播："><a href="#插播：" class="headerlink" title="插播："></a>插播：</h5><p>如果两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？</p>
<p>不对，两个对象的 hashCode()相同，equals()不一定 true。显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，<strong>hashCode()相等即两个键值对的哈希值相等</strong>，然而哈希值相等，并不一定能得出键值对相等。</p>
<h3 id="7-Java中的内部类"><a href="#7-Java中的内部类" class="headerlink" title="7. Java中的内部类"></a>7. Java中的内部类</h3><img src="/2022/10/08/String/7.png" class="" title="This is an image">

<p><strong>成员内部类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Draw</span> &#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawSahpe</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;drawshape&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以<strong>无条件访问外部类的所有成员属性和成员方法</strong>（包括private成员和静态成员）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span><span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Draw</span> &#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawSahpe</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></span><br><span class="line">            System.out.println(count);   <span class="comment">//外部类的静态成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生<strong>隐藏现象</strong>，即<strong>默认</strong>情况下<strong>访问</strong>的是<strong>成员内部类</strong>的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">外部类.<span class="built_in">this</span>.成员变量</span><br><span class="line">外部类.<span class="built_in">this</span>.成员方法</span><br></pre></td></tr></table></figure>

<p>虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Circle</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> <span class="variable">radius</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Circle</span><span class="params">(<span class="type">double</span> radius)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.radius = radius;</span><br><span class="line">        getDrawInstance().drawSahpe();   <span class="comment">//必须先创建成员内部类的对象，再进行访问</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">private</span> Draw <span class="title function_">getDrawInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Draw</span>();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Draw</span> &#123;     <span class="comment">//内部类</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">drawSahpe</span><span class="params">()</span> &#123;</span><br><span class="line">            System.out.println(radius);  <span class="comment">//外部类的private成员</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="comment">//第一种方式：</span></span><br><span class="line">        <span class="type">Outter</span> <span class="variable">outter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>();</span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> outter.<span class="keyword">new</span> <span class="title class_">Inner</span>();  <span class="comment">//必须通过Outter对象来创建</span></span><br><span class="line">         </span><br><span class="line">        <span class="comment">//第二种方式：</span></span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner1</span> <span class="operator">=</span> outter.getInnerInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outter</span><span class="params">()</span> &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> Inner <span class="title function_">getInnerInstance</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(inner == <span class="literal">null</span>)</span><br><span class="line">            inner = <span class="keyword">new</span> <span class="title class_">Inner</span>();</span><br><span class="line">        <span class="keyword">return</span> inner;</span><br><span class="line">    &#125;</span><br><span class="line">      </span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Inner</span><span class="params">()</span> &#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，<strong>如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问</strong>。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。</p>
<p><strong>局部内部类</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">People</span><span class="params">()</span> &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Man</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Man</span><span class="params">()</span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">public</span> People <span class="title function_">getWoman</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">class</span> <span class="title class_">Woman</span> <span class="keyword">extends</span> <span class="title class_">People</span>&#123;   <span class="comment">//局部内部类</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">age</span> <span class="operator">=</span><span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Woman</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。</p>
<p><strong>匿名内部类</strong></p>
<p>匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">scan_bt.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">             </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">         </span><br><span class="line">        history_bt.setOnClickListener(<span class="keyword">new</span> <span class="title class_">OnClickListener</span>() &#123;</span><br><span class="line">             </span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                 </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<p>这里new onClickListener()就是匿名内部类</p>
<p>就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">setListener</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    scan_bt.setOnClickListener(<span class="keyword">new</span> <span class="title class_">Listener1</span>());       </span><br><span class="line">    history_bt.setOnClickListener(<span class="keyword">new</span> <span class="title class_">Listener2</span>());</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Listener1</span> <span class="keyword">implements</span> <span class="title class_">View</span>.OnClickListener&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Listener2</span> <span class="keyword">implements</span> <span class="title class_">View</span>.OnClickListener&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onClick</span><span class="params">(View v)</span> &#123;</span><br><span class="line">    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">             </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。</p>
<p>　　匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。</p>
<p><strong>静态内部类</strong></p>
<p>静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        Outter.<span class="type">Inner</span> <span class="variable">inner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>.Inner();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Outter</span><span class="params">()</span> &#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Inner</span><span class="params">()</span> &#123;</span><br><span class="line">             </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h5><p>为什么在Java中需要内部类？总结一下主要有以下四点：</p>
<p>1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整，</p>
<p>2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。</p>
<p>3.方便编写事件驱动程序</p>
<p>4.方便编写线程代码</p>
<p>个人觉得第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善。</p>
<h5 id="面试笔试题"><a href="#面试笔试题" class="headerlink" title="面试笔试题"></a>面试笔试题</h5><h5 id="1-根据注释填写-1-，-2-，-3-处的代码"><a href="#1-根据注释填写-1-，-2-，-3-处的代码" class="headerlink" title="1.根据注释填写(1)，(2)，(3)处的代码"></a>1.根据注释填写(1)，(2)，(3)处的代码</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">           <span class="comment">// 初始化Bean1</span></span><br><span class="line">           (<span class="number">1</span>)</span><br><span class="line">           bean1.I++;</span><br><span class="line">           <span class="comment">// 初始化Bean2</span></span><br><span class="line">           (<span class="number">2</span>)</span><br><span class="line">           bean2.J++;</span><br><span class="line">           <span class="comment">//初始化Bean3</span></span><br><span class="line">           (<span class="number">3</span>)</span><br><span class="line">           bean3.k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bean1</span>&#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="variable">I</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">class</span> <span class="title class_">Bean2</span>&#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="variable">J</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bean</span>&#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Bean3</span>&#123;</span><br><span class="line">           <span class="keyword">public</span> <span class="type">int</span> <span class="variable">k</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。</p>
<p>创建静态内部类对象的一般形式为： 外部类类名.内部类类名 xxx &#x3D; new 外部类类名.内部类类名()</p>
<p>创建成员内部类对象的一般形式为： 外部类类名.内部类类名 xxx &#x3D; 外部类对象名.new 内部类类名()</p>
<p>因此，（1），（2），（3）处的代码分别为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 成员内部类</span><br><span class="line"><span class="type">Test</span> <span class="variable">test</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>();    </span><br><span class="line">Test.<span class="type">Bean1</span> <span class="variable">bean1</span> <span class="operator">=</span> test.<span class="keyword">new</span> <span class="title class_">Bean1</span>();   </span><br><span class="line"># 静态内部类</span><br><span class="line">Test.<span class="type">Bean2</span> <span class="variable">b2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Test</span>.Bean2();</span><br><span class="line"># 局部内部类</span><br><span class="line"><span class="type">Bean</span> <span class="variable">bean</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Bean</span>();     </span><br><span class="line">Bean.<span class="type">Bean3</span> <span class="variable">bean3</span> <span class="operator">=</span>  bean.<span class="keyword">new</span> <span class="title class_">Bean3</span>();   xw</span><br></pre></td></tr></table></figure>

<h5 id="2-下面这段代码的输出结果是什么？"><a href="#2-下面这段代码的输出结果是什么？" class="headerlink" title="2.下面这段代码的输出结果是什么？"></a>2.下面这段代码的输出结果是什么？</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  &#123;</span><br><span class="line">        <span class="type">Outter</span> <span class="variable">outter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Outter</span>();</span><br><span class="line">        outter.<span class="keyword">new</span> <span class="title class_">Inner</span>().print();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Outter</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span> &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">print</span><span class="params">()</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">3</span>;</span><br><span class="line">            System.out.println(<span class="string">&quot;局部变量：&quot;</span> + a);</span><br><span class="line">            System.out.println(<span class="string">&quot;内部类变量：&quot;</span> + <span class="built_in">this</span>.a);</span><br><span class="line">            System.out.println(<span class="string">&quot;外部类变量：&quot;</span> + Outter.<span class="built_in">this</span>.a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>最后补充一点知识：关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点：</p>
<p>1）成员内部类的引用方式必须为 Outter.Inner.</p>
<p>2）构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">WithInner</span> &#123;</span><br><span class="line">    <span class="keyword">class</span> <span class="title class_">Inner</span>&#123;</span><br><span class="line">         </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">InheritInner</span> <span class="keyword">extends</span> <span class="title class_">WithInner</span>.Inner &#123;</span><br><span class="line">      </span><br><span class="line">    <span class="comment">// InheritInner() 是不能通过编译的，一定要加上形参</span></span><br><span class="line">    InheritInner(WithInner wi) &#123;</span><br><span class="line">        wi.<span class="built_in">super</span>(); <span class="comment">//必须有这句调用</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">WithInner</span> <span class="variable">wi</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">WithInner</span>();</span><br><span class="line">        <span class="type">InheritInner</span> <span class="variable">obj</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">InheritInner</span>(wi);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="总结：-3"><a href="#总结：-3" class="headerlink" title="总结："></a>总结：</h5><p>成员内部类：在另一个类内部</p>
<p>局部内部类：方法或者一个作用域里，与成员内部类区别：访问权限只局限于方法内或作用域</p>
<p>匿名内部类：唯一一种没有构造器的类，用于实现接口</p>
<p>静态内部类：在另一个类里，与成员内部类区别：不过多了一个关键字static</p>
<h3 id="8-Java有哪些修饰符？有哪些区别？"><a href="#8-Java有哪些修饰符？有哪些区别？" class="headerlink" title="8. Java有哪些修饰符？有哪些区别？"></a>8. Java有哪些修饰符？有哪些区别？</h3><p>Java中的修饰符有public、private、protected.</p>
<p>1、public：public表明该数据成员、成员函数对所有用户开放的，所有用户都可以直接进行调用<br>2、private：private表示私有、私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用。<br>3、protected：protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他外部class，protected就变成private。</p>
<h5 id="总结：-4"><a href="#总结：-4" class="headerlink" title="总结："></a>总结：</h5><table>
<thead>
<tr>
<th><strong>访问级别</strong></th>
<th><strong>访问控制修饰符</strong></th>
<th><strong>同类</strong></th>
<th><strong>同包</strong></th>
<th><strong>子类(不同包)</strong></th>
<th><strong>不同包(其他类)</strong></th>
</tr>
</thead>
<tbody><tr>
<td>公共</td>
<td>public</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
</tr>
<tr>
<td>受保护</td>
<td>protected</td>
<td>允许</td>
<td>允许</td>
<td>允许</td>
<td>不允许</td>
</tr>
<tr>
<td>默认</td>
<td>缺省修饰符</td>
<td>允许</td>
<td>允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
<tr>
<td>私有</td>
<td>private</td>
<td>允许</td>
<td>不允许</td>
<td>不允许</td>
<td>不允许</td>
</tr>
</tbody></table>
<p>public: 全</p>
<p>private：只能类内</p>
<p>protected：不能不同包</p>
<h4 id="追问：怎么获取private修饰的变量"><a href="#追问：怎么获取private修饰的变量" class="headerlink" title="追问：怎么获取private修饰的变量"></a>追问：怎么获取private修饰的变量</h4><p>Private通过反射获取，可以设置setAccessable为true实现</p>
<p>下面是某博客的例子，只是一个演示用法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@Description</span>: 反射</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: Mr_VanGogh</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Reflect</span> &#123;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> age;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Reflect</span><span class="params">(<span class="type">int</span> age)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">speak</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;My name is&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Reflect</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Class</span> <span class="variable">clz</span> <span class="operator">=</span> Class.forName(<span class="string">&quot;com.chenshuyi.reflect.Apple&quot;</span>);</span><br><span class="line"><span class="type">Method</span> <span class="variable">method</span> <span class="operator">=</span> clz.getMethod(<span class="string">&quot;setPrice&quot;</span>, <span class="type">int</span>.class);</span><br><span class="line"><span class="type">Constructor</span> <span class="variable">constructor</span> <span class="operator">=</span> clz.getConstructor();</span><br><span class="line"><span class="type">Object</span> <span class="variable">object</span> <span class="operator">=</span> constructor.newInstance();</span><br><span class="line">method.invoke(object, <span class="number">4</span>);</span><br></pre></td></tr></table></figure>

<p>首先，我们要了解三个反射包中的类：</p>
<ul>
<li>Constructor：代表类的单个构造方法，通过Constructor我们可执行一个类的某个构造方法（有参或者无参）来创建对象时。</li>
<li>Method：代表类中的单个方法，可以用于执行类的某个普通方法，有参或无参，并可以接收返回值。</li>
<li>Field：代表类中的单个属性，用于set或get属性</li>
<li>AccessibleObject：以上三个类的父类，提供了构造方法，普通方法，和属性的访问控制的能力。</li>
</ul>
<p>使用Class类中的方法可以获得该类中的所有Constructor对象，Method对象，和Field对象。但是任然无法访问私有化的构造方法，普通方法，和私有属性，此时我们可以使用他们继承父类(AccessibleObject)中的setAccessible（）方法，来设置或取消访问检查，以达到访问私有对象的目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>  <span class="keyword">throws</span> Exception &#123;</span><br><span class="line"> </span><br><span class="line">        <span class="type">Reflect</span> <span class="variable">reflect</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Reflect</span>(<span class="string">&quot;a&quot;</span>);</span><br><span class="line"> </span><br><span class="line">        Method[] methods = Reflect.class.getMethods();</span><br><span class="line">        Field[] fields = Reflect.class.getDeclaredFields();</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; fields.length; i ++) &#123;</span><br><span class="line">            fields[i].setAccessible(<span class="literal">true</span>);</span><br><span class="line">            System.out.println(fields[i].getName());</span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; methods.length; j ++) &#123;</span><br><span class="line">            methods[j].setAccessible(<span class="literal">true</span>);</span><br><span class="line">            System.out.println(methods[j].getName());</span><br><span class="line"> </span><br><span class="line">            methods[j].invoke(reflect);</span><br><span class="line">            System.out.println(methods[j].getName());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="9-Java的异常体系说一下？"><a href="#9-Java的异常体系说一下？" class="headerlink" title="9. Java的异常体系说一下？"></a>9. Java的异常体系说一下？</h3><img src="/2022/10/08/String/8.png" class="" title="This is an image">

<p>Java中的异常主要分为Error和Exception</p>
<p><strong>Error</strong>指Java程序运行错误，如果程序在启动时出现Error，则启动失败；如果程序运行过程中出现Error，则系统将退出程序。出现Error是系统的内部错误或资源耗尽，Error不能在程序运行过程中被动态处理，一旦出现Error，系统能做的只有记录错误的原因和安全终止。 AWTError &#x2F; ThreadDeath</p>
<p><strong>Exception</strong>指Java程序运行异常，在运行中的程序发生了程序员不期望发生的事情，可以被Java异常处理机制处理。Exception也是程序开发中异常处理的核心，可分为RuntimeException（运行时异常）和CheckedException（检查异常），如下图所示。</p>
<ul>
<li>RuntimeException （Unchecked Exception）（运行时异常）：指在Java虚拟机正常运行期间抛出异常，RuntimeException可以被捕获并处理，如果出现情况，我们需要抛出异常或者捕获并处理异常。常见的有NullPointerExcception, ClassCastException, ArrayIndexOutOfBoundsException等</li>
<li>CheckedException（检查异常）：指在编译阶段Java编译器检查CheckedException异常，并强制程序捕获和处理此类异常，要求程序在可能出现异常的地方通过try catch语句块捕获异常并处理异常。常见的有由于I&#x2F;O错误导致的IOException、SQLException、ClassNotFoundException等。该类异常通常由于打开错误的文件、SQL语法错误、类不存等引起。</li>
</ul>
<h5 id="总结：-5"><a href="#总结：-5" class="headerlink" title="总结："></a>总结：</h5><p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p>
<p><strong>Error</strong>：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获不建议通过<code>catch</code>捕获 。例如 Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。</p>
<p><strong>Exception</strong>：程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。</p>
<h5 id="异常的处理方式？"><a href="#异常的处理方式？" class="headerlink" title="异常的处理方式？"></a>异常的处理方式？</h5><p>异常处理方式有<strong>抛出异常</strong>和<strong>使用try catch语句块</strong>捕获异常两种方式。<br>（1）<strong>抛出异常</strong>：遇到异常时不进行具体的处理，直接将异常抛给调用者，让调用者自己根据情况处理。抛出异常的三种方式：throws、throw和系统自动抛出异常。其中throws作用在方法上，用于定义方法可能抛出的异常；throw作用在方法内，表示明确抛出一个异常。<br>（2）<strong>使用try catch捕获并处理异常：</strong>使用try catch捕获异常能够针对性的处理每种可能出现的异常，并在捕获到异常后根据不同的情况做不同的处理。其使用过程比较简单，用try catch语句块可能出现异常的代码包起来即可。</p>
<h3 id="10-Java中的深拷贝和浅拷贝说一下？"><a href="#10-Java中的深拷贝和浅拷贝说一下？" class="headerlink" title="10. Java中的深拷贝和浅拷贝说一下？"></a>10. Java中的深拷贝和浅拷贝说一下？</h3><p>深拷贝和浅拷贝都是对象拷贝</p>
<p><strong>浅拷贝</strong>：按位拷贝对象，它会创建一个<strong>新对象</strong>，这个对象有着原始对象属性的一份精确拷贝。如果属性是<strong>基本类型</strong>，拷贝的就是基本类型的值；如果属性是<strong>内存地址</strong>（引用类型），拷贝的就是内存地址，因此如果其中一个对象改变了这个地址，就会<strong>影响</strong>到另一个对象。（浅拷贝仅仅复制所考虑的对象，而不是复制它所引用的对象）。</p>
<p><strong>深拷贝</strong>：在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。（深拷贝把要复制的对象所引用的对象都复制了一遍。）</p>
<h5 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h5><p>浅拷贝特点<br>（1）：对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个。<br>（2）对于引用类型，比如数组或者类对象，因为引用类型是引用传递，所以浅拷贝只是把内存地址赋值给了成员变量，它们指向了同一内存空间。改变其中一个，会对另外一个也产生影响。</p>
<p>深拷贝特点<br>（1）对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个（和浅拷贝一样）。<br>（2）对于引用类型，比如数组或者类对象，深拷贝会创建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。<br>（3）对于有多层对象的，每个对象都需要实现<strong>Cloneable</strong>并重写<strong>clone（）</strong>方法，进而实现了对象的串行层层拷贝。<br>（4）深拷贝相比于浅拷贝速度较慢并且花销较大。</p>
<h4 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h4><p>[1]: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/dolphin0520/p/3811445.html">https://www.cnblogs.com/dolphin0520/p/3811445.html</a>	“Java内部类详解”<br>[2]: <a target="_blank" rel="noopener" href="https://www.nowcoder.com/discuss/916143">https://www.nowcoder.com/discuss/916143</a>	“Java超高频面试题汇总”<br>[3]: <a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903790089338887">https://juejin.cn/post/6844903790089338887</a>	“你真的懂&#x3D;&#x3D;和equals的区别吗？”<br>[4]: 	“《java编程思想》”</p>
<p>[5]: <a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1886994">https://cloud.tencent.com/developer/article/1886994</a>	“面试官：private修饰的方法可以通过反射访问，那么private的意义是什么？”<br>[6]: <a target="_blank" rel="noopener" href="https://javaguide.cn/java/basis/java-basic-questions-01.html#">https://javaguide.cn/java/basis/java-basic-questions-01.html#</a>	“JavaGuide”</p>
<p>[7]: <a target="_blank" rel="noopener" href="https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html">https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html</a>	“大白话说Java反射：入门、使用、原理”<br>[8]: <a target="_blank" rel="noopener" href="https://blog.csdn.net/u012723673/article/details/80613557">https://blog.csdn.net/u012723673/article/details/80613557</a>	“Java中各类修饰符的使用总结（看完这篇就够了）”</p>
</div><div class="article-licensing box"><div class="licensing-title"><p>Java Basics</p><p><a href="http://example.com/2022/10/08/String/">http://example.com/2022/10/08/String/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Liny</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2022-10-08</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-11-09</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icons" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="icon fab fa-creative-commons"></i></a><a class="icons" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="icon fab fa-creative-commons-by"></i></a><a class="icons" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="icon fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Java/">Java</a></div><!--!--></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" href="https://www.buymeacoffee.com/1093742432A" target="_blank" rel="noopener" data-type="buymeacoffee"><span class="icon is-small"><i class="fas fa-coffee"></i></span><span>Buy me a coffee</span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2022/10/10/ModularJs/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">ModularJs</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2022/10/08/%E9%83%A8%E7%BD%B2Hexo/"><span class="level-item">Deploy Hexo</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div id="comment-container"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.css"><script src="https://cdn.jsdelivr.net/npm/gitalk@1.7.2/dist/gitalk.min.js"></script><script>var gitalk = new Gitalk({
            id: "44d67f9e0ee2ccaf0481729abd372788",
            repo: "NewBlogComments",
            owner: "Liny777",
            clientID: "c215c3a16d68cf01d606",
            clientSecret: "056d890e249979b3eaabf0777d9780624b3d66d7",
            admin: ["Liny777"],
            createIssueManually: false,
            distractionFreeMode: false,
            perPage: 10,
            pagerDirection: "last",
            
            
            enableHotKey: true,
            
        })
        gitalk.render('comment-container')</script></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-4-widescreen  order-1 is-sticky"><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Java基础知识高频问题"><span class="level-left"><span class="level-item">1</span><span class="level-item">Java基础知识高频问题</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#1-面向对象三大特征"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">1. 面向对象三大特征</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#封装"><span class="level-left"><span class="level-item">1.1.1</span><span class="level-item">封装</span></span></a></li><li><a class="level is-mobile" href="#继承"><span class="level-left"><span class="level-item">1.1.2</span><span class="level-item">继承</span></span></a></li><li><a class="level is-mobile" href="#多态"><span class="level-left"><span class="level-item">1.1.3</span><span class="level-item">多态</span></span></a></li><li><a class="level is-mobile" href="#总结"><span class="level-left"><span class="level-item">1.1.4</span><span class="level-item">总结</span></span></a></li></ul></li><li><a class="level is-mobile" href="#2-重载和重写"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">2. 重载和重写</span></span></a></li><li><a class="level is-mobile" href="#3-抽象类和接口的区别"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">3. 抽象类和接口的区别</span></span></a></li><li><a class="level is-mobile" href="#4-Final修饰类、方法、字段分别起到的作用？"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">4. Final修饰类、方法、字段分别起到的作用？</span></span></a></li><li><a class="level is-mobile" href="#5-String-VS-StringBuffer-VS-StringBuilder"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">5. String VS StringBuffer VS StringBuilder</span></span></a></li><li><a class="level is-mobile" href="#6-说一下Java中的-x3D-x3D-与eaquels的区别"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">6. 说一下Java中的==与eaquels的区别</span></span></a></li><li><a class="level is-mobile" href="#7-Java中的内部类"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">7. Java中的内部类</span></span></a></li><li><a class="level is-mobile" href="#8-Java有哪些修饰符？有哪些区别？"><span class="level-left"><span class="level-item">1.8</span><span class="level-item">8. Java有哪些修饰符？有哪些区别？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#追问：怎么获取private修饰的变量"><span class="level-left"><span class="level-item">1.8.1</span><span class="level-item">追问：怎么获取private修饰的变量</span></span></a></li></ul></li><li><a class="level is-mobile" href="#9-Java的异常体系说一下？"><span class="level-left"><span class="level-item">1.9</span><span class="level-item">9. Java的异常体系说一下？</span></span></a></li><li><a class="level is-mobile" href="#10-Java中的深拷贝和浅拷贝说一下？"><span class="level-left"><span class="level-item">1.10</span><span class="level-item">10. Java中的深拷贝和浅拷贝说一下？</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#参考链接"><span class="level-left"><span class="level-item">1.10.1</span><span class="level-item">参考链接</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo2.png" alt="Undateable" height="28"></a><p class="is-size-7"><span>&copy; 2023 Liny</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/Liny777"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/cookieconsent@3.1.1/build/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.10.0/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.8.1/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>