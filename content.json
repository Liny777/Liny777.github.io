{"posts":[{"title":"ModularJs","text":"Modular Javascript - Javascript Tutorial on the Object Literal PatternModular Javascript Cover how to build a basic module in javascript. 1、Object-LiteralThe simplest pattern for modular javascript is the object literal pattern - it adds all values and methods on a single object, thus encapsulating all of the module’s function into one object. The downside of this pattern, is it leaves all of the module’s data accessible. Clean it up into a self-encapsulated module that is easy to work with. Self - Encapsulated : 将一个对象封装起来 Efficient Dom Usage : 把需要操作的Dom元素进行缓存 - CacheDom function Render Method : 视频中是使用Mustache.render配合template进行渲染。 Bind Events : 给Dom元素一并添加点击事件，将每个事件独立地写在外面，bindEvent只负责绑定。 Delete Events : 记得写一个删除绑定，监听函数等的一个函数，避免内存泄漏。 12345678910111213141516171819202122232425262728293031323334353637383940var people = { people: ['Will', 'Steve'], init: function() { this.cacheDom(); this.bindEvents(); this.render(); }, cacheDom: function() { this.$el = $('#peopleModule'); this.$button = this.$el.find('button'); this.$input = this.$el.find('input'); this.$ul = this.$el.find('ul'); this.template = this.$el.find('#people-template').html(); }, bindEvents: function() { this.$button.on('click', this.addPerson.bind(this)); this.$ul.delegate('i.del', 'click', this.deletePerson.bind(this)); }, render: function() { var data = { people: this.people, }; this.$ul.html(Mustache.render(this.template, data)); }, addPerson: function() { this.people.push(this.$input.val()); this.render(); this.$input.val(''); }, deletePerson: function(event) { var $remove = $(event.target).closest('li'); var i = this.$ul.find('li').index($remove); this.people.splice(i, 1); this.render(); }};people.init(); 但是上面这种写法有个缺点，可以直接在浏览器控制台去调用API直接操控对象元素。我们不想用户能够调用render、cacheDom等函数，只希望他们能够调用addPerson和DeletePerson，因此我们在给上面对象封装一层，只暴露出安全的想给用户用的接口。 We write a revealing module pattern by starting with a self-executing anonymous function also known as an IIFE (immediately invoked function expression). This runs a function and sets it’s return value as our module’s value. If we return an object of methods, then those methods are what other modules have “public” access to. What’s nice about this, is we can create any variables within the function and no other modules have access to them unless we expose them via our return object. 方法：(function(){})() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var people = (function(){ var people = ['Will', 'Steve']; //cache DOM var $el = $('#peopleModule'); var $button = $el.find('button'); var $input = $el.find('input'); var $ul = $el.find('ul'); var template = $el.find('#people-template').html(); //bind events $button.on('click', addPerson); $ul.delegate('i.del', 'click', deletePerson); _render(); // 代表私有变量 function _render() { $ul.html(Mustache.render(template, {people: people})); } // Maybe String or index or other function addPerson(value) { var name = (typeof value === &quot;string&quot;) ? value : $input.val(); people.push(name); _render(); $input.val(''); } function deletePerson(event) { var i; if (typeof event === &quot;number&quot;) { i = event; } else { var $remove = $(event.target).closest('li'); i = $ul.find('li').index($remove); } people.splice(i, 1); _render(); } return { addPerson: addPerson, deletePerson: deletePerson };})();//people.addPerson(&quot;Jake&quot;);//people.deletePerson(0); 给私有方法或变量加下划线 What kind of cool is we can keep these internal methods whatever we want to call them here’s very common thing is if something is private if it’s internal you’ll see an underscore there so let me find every where render is called and give it an underscore.Unserscore usually means it is private where we’re storing this internally we’re never exposing. 2、Pub - Subwe’ll cover the pubsub design pattern (publish/subscribe), which allows us to decouple our modules. Once integrated with our pubsub module, they can emit events and not have to worry about which modules depend on them. Modules can subscribe to events and be notified when any module publishes. 事件的格式是 key:name(Listener) | value:[event1,event2,......] This loose coupling will allow the application to grow significantly larger without encountering problems. 下面是两个模块整合在一起，但是彼此互不依赖，却可以实现一个更新另一个也更新，这就是Vue双向绑定的底层原理，逻辑层与视图层实时更新。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//events (publish subscribe) patternvar events = { events: {}, on: function (eventName, fn) { this.events[eventName] = this.events[eventName] || []; this.events[eventName].push(fn); }, off: function(eventName, fn) { if (this.events[eventName]) { for (var i = 0; i &lt; this.events[eventName].length; i++) { if (this.events[eventName][i] === fn) { this.events[eventName].splice(i, 1); break; } }; } }, emit: function (eventName, data) { if (this.events[eventName]) { this.events[eventName].forEach(function(fn) { fn(data); }); } } }; // Stats module (function(){ var people = 0; //cache DOM var $stats = $('#statsModule'); var template = $('#stats-template').html(); //bind events events.on('peopleChanged', setPeople); _render(); function _render() { $stats.html(Mustache.render(template, {people: people})); } function setPeople(newPeople) { people = newPeople; _render(); } function destroy(){ $stats.remove(); events.off('peopleChanged',setPeople) } return { destroy: destroy } })(); //people module (function(){ var people = ['Will', 'Steve']; //cache DOM var $el = $('#peopleModule'); var $button = $el.find('button'); var $input = $el.find('input'); var $ul = $el.find('ul'); var template = $el.find('#people-template').html(); //bind events $button.on('click', addPerson); $ul.delegate('i.del', 'click', deletePerson); _render(); function _render() { $ul.html(Mustache.render(template, {people: people})); events.emit(&quot;peopleChanged&quot;, people.length); } function addPerson(value) { var name = (typeof value === &quot;string&quot;) ? value : $input.val(); people.push(name); _render(); $input.val(''); } function deletePerson(event) { var i; if (typeof event === &quot;number&quot;) { i = event; } else { var $remove = $(event.target).closest('li'); i = $ul.find('li').index($remove); } people.splice(i, 1); _render(); } })(); 这里插播一下平时面试常考的发布订阅模式：实现思路 创建一个 EventEmitter 类 在该类上创建一个事件中心（Map） on 方法用来把函数 fn 都加到事件中心中（订阅者注册事件到调度中心） emit 方法取到 arguments 里第一个当做 event，根据 event 值去执行对应事件中心中的函数（发布者发布事件到调度中心，调度中心处理代码） off 方法可以根据 event 值取消订阅（取消订阅） once 方法只监听一次，调用完毕后删除缓存函数（订阅一次） 注册一个 newListener 用于监听新的事件订阅 12345678910111213141516171819202122232425262728293031323334353637class EventEmitter{ constructor(){ this._events = {}; } on(eventName, callback){ if(this._events[eventName]){ if(this.eventName !== &quot;newListener&quot;){ this.emit(&quot;newListener&quot;, eventName) } } const callbacks = this._events[eventName] || []; callbacks.push(callback); this._events[eventName] = callbacks } emit(eventName, ...args){ const callbacks = this._events[eventName] || []; callbacks.forEach(cb =&gt; cb(...args)) } // 其中once部分可以进行修改，是阿里二面的时候一位哥告诉我的, 传入callback时，传入一个匿名函数，然后里面分别先执行callback再调用off进行销毁～ once(eventName, callback){ const one = (...args)=&gt;{ callback(...args) this.off(eventName, one) } one.initialCallback = callback; this.on(eventName, one) } off(eventName, callback){ const callbacks = this._events[eventName] || [] const newCallbacks = callbacks.filter(fn =&gt; fn != callback &amp;&amp; fn.initialCallback != callback /* 用于once的取消订阅 */) this._events[eventName] = newCallbacks; }} 3、Prototypal Pattern vs Classical OOP in JS两种方法都可以实现继承，但是第二种会更简洁。 3.1 Classical OOPHere’s the link to the “inherit” function I use here: https://github.com/nodejs/node-v0.x-a... Using a constructor, a prototoype, and the “new” keyword, we can create multiple copies or “instances” of a module, each with unique properties, but shared functionality. We can also implement inheritance in Javascript. If we create a new module, we can inherit the functionality of a parent module with a simple inheritance helper function. 跟Java继承一个意思撒～ 有一个点注意一下： Friend.super_.call(this, name); 这里其实和Java抽象有点像，为了使得父子的共同属性保持一致变化，所以需要把name的this从子指向父。这样父亲name的变化，子的name也会跟着变化。（把共同属性的this指向父亲） 如果子类要拓展自己的方法，用如下写法： Musician.prototype.shoutName = function() { console.log(&quot;DUDE!!!&quot;) } 删除的时候，如下，使用delete API： delete Musician.prototype.shoutName 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// /**// * Inherit the prototype methods from one constructor into another.// *// * The Function.prototype.inherits from lang.js rewritten as a standalone// * function (not on Function.prototype). NOTE: If this file is to be loaded// * during bootstrapping this function needs to be rewritten using some native// * functions as prototype setup using normal JavaScript does not work as// * expected during bootstrapping (see mirror.js in r114903).// *// * @param {function} ctor Constructor function which needs to inherit the// * prototype.// * @param {function} superCtor Constructor function to inherit prototype from.// */// exports.inherits = function(ctor, superCtor) {// ctor.super_ = superCtor;// ctor.prototype = Object.create(superCtor.prototype, {// constructor: {// value: ctor,// enumerable: false,// writable: true,// configurable: true// }// });// };// classical prototypalfunction inherites(ctor, superCtor) { ctor.super_ = superCtor; ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });};var Person = function(name) { this.name = name}Person.prototype.sayName = function() { console.log(this.name)}Person.prototype.shoutName = function() { console.log(this.name + '!')}var john = new Person();var bobby = new Person();var Friend = function(name) { // Person.call(this,name) Friend.super_.call(this, name); }inherities(Friend, Person);var julia = new Friend(&quot;julia&quot;);julia.sayName();var Musician = function(name, instrument) { Musician.super_.call(this, name); this.instrument = instrument;}Musician.prototype.shoutName = function() { console.log(&quot;DUDE!!!&quot;)}inherites(Musician, Person);Musician.prototype.getInstrument = function() { console.log(this.instrument);}var Jason = new Musician(&quot;Jason&quot;, &quot;trombone&quot;)delete Musician.prototype.shoutName/** * The delete operator in JavaScript is used to delete an object's property. * If it is used to delete an object property that already exists, * it returns true and removes the property from the object. * However, deleting an object property that doesn't exist will not affect the object, but will still return true . */ 3.2 Prototypal PatternWhile many JS devs still use classical OOP, many have switched to the prototypal pattern for Module Inheritance and Instantiation. Here’s the prototypal pattern for JS and why some devs find it simpler to use. Basically, when coding JS OOP with the prototypal pattern, everything is an object. You start with an object literal and, then, to inherit from it, you use Object.create(someModule) to create a child that inherits from it. var parent = {some: method}; var child = Object.create(parent); //now add new methods to the child child.newMethod = someMethod; So there’s really no difference between inheritance and instantiation in the prototypal method. To create multiple children, simply: var child1 = Object.create(parent); var child2 = Object.create(parent); And there you have it! Also see the source javascript code on how to include a create method so creating is a little more seamless. 123456789101112131415161718192021222324252627282930313233343536373839// classical prototypal/*** * Define : * Object.create() method is used to create a new object with the specified prototype object and prototypes. * Object.create() method returns a new object with the specified prototype object and properties. * Application : * Object.create() is used for implementing inheritance. */var human = { species: &quot;human&quot;, // Rewrite Object.create function create: function(values) { var instance = Object.create(this); Object.keys(values).forEach(function(keys) { instance[keys] = values[keys]; }); return instance; }, saySpecies: function() { console.log(this.species); }, sayName: function() { console.log(this.name); }};var musician = Object.create(human); // inherited humanmusician.playInstrument = function() { console.log(&quot;plays...&quot; + this.instrument);}var will = Object.create(musician); // inherited musician - &gt; human will.name = &quot;Will&quot;;will.instrument = &quot;Drums&quot;;var musician2 = human.create({ species: &quot;musician&quot;, playInstrument: function() { console.log(&quot;plays&quot;+this.instrument); }}) 其他[1]: https://www.youtube.com/c/learncodeacademy “Youtuber Learncode.academy”[2]: https://juejin.cn/post/6844904101331877895 “从发布订阅模式入手读懂Node.js的EventEmitter源码”[3]: https://juejin.cn/post/6985156199192723487 “手写一个基于发布订阅模式的js事件处理中心(EventEmitter)” [4]: https://www.youtube.com/playlist?list=PLoYCgNOIyGABs-wDaaxChu82q_xQgUb4f “Modular Javascript”","link":"/2022/10/10/ModularJs/"},{"title":"Monitor-SDK","text":"本项目主要是实现一个前端监控系统，使用者将本项目开发的埋点代码放置在需要被监控的前端项目中，用户的行为数据会被记录，使用者可以通过一个中台页面监控项目情况。 一、项目介绍Root：一个轻量、快速的全栈前端监控系统。 项目地址 1 项目地址 2 Github 地址： 前端 后端 埋点 测试应用 二、项目分工 团队成员 主要贡献 郑琬仪 异常概览、总概览和其他页面和接口、页面异常捕获sdk、项目进度与其他事项 林佑光 用户细查及总概览页面、相关前后端接口、用户行为捕获sdk 田雨沛 用户详情页面、相关前后端接口、Flask后端框架搭建、项目自动化构建部署、辅助组员完成代码 熊恺杰 异常详情页面、相关前后端接口、MongoDB数据库搭建、sdk打包、辅助组员完成代码 熊康伟 性能页面、相关前后端接口、页面性能sdk 龚恒 异常详情页面、相关前后端接口、HTTP请求监控sdk及打包 三、项目实现3.1 技术选型与相关开发文档 可以补充场景分析环节，明确要解决的问题和前提假设，比如按当前选型和架构总体预计需要xxx存储空间，xxx台服务器……。 本项目主要是实现一个前端监控系统，使用者将本项目开发的埋点代码放置在需要被监控的前端项目中，用户的行为数据会被记录，使用者可以通过一个中台页面监控项目情况。 3.1.1 前端技术选型：Vue3 + Vite + TypeScript + Arco Design 3.1.2 后端Flask + MongoDB 3.1.3 监控SDKWebpack 3.1.4 其他 为提升代码的可读性和可维护性，我们在前端监控系统仓库中使用 TS + ESLint 来规范成员的代码风格；为方便统计成员每次提交的内容，使用 commitlint 来规范仓库的提交信息。 网站监控系统项目中，使用 flask+mongodb 搭建数据服务器并模拟数据；在监控SDK项目中，通过设置 webpack 的请求中间件来实现虚拟服务器。 3.2 架构设计 可以补充场景分析环节，明确要解决的问题和前提假设，比如预计0.5%的用户属于大V，粉丝很多，也会经常上传视频，当前架构的解决方案是xxx。 为了使多人协同的项目进行部署时快捷高效，我们加入了自动化部署脚本 为了在有限的时间内快速开发具有良好交互特性和较美观的 UI 的网页，我们选择了字节的Arco Design组件库 为了良好的项目和组件结构，我们根据不同需求建立文件夹（概览、异常、用户、性能）内有index.vue 以及组件文件夹以存储组件，前端架构耦合度较低，便于查找和管理 3.2.1 数据库设计 3.3 项目代码介绍 前端监控系统： 123456789101112131415161718192021222324252627282930313233343536web-monitor-dashboard├─.husky├─config└─src ├─api // api接口 ├─assets // 静态资源 ├─components // 通用组件 ├─config // 项目配置 ├─directive // 自定义指令库 ├─hooks // 前端工具 ├─layout // 基础布局 ├─locale // 中英文编码 ├─mock // 数据mock ├─router // 路由文件 │ ├─appMenus │ ├─guard │ └─routes │ └─modules // 各个页面的router ├─store // 数据存储 ├─types // 数据类型定义 ├─utils // 数据类工具 └─views ├─error // 错误页面 │ ├─issue-details // 错误详情页面 │ └─issues // 错误概览页面 ├─login // 登入页面 ├─not-found // not-found 页面 ├─overview // 概览页面 │ ├─components │ └─locale ├─performance // 性能页面 │ ├─api // api性能及详情页面 │ └─page // 页面性能及详情页面 ├─user // 用户详情页面 ├─useraction // 用户细查页面 └─userinfo 后端： 123456789101112131415161718web-monitor-backend│ requirements.txt└─api │ __init__.py ├─mock │ data_generator.py │ mock_data_forger.py ├─model // 数据表定义 │ models.py ├─route │ api.py // 其他相关接口 │ errors.py // 错误相关后端接口 │ performance.py // 性能相关后端接口 │ user.py // 用户相关后端接口 │ mock_api.py └─util data_process.py utils.py 监控系统SDK： 12345678monitorSDK └─lib blankError.js // 白屏异常 jsError.js // 脚本异常 promiseError.js // Promise 脚本异常 resource.js // 资源加载异常 stayTime.js // 监控用户行为 xhr.js // 监控request 四、测试结果 建议从功能测试和性能测试两部分分析，其中功能测试补充测试用例，性能测试补充性能分析报告、可优化点等内容。 功能测试： 用户登录、路由切换 概览页面：流量数据、用户量统计、访客量趋势、页面浏览量趋势、用户平均停留时长、异常数据总览加载 用户细查页面：用户列表显示、根据用户编号查询功能 用户详情页面：用户相关信息显示 错误概览页面：异常数据图标显示、异常数据列表及根据异常类型即网页查询功能 页面性能页面：FP、FCP、DOM Ready、DNS渲染和页面列表 接口性能页面：平均请求概览、总请求量、接口列表 自适应测试 五、Demo 演示视频 六、项目总结与反思 目前仍存在的问题 数据加载速度较慢 由于对 typescript 使用上的不熟悉，类型声明考虑不周；因人力和时间关系，已完成的通用可配置组件较少 缺少强制代码评审，再加上不同成员对代码熟练程度和风格不一致，导致页面的代码结构差异较大，代码质量可以改善。 已识别出的优化项 针对服务器性能较弱的问题，应该定时整理日志的统计信息，在请求时直接返回，而不是每次都遍历全部日志进行统计。 项目的前端页面结构和功能不够完善，其中包括：缺乏切换监控不同项目、图表中可以选择更多不同的时间维度 数据结构设计存在改进空间，性能页面需要从多个表中获取不同的数据 架构演进的可能性 项目过程中的反思与总结 大部分同学对ts、python、github操作不是很熟悉 直接使用Arco Design Pro的代码为框架，但由于对代码的框架不是很熟悉导致出现问题 后期没有实时跟踪成员的进度，导致不能在成员出现代码困难第一时间发现 总结：经过这次项目，对前端监控的认识加深了很多，同时也进一步需要根据不同组员的能力进行良好和清晰的分工的重要性，尽管我们在很早就开始大项目，但是由于并没有很好组织代码提交进度，也面对了很多问题。无论如何，在大家的共同努力下依然完成了这次的大项目，辛苦大家了！ 没有进行批量上传 传输加密 sourceMap上传 sendBean上传请求 页面关闭的pv uv统计问题 七、其他补充资料（选填）我的部分：用户行为PV：用户浏览量 UV：独立访客数 用户停留时长：用户在页面的停留时长 获取方法： 通过监听事件，获取用户跳转页面的行为，然后将跳转页面，用户停留时间等参数发给后端，这个时候已经获取到页面停留时间，同时可以获取pv，因为我们这里简化一下，浏览量只包括浏览页面的话，那每跳转一个页面就是一个浏览量，pv就+1，然后uv就只要对当天的统计的pv采集到的userid进行去重就可以拿到，或者直接到数据库里进行获取就好。 监听页面跳转方法：主要分为两种情况，单页面与多页面应用 单页面SPA：分为Hash模式，History模式 Hash：基于浏览器的hashchange事件，地址变化时，通过window.location.hash 获取地址上的hash值；并通过构造Router类，配置routes对象设置hash值与对应的组件内容。 History：基于HTML5新增的pushState()和replaceState()两个api，以及浏览器的popstate事件，地址变化时，通过window.location.pathname找到对应的组件。并通过构造Router类，配置routes对象设置pathname值与对应的组件内容 多页面MPA： 主要基于**onpageshow(页面显示的时候)和onpagehide(页面隐藏的时候)这两个API获取用户停留的时长。只要在onpageshow初始时间值，在onpagehide**的时间求出差值，然后上传到后台就行。但是目前没有考虑用户直接关闭浏览器的情况。 登录获取用户信息： 在安装SDK时，会先判断**localStorage里是否有用户ID，如果没有，会将请求页面发送给后端，然后后端获取用户的操作系统，设备信息以及IP信息后创建一个新用户并将新用户的ID返回给前端，前端获取到用户ID后将其存放于localStorage中。如果一开始就有用户ID，就直接从localStorage** 中获取。 需求自动收集、上报、存储页面关键数据，并提供监控数据可视化查询界面，要求覆盖Web页面关键运行数据，包括： 异常监控，包括：JS异常、接口异常、白屏异常、资源异常等 关键性能数据监控，如：FP、FCP、DOM Ready、DNS等 用户行为数据，如：PV、UV、页面停留时间等 HTTP请求监控、包括：请求链路、成功率、返回信息等 视图要求 PV/UV 趋势图 各性能数据走势图 异常数据&amp;归因分析展示 参考 https://help.aliyun.com/document_detail/58652.html https://sentry.io/welcome/ https://github.com/getsentry/sentry http://www.webfunny.cn/demo/home.html https://github.com/a597873885/webfunny_monitor.git","link":"/2022/09/01/Monitor-SDK/"},{"title":"New-Energy-Car","text":"作品展示： 项目介绍：此项目为清华大学车辆与运载学院新能源汽车测试组参与的国家重点研发计划科技冬奥重点专项“氢能出行”。本人的工作是负责构建信息监控大数据平台，实时展示新能源汽车的数据信息。 主要工作： 1、使用Vue2框架搭配Echarts与百度地图通过点聚合方式显示78辆氢能源汽车的数据 2、使用Flex与Grid布局 3、使用Webpack打包与部署前端应用","link":"/2021/09/08/New-Energy-Car/"},{"title":"Reading-English","text":"文章主要包括细节题，推断题，主旨题，态度题，词义猜测题。 细节题题型概述 第一类 窄 仅涉及原文中一个或几个句子。对于此类题，根据关键词或信息在原文精确定位，将定位内容与原文信息未做曲解的同义表述即为正确答案。找1对4。 第二类 广 对文章某一段或数段甚至全文进行提问。常见考法，四个选一个正确/错误，或同意以下任意一项。这类题一般每个选项均有各自关键词，根据关键词在原文进行定位，寻找相关信息，对比选项和原文，排除干扰项。相当于 找4对4。 细节题常用提问方式：Which of the following is NOT true ? Which of the following is NOT mentioned ? The main reason for … is … According to the author … 解题思路 （1）定位。两种方法。 一是关键词定位，可以从专有名词（人名，地名）、时间、数字、修饰词，如果没有关键词，可以按照名词、动词、形容词的顺序选定关键词。 ​ 二是顺序法。大部分题目的题目顺序与文章顺序基本一致。（2）对比文章和选项。 ​ 即根据题干，找到与原文信息对应的正确选项。 正确项和干扰项的特征正确项是原文的同义转述或改写，即对原文的重新加工，用不同的词语或句型表达相同的意思。 干扰项具有以下特征： （1）偷换概念：提到原文内容，还包含与原文不相符的。（一半一半） （2）答非所问：虽是原文信息，但不符合题目要求。（马嘴不对牛头） （3）以偏概全：扩大适用范围，即将原文中只适用于部分的情况变成适用于全部。（局部代替整体） （4）无中生有：选项中出现了原文没有提到或推导不出的信息。（压根就没这东西） （5）正反混淆：选项与原文相反。（颠倒是非） （6）过于绝对：选项中出现了表现绝对意义的词语，only,never,all,everything,nobody等。 （7）逻辑颠倒：看似原文推断出来的结论，实际上与原文不符，例如选项中涉及的因果关系与原文所说的因果关系正好相反。 推断题题型概述 占比重较大 考察考生推测作者字里行间言外之意。要求对文章深层推理和理解。 推断题常用的提问方式：What is implied by the guidelines ? What can be inferred from the information ? What can be inferred from the information ? What will probably happen when … 解题思路 （1）以原文为基础，但不拘泥于文章字面意思，要根据已知信息推导未知信息。 （2）弄清上下文逻辑，从文意和逻辑推理。 （3）注意间接表达的句子，这些句子常采用比喻、反语方式，其背后通常蕴藏着需要探索的意义。 （4）注意结构复杂或语义深刻的句子，这些句子需要谨慎对待，读出弦外之意。 正确项和干扰项的特征 正确项 （1）大多含义深刻，更具综合性和概括性。 （2）有时会与通过常识得出结论相反。 （3）正确项一般不会使用绝对词语，而是非绝对，比如often,usually,sometimes,some,may,might,can,could,possibly,probably等。 干扰项 （1）只是原文简单复述，而非推断的结论。 （2）虽然符合常识，但不是基于原文。（同正确的2） （3）推理过度，概括过度。 （4）看似由原文推断，实际与原文不符。 （5）过于绝对。（同正确3) （6）由文中信息杂糅而成，非原文真实意思的表达。 主旨题题型概述考查考生综合、概括、归纳和分析能力。题干标志词main idea, subject, the best title, topic, purpose, summay等。该题型可细分为段落主旨题和全文主旨题。在银行招聘考试中，常考的为全文主旨题。 针对某一段或几段的主题进行提问。常用的提问方式有： 段落主旨题 全文主旨题 In the first paragraph/Paragraph X, the author discusses …We learn from Paragraph X that …Which of the following is true according to Paragraph X ? What would be the best title for this passage ?What is the passage mainly about ?What is the main idea of the article ?The main purpose of the passage is to …Which of the following is this passage mainly about ?Which of the statements can best reflect the main idea of this passage ? 解题技巧对于主旨题，考生在阅读文章时要特别留意以下几处： （1）文章的首段和尾段，通常为文章主旨出现最频繁之处。（2）每段的首句和尾句，通常是段落主旨出现的地方。 （3）文章或段落中出现转折的地方，转折所在句往往揭示了作者真实的写作目的或基本观点，即文章的中心思想所在。 （4）作者有意识地反反复复的观点通常是文章主旨。反复提到的词，一般是体现中心思想的核心词。 （5）如果文章中没有明确的主旨句，考生可通过归纳各段的主要内容，进而确定文章主题。 正确项和干扰项的特征 正确项 干扰项 （1）较全面、有针对性地表达文章或段落的中心思想。（2）若文章或段落含有明确的中心句，则与之意思相近的为正确项。（3）常包含文中反复出现的主题词、关键词或抽象意义的词语。 （1）以偏概全，只涉及文章某一细节，非文章或段落中心意思。（2）当问及全文主旨时，选项只是某一段落的大意。（3）概括范围太过宽泛，超出了文章阐述的范围，或者与文章内容无关。 态度题题型概述考查作者或文章中所涉及人物对于文章的主题或涉及的某一现、问题所表现出来的态度。态度题干中通常会出现attitude、opinion、tone等标志词 常见的提问方式有以下几种： What is the author’s attitude towards … ? How would you describe … attitude towards … ? What is the tone(mood) of the passage ? The author’s attitude towards … seems to be … Which of the following best describes the author’s attitude towards … 解题策略 （1）不要将自己的态度掺杂其中，同时还要注意区分作者本人态度和作者引用观点的态度。 （2）作者态度一般与文章主旨相关联，支持某一事物与否应视其与主旨的一致程度而定。作者态度基本不会是漠不关心，所以indifferent, uninterested, impassive, unconcerned等词一般不是正确选项. （3）当作者的态度没有明确显露时，考生要学会根据作者语言的褒贬去判断作者的态度，通过阅读全文来把握文章的主旨和感情基调 （等于没说～） （4）表示“客观“的词多为正确选项，如objective, impartial, unbiased，unprejudiced等。在阅读中，明白作者的语气，观点，态度，立场以及其他人物观点之间的关系，可以帮助考生准确理解文章的主旨。这些观点、态度有的很直白地表现出来，有的则隐藏在字里行间，需要通过阅读全文，把握主旨来判断。 正确项和干扰项的特征干扰项： （1）望文生义，拘泥于表面意思，非原文真实意图的表达。 （2）将其他人物态度错置于作者身上。 （3）无中生有，编造事实或曲解原文。 积极 informative : 有教益的 promising ：有希望的 persuasive：有说服力的 消极 Adverse : 不利的 subjective : 主观的 ironic：讽刺的 客观 disinterested : 公正的，无私的 中立，不关心 impassive 冷漠 uninterested 冷淡 词义猜测题题型概述考查考生根据上下文推断单词或短语意思的能力。所考查词汇一般有两种情况：一是超纲词；二是熟词生义。 解题技巧 对于完全陌生单词 （1）通过语境猜。通过上下文和文章主题的逻辑关系。从对两种事物或现象对比描述中，推断出词义。 （2）根据定义猜测词义。定义：用一个句子或者段落给生词定义；使用破折号、冒号后面的内容或者引号、括号中的内容对生词加以解释或者定义。（前提得有给） （3）通过经验及生活常识猜测词义。在阅读文章的基础上利用自己对日常生活的理解和判断对单词含义进行猜测。 对于熟悉单词 （1）代入检验法：如果选项中的单词都认识，可以分别代入原文，检查一下是否符合逻辑。 （2）词汇关系法：查看是否有特定的搭配或者逻辑关系。 （3）句子关系：根据语法结构和句子逻辑关系判断文章中句子关系是顺接还是逆接，话题和感情色彩是相同还是相反。 注意语法，句子结构，标点符号，文字描述等。 错题反思注意高频词，主旨题选项，出现的高频词如果与文中的不一样，比如IQ Scores，选项是IQ Test就可以先排除，。 细节题有一些选项是要推测的，并且答案可能在后面，不要用近义词代替，比如文中是healthier eating，选项是nutrition, 所以不能选，不能把营养和健康饮食等同起来 = =","link":"/2020/10/11/Reading-English/"},{"title":"Graph-Database-Visualization","text":"技术栈：前端：Vue + Echarts + Element-UI 后端：SpringBoot + HugeGraph 项目介绍：本项目是我的本科毕设，背景是实验室与协和医院合作开发智能医疗项目，旨在提高就诊效率等。本人的工作是将存在图数据库里的医学数据通过可视化的方式呈现出来，方便病人查阅相关医学资料。主要工作： 1、利用Vue2+Echarts+Element-UI实现可视化界面 2、运用Springboot实现后端查询数据接口 3、运用拦截器和JWT实现特定请求的登录认证和鉴权； 4、利用ExceptionHandler统一处理异常，减少代码耦合度； 作品展示： 视频展示-1： 视频展示-2: 代码地址： https://github.com/Liny777/Visualization-vue-sample","link":"/2020/09/08/Graph-Database-Visualization/"},{"title":"Reminder","text":"f4cc23558ba95030556638b09840cfb7c89f80cc2d775127ff51e6f9d8b812afe4c13d30b45aace59541ae61c00c9b6ba99f4b4aef900d5f518413938e220fd047229287db204c4ece61bb1e411f53d10e34a3a427b5831d4cb659dec9fb2327368e7f1535383abaefea0c2c6e1015c2716439fa247a9d94ebe7fd28a308d919f4703da2c89eb14a99352430028ff2e264447b5b42f5394e481c984ba8ed079d0b585f264e3e61a39fed3ba6d32187a2c0266c7c5923296e91bc0b3b622729eb07547b67d54138444703bc12b423a24b707182d9c1ce7acc8a0985522d59cc4aab1f01e1c8a71b198d64169446ec132b957ddf8c8895dceb18b9cec6f320e458ce10167846c522acff4abdac33927d17b08c0ed0f9af014a40a70353c32d0633e1297846052f44fb219f142f8fdc509a3e7f06d601da4147253be5fd240ac1d7eeeb6759fd53e29e81a1c38066ca33bf1100acae9ab071a0c9683d39d045638784fffcef8a8bf8d0e7d20f630be4ae133791357ae1ab1e4b3d274d76c0fce14c8751156272dd93126827edb5086dc640f01fad70907f994e175bc66ea4527cd369318cb28fa14a933c2998fff79da7b7 密码输入框上描述性内容","link":"/2020/10/11/Reminder/"},{"title":"Java Basics","text":"Java基础知识高频问题 😲😲😲 Java语言的三大特性是什么？ 重载与重写的区别? 接口和抽象类的区别是什么？ Java中的内部类说一下? 说一下final关键字的作用? 说一下String，StringBuilder和StringBuffer的区别? 说一下Java中的==与eaquels的区别? Java访问修饰符有哪些？都有什么区别？ 追问 怎么获取private修饰的变量 .Java中的异常体系说一下？ 追问 异常的处理方式？ .Java中的深拷贝和浅拷贝说一下？ 追问 浅拷贝与深拷贝的特点是什么？ 1. 面向对象三大特征 封装封装是指将对象的属性私有化，提供一些可以访问属性的方法，我们可以通过访问这些方法得到对象的属性。 继承继承是指某新类继承已经存在的类，该新类拥有被继承的类的所有属性和方法，并且新类可以根据自己的情况拓展属性或方法。其中新类被称为子类，原存在的类被称为父类。1、子类拥有父亲类对象所有的属性和方法（包括私有属性和私有方法），但是父类中私有属性和方法子类是无法访问，只是拥有。2、子类可以拥有自己属性和方法，即子类可以对父类进行拓展。3、子类可以用自己的方式实现父类的方法。 子类不能直接访问父类的私有属性，子类只能在父类中写一个public的getXXX的方法来获取父类中的private属性，子类就调用父类的getXXX来获取private属性 在子类的构造方法中通过super()方法调用父类的构造方法来继承到父类的私有域。 构造子类的同时，为子类构造出跟父类相同的域。如此就在子类的对象中，也拥有了父类声明的域了 多态多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作。 多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。【摘自JavaGuide】 在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。 总结封装：封装起来，只提供访问接口 继承：新继承已有的，然后根据自己情况拓展 多态：同一个行为不同表现形式（比如飞，各种飞行姿势等）- 接口 和 继承来实现 2. 重载和重写 重载：重载是发生在同一个类中，具有相同的方法名，但是有不同的参数，参数的个数不一样、参数的位置不一样、这叫做重载，常见的就比如构造方法，有参构造和无参构造。 重写：发生在当子类继承父类时，对父类中的一些方法根据自己的需求进行重写操作。 父类方法被默认修饰时，只能在同一包中，被其子类被重写，如果不在同一包则不能重写。 父类的方法被protoeted时，不仅在同一包中，被其子类被重写，还可以不同包的子类重写。 重写方法的规则：1）、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。 2）、返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。 3）、访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private） 4）、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。 重载的规则：1）、必须具有不同的参数列表； 2）、可以有不同的返回类型，只要参数列表不同就可以了； 3）、可以有不同的访问修饰符； 4）、可以抛出不同的异常； 总结：重写：只有内容和权限可以不一样，其他必须一样 重载：函数名字一样，其他都可以不一样 3. 抽象类和接口的区别 接口（Interface）和抽象类（Abstract class）是支持抽象类定义的两种机制。抽象是对类的抽象。 接口是公开的，不能有私有的方法或变量，接口中的所有方法都没有方法体，通过关键字interface实现。接口是对行为的抽象。抽象类是一种模版，接口是一种行为规范。 抽象类是可以有私有方法或私有变量的，通过把类或者类中的方法声明为abstract来表示一个类是抽象类，被声明为抽象的方法不能包含方法体。子类实现方法必须含有相同的或者更低的访问级别（public-&gt;protected-&gt;private)。抽象类的子类为父类中所有抽象方法的具体实现，否则也是抽象类。特点： 被abstract修饰，没有方法体的方法称为抽象方法； 抽象方法必须存在于抽象类中，不能存在于非抽象类； 抽象方法必须在其子类中实现，除非子类也是抽象类； 如果一个类中含有抽象方法，该类一定是抽象类，该类必须被abstract修饰； 如果一个类是抽象类，该类可以含有抽象方法和非抽象方法 如果一个类为抽象类，则该类不能被实例化，必须通过该类的非抽象子类进行实例化 相同点：（1）：都不能被实例化（2）：接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。 不同点： （1）：接口只有定义，不能有方法的实现，但java1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。（2）：实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。（3）：接口强调特定功能的实现，而抽象类强调所属关系。（4）：接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）（5）：接口被用于常用的功能，便于日后维护和添加删除，而抽象类更倾向于充当公共类的角色，不适用于日后重新对立面的代码修改。从设计层面来说，抽象是对类的抽象，是一种设计模版，而接口是对行为的抽象，是一种行为的规范。 总结：接口：行为约束，只约束行为类别，不约束行为内容，implements，没有构造方法，一个类实现多个接口 抽象：代码复用，extends，有构造方法，一个类继承一个抽象 同：都不能实例化，不能private 4. Final修饰类、方法、字段分别起到的作用？ 总结：类：不能被继承，成员方法被隐式地指定为final方法。方法：不能被重写 字段 常量：不能修改 变量/引用型：不能指向其他人 5. String VS StringBuffer VS StringBuilder 总结String：不可变，原理final，private final char value[]，操作少量 StringBuffer：可变，继承自AbstractStringBuilder，加了同步锁，唯一一个线程安全，多线程选择他 StringBuilder：可变，继承自AbstractStringBuilder，单线程， 6. 说一下Java中的==与eaquels的区别 ==对于基本类型和引用类型 == 的作用效果是不同的，如下所示： 基本类型：比较的是值是否相同； 引用类型：比较的是引用是否相同； 1、比较的是操作符两端的操作数是否是同一个对象。 2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。 3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如： int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。 1234567String x = &quot;string&quot;;String y = &quot;string&quot;;String z = new String(&quot;string&quot;);System.out.println(x==y); // trueSystem.out.println(x==z); // falseSystem.out.println(x.equals(y)); // trueSystem.out.println(x.equals(z)); // true equalsequals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。 首先来看默认情况下 equals 比较一个有相同值的对象，代码如下： 12345678910111213141516171819class Cat { public Cat(String name) { this.name = name; } private String name; public String getName() { return name; } public void setName(String name) { this.name = name; }}Cat c1 = new Cat(&quot;王磊&quot;);Cat c2 = new Cat(&quot;王磊&quot;);System.out.println(c1.equals(c2)); // false 输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下： 123public boolean equals(Object obj) { return (this == obj);} 原来 equals 本质上就是 ==。 同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下： value哪来的？？？ – String底层是数组，value可以拿到String的char数组。 123456789101112131415161718192021public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false;} 源码里String的代码： 123456789101112public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String = aString = (String)anObject; if(coder() == aString.coder()) { return isLatin1() ? StringLatin1.equals(value, aString.value) : StringUTF16.equals(value, aString.value); } } return false;} 原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。 equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。 String s=”abce”是一种非常特殊的形式,和new 有本质的区别。它是java中唯一不需要new 就可以产生对象的途径。 以String s=”abce”;形式赋值在java中叫直接量,它是在常量池中而不是象new一样放在压缩堆中。这种形式的字符串，在JVM内部发生字符串拘留，即当声明这样的一个字符串后，JVM会在常量池中先查找有有没有一个值为”abcd”的对象。 如果有，就会把它赋给当前引用.即原来那个引用和现在这个引用指点向了同一对象，如果没有，则在常量池中新创建一个“abcd””，下一次如果有Strings1=”abcd”；又会将s1指向“abcd”这个对象，即以这形式声明的字符串，只要值相等，任何多个引用都指向同一对象。 而String s=new String（”abcd”）；和其它任何对象一样.每调用一次就产生一个对象，只要它们调用。 也可以这么理解：String str=”hello”；先在内存中找是不是有“hello”这个对象，如果有，就让str指向那个“hello”。 如果内存里没有”hello”，就创建一个新的对象保存”hello”.String str=new String（“hello”）就是不管内存里是不是已经有”hello”这个对象，都新建一个对象保存”hello”。 总结==：对象地址，基本数据类型 == 比较的是值，引用数据类型==比较的是内存地址 equals：没有重写，同==。重写了，则是比较内容是否相同，而不是地址。 插播：如果两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？ 不对，两个对象的 hashCode()相同，equals()不一定 true。显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。 7. Java中的内部类 成员内部类 12345678910111213class Circle { double radius = 0; public Circle(double radius) { this.radius = radius; } class Draw { //内部类 public void drawSahpe() { System.out.println(&quot;drawshape&quot;); } }} 这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。 1234567891011121314class Circle { private double radius = 0; public static int count =1; public Circle(double radius) { this.radius = radius; } class Draw { //内部类 public void drawSahpe() { System.out.println(radius); //外部类的private成员 System.out.println(count); //外部类的静态成员 } }} 不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问： 12外部类.this.成员变量外部类.this.成员方法 虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问： 123456789101112131415161718class Circle { private double radius = 0; public Circle(double radius) { this.radius = radius; getDrawInstance().drawSahpe(); //必须先创建成员内部类的对象，再进行访问 } private Draw getDrawInstance() { return new Draw(); } class Draw { //内部类 public void drawSahpe() { System.out.println(radius); //外部类的private成员 } }} 成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下： 1234567891011121314151617181920212223242526272829public class Test { public static void main(String[] args) { //第一种方式： Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); //必须通过Outter对象来创建 //第二种方式： Outter.Inner inner1 = outter.getInnerInstance(); }} class Outter { private Inner inner = null; public Outter() { } public Inner getInnerInstance() { if(inner == null) inner = new Inner(); return inner; } class Inner { public Inner() { } }} 内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。 局部内部类 123456789101112131415161718class People{ public People() { }} class Man{ public Man(){ } public People getWoman(){ class Woman extends People{ //局部内部类 int age =0; } return new Woman(); }} 注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。 匿名内部类 匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听 1234567891011121314151617scan_bt.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { // TODO Auto-generated method stub } }); history_bt.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { // TODO Auto-generated method stub } }); 这里new onClickListener()就是匿名内部类 就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。 123456789101112131415161718192021private void setListener(){ scan_bt.setOnClickListener(new Listener1()); history_bt.setOnClickListener(new Listener2());} class Listener1 implements View.OnClickListener{ @Override public void onClick(View v) { // TODO Auto-generated method stub }} class Listener2 implements View.OnClickListener{ @Override public void onClick(View v) { // TODO Auto-generated method stub }} 这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。 匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。 静态内部类 静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。 1234567891011121314151617public class Test { public static void main(String[] args) { Outter.Inner inner = new Outter.Inner(); }} class Outter { public Outter() { } static class Inner { public Inner() { } }} 使用场景为什么在Java中需要内部类？总结一下主要有以下四点： 1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整， 2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。 3.方便编写事件驱动程序 4.方便编写线程代码 个人觉得第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善。 面试笔试题1.根据注释填写(1)，(2)，(3)处的代码1234567891011121314151617181920212223242526public class Test{ public static void main(String[] args){ // 初始化Bean1 (1) bean1.I++; // 初始化Bean2 (2) bean2.J++; //初始化Bean3 (3) bean3.k++; } class Bean1{ public int I = 0; } static class Bean2{ public int J = 0; }} class Bean{ class Bean3{ public int k = 0; }} 从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。 创建静态内部类对象的一般形式为： 外部类类名.内部类类名 xxx = new 外部类类名.内部类类名() 创建成员内部类对象的一般形式为： 外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名() 因此，（1），（2），（3）处的代码分别为： 12345678# 成员内部类Test test = new Test(); Test.Bean1 bean1 = test.new Bean1(); # 静态内部类Test.Bean2 b2 = new Test.Bean2();# 局部内部类Bean bean = new Bean(); Bean.Bean3 bean3 = bean.new Bean3(); xw 2.下面这段代码的输出结果是什么？123456789101112131415161718192021public class Test { public static void main(String[] args) { Outter outter = new Outter(); outter.new Inner().print(); }} class Outter{ private int a = 1; class Inner { private int a = 2; public void print() { int a = 3; System.out.println(&quot;局部变量：&quot; + a); System.out.println(&quot;内部类变量：&quot; + this.a); System.out.println(&quot;外部类变量：&quot; + Outter.this.a); } }} 123321 最后补充一点知识：关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点： 1）成员内部类的引用方式必须为 Outter.Inner. 2）构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》 1234567891011121314151617class WithInner { class Inner{ }}class InheritInner extends WithInner.Inner { // InheritInner() 是不能通过编译的，一定要加上形参 InheritInner(WithInner wi) { wi.super(); //必须有这句调用 } public static void main(String[] args) { WithInner wi = new WithInner(); InheritInner obj = new InheritInner(wi); }} 总结：成员内部类：在另一个类内部 局部内部类：方法或者一个作用域里，与成员内部类区别：访问权限只局限于方法内或作用域 匿名内部类：唯一一种没有构造器的类，用于实现接口 静态内部类：在另一个类里，与成员内部类区别：不过多了一个关键字static 8. Java有哪些修饰符？有哪些区别？Java中的修饰符有public、private、protected. 1、public：public表明该数据成员、成员函数对所有用户开放的，所有用户都可以直接进行调用2、private：private表示私有、私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用。3、protected：protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他外部class，protected就变成private。 总结： 访问级别 访问控制修饰符 同类 同包 子类(不同包) 不同包(其他类) 公共 public 允许 允许 允许 允许 受保护 protected 允许 允许 允许 不允许 默认 缺省修饰符 允许 允许 不允许 不允许 私有 private 允许 不允许 不允许 不允许 public: 全 private：只能类内 protected：不能不同包 追问：怎么获取private修饰的变量Private通过反射获取，可以设置setAccessable为true实现 下面是某博客的例子，只是一个演示用法。 123456789101112131415161718192021/** * @Description: 反射 * @author: Mr_VanGogh */public class Reflect { private String name; private int age; private Reflect(int age) { this.age = age; } private void speak(String name) { System.out.println(&quot;My name is&quot; + name); } public Reflect(String name) { this.name = name; }} 反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。 12345Class clz = Class.forName(&quot;com.chenshuyi.reflect.Apple&quot;);Method method = clz.getMethod(&quot;setPrice&quot;, int.class);Constructor constructor = clz.getConstructor();Object object = constructor.newInstance();method.invoke(object, 4); 首先，我们要了解三个反射包中的类： Constructor：代表类的单个构造方法，通过Constructor我们可执行一个类的某个构造方法（有参或者无参）来创建对象时。 Method：代表类中的单个方法，可以用于执行类的某个普通方法，有参或无参，并可以接收返回值。 Field：代表类中的单个属性，用于set或get属性 AccessibleObject：以上三个类的父类，提供了构造方法，普通方法，和属性的访问控制的能力。 使用Class类中的方法可以获得该类中的所有Constructor对象，Method对象，和Field对象。但是任然无法访问私有化的构造方法，普通方法，和私有属性，此时我们可以使用他们继承父类(AccessibleObject)中的setAccessible（）方法，来设置或取消访问检查，以达到访问私有对象的目的。 1234567891011121314151617181920public static void main(String[] args) throws Exception { Reflect reflect = new Reflect(&quot;a&quot;); Method[] methods = Reflect.class.getMethods(); Field[] fields = Reflect.class.getDeclaredFields(); for (int i = 0; i &lt; fields.length; i ++) { fields[i].setAccessible(true); System.out.println(fields[i].getName()); } for (int j = 0; j &lt; methods.length; j ++) { methods[j].setAccessible(true); System.out.println(methods[j].getName()); methods[j].invoke(reflect); System.out.println(methods[j].getName()); } } 9. Java的异常体系说一下？ Java中的异常主要分为Error和Exception Error指Java程序运行错误，如果程序在启动时出现Error，则启动失败；如果程序运行过程中出现Error，则系统将退出程序。出现Error是系统的内部错误或资源耗尽，Error不能在程序运行过程中被动态处理，一旦出现Error，系统能做的只有记录错误的原因和安全终止。 AWTError / ThreadDeath Exception指Java程序运行异常，在运行中的程序发生了程序员不期望发生的事情，可以被Java异常处理机制处理。Exception也是程序开发中异常处理的核心，可分为RuntimeException（运行时异常）和CheckedException（检查异常），如下图所示。 RuntimeException （Unchecked Exception）（运行时异常）：指在Java虚拟机正常运行期间抛出异常，RuntimeException可以被捕获并处理，如果出现情况，我们需要抛出异常或者捕获并处理异常。常见的有NullPointerExcception, ClassCastException, ArrayIndexOutOfBoundsException等 CheckedException（检查异常）：指在编译阶段Java编译器检查CheckedException异常，并强制程序捕获和处理此类异常，要求程序在可能出现异常的地方通过try catch语句块捕获异常并处理异常。常见的有由于I/O错误导致的IOException、SQLException、ClassNotFoundException等。该类异常通常由于打开错误的文件、SQL语法错误、类不存等引起。 总结：在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类: Error：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获不建议通过catch捕获 。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。 Exception：程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。 异常的处理方式？异常处理方式有抛出异常和使用try catch语句块捕获异常两种方式。（1）抛出异常：遇到异常时不进行具体的处理，直接将异常抛给调用者，让调用者自己根据情况处理。抛出异常的三种方式：throws、throw和系统自动抛出异常。其中throws作用在方法上，用于定义方法可能抛出的异常；throw作用在方法内，表示明确抛出一个异常。（2）使用try catch捕获并处理异常：使用try catch捕获异常能够针对性的处理每种可能出现的异常，并在捕获到异常后根据不同的情况做不同的处理。其使用过程比较简单，用try catch语句块可能出现异常的代码包起来即可。 10. Java中的深拷贝和浅拷贝说一下？深拷贝和浅拷贝都是对象拷贝 浅拷贝：按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。（浅拷贝仅仅复制所考虑的对象，而不是复制它所引用的对象）。 深拷贝：在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。（深拷贝把要复制的对象所引用的对象都复制了一遍。） 特点：浅拷贝特点（1）：对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个。（2）对于引用类型，比如数组或者类对象，因为引用类型是引用传递，所以浅拷贝只是把内存地址赋值给了成员变量，它们指向了同一内存空间。改变其中一个，会对另外一个也产生影响。 深拷贝特点（1）对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个（和浅拷贝一样）。（2）对于引用类型，比如数组或者类对象，深拷贝会创建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。（3）对于有多层对象的，每个对象都需要实现Cloneable并重写clone（）方法，进而实现了对象的串行层层拷贝。（4）深拷贝相比于浅拷贝速度较慢并且花销较大。 参考链接[1]: https://www.cnblogs.com/dolphin0520/p/3811445.html “Java内部类详解”[2]: https://www.nowcoder.com/discuss/916143 “Java超高频面试题汇总”[3]: https://juejin.cn/post/6844903790089338887 “你真的懂==和equals的区别吗？”[4]: “《java编程思想》” [5]: https://cloud.tencent.com/developer/article/1886994 “面试官：private修饰的方法可以通过反射访问，那么private的意义是什么？”[6]: https://javaguide.cn/java/basis/java-basic-questions-01.html# “JavaGuide” [7]: https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html “大白话说Java反射：入门、使用、原理”[8]: https://blog.csdn.net/u012723673/article/details/80613557 “Java中各类修饰符的使用总结（看完这篇就够了）”","link":"/2022/10/08/String/"},{"title":"Vue Feature","text":"本文主要讲一下Vue的双向绑定，单向数据流以及响应式原理。不要搞混了三者的概念～ 本文暂时也是对其他博客的一个整理以及自己一点总结～ Vue 单向绑定 + V-model = 双向绑定 V-model = View 层 + 监听事件 单向数据流 = 父组建流向子组件 响应式原理（单向绑定原理） = 数据劫持只是解决了属性变更后，触发通知的问题。通知谁是由Dep来做，数据劫持触发Dep，Dep进一步触发Watcher，Watcher收到属性变化通知后，执行render，生成新的 virutal-dom 结构，再交由 Vue 做diff，更新视图。 单向绑定 VS 双向绑定 单向绑定 VS 双向绑定 绑定：视图层与逻辑层之间的互相通知 （View 与 Modal 层之间的映射关系） 单向数绑定的优缺点： 优点：所有状态变化都可以被记录、跟踪，状态变化通过手动调用触发，源头易追溯。 缺点：会有很多类似的样板代码，代码量会相应的上升。 双向数据绑定的优缺点： 优点：在操作表单时使用v-model方便简单，可以省略繁琐或重复的onChange事件去处理每个表单数据的变化（减少代码量）。 缺点：属于暗箱操作，无法很好的追踪双向绑定的数据的变化。 单向绑定 双向绑定 Vue 插值形式{{data}}，v-bind也是单向绑定 表单的v-model，用户对View层的更改会直接同步到Model层 React 当View层发生更改时，用户通过发出Actions进行处理，Actions中通过setState对State进行更新，State更新后触发View更新。可以看出，View层不能直接修改State，必须要通过Actions来进行操作，这样更加清晰可在 React 中，View 层是不能直接修改 State，必须通过相应的 Actions 来进行操作。 Angular 使用[x]属性绑定、(x)事件绑定或插值形式{{data}}。 使用[(x)]语法，用户对View的更改会直接同步到Model。 Angular JS 使用ng-bind指令或插值形式{{data}}。 使用ng-model指令，用户对View的更改会直接同步到Model。 Vue &amp; React 实际上v-model只是v-bind:value 和 v-on:input的语法糖，我们也可以采取类似react的单向绑定。两者各有利弊，单向绑定清晰可控，但是模板代码过多，双向绑定可以简化开发，但是也会导致数据变化不透明，优缺点共存，大家可以根据情况使用。1 Vue &amp; Angular 除了语法上有所不同，Angular 双向数据绑定与 Vue 类似，也是语法糖，[(x)] 语法结合了属性绑定[x] 和事件绑定 (x)。 Vue &amp; Angular JS AngularJS 的双向数据绑定实现原理与 Angular 完全不同，其实现原理可以参考这篇文章。**(留坑)** 单向数据流 VS 双向数据流 单向数据流 VS 双向数据流 所谓数据流，就是指的是组件之间的数据流动。（父子组件） React、Vue 以及 Angular 都只是单向数据流 虽然 Vue 和 Angular 有双向数据绑定，但 Vue 和 Angualr 父子组件之间数据传递，仍然遵循单向数据流，即父组件可以向子组件传递props，但是子组件不能修改父组件传递来的props，子组件只能通过事件通知父组件进行数据更改。如下图所示： 优点：由于组件数据传递只有唯一的入口和出口，使得程序更直观、更容易理解，有利于程序的可维护性。 AngularJS 支持双向数据流 所谓双向数据流，就是指在子组件中可以直接更新父组件的数据。 缺点：由于组件数据变化的来源入口变得可能不止一个，如果缺乏相应的“管理”手段，容易将数据流转方向弄得紊乱。同时也会增加了出错时 debug 的难度。 数据流与数据绑定 严格来说，数据流和数据绑定是两个概念，并不是同一个东西。单向数据流也可以支持双向数据绑定，双向数据流也可以支持单向数据绑定。 简单总结一下前端三大框架的数据流与数据绑定的区别：5 数据劫持 数据劫持 双向绑定的原理就是数据劫持与发布订阅模式的结合。 Vue2: 针对 Object 类型，采用 Object.defineProperty() 方法劫持属性的读取和设置方法； 针对 Array 类型，采用原型相关的知识劫持常用的函数，从而知晓当前数组发生变化。 详解： 对象 Object.defineProperty() 方法设置属性的 setter 与 getter 方法，从而达到劫持 student 对象中的 name 属性的读取和设置操作的目的。该方法每次只能设置一个属性，那么就需要遍历对象来完成其属性的配置： 1Object.keys(student).forEach(key =&gt; defineReactive(student, key)) 另外还必须是一个具体的属性，这也非常的致命。 假如后续需要扩展该对象，那么就必须手动为新属性设置 setter 和 getter 方法，**这就是为什么不在 data 中声明的属性无法自动拥有双向绑定效果的原因 **。（这时需要调用 Vue.set() 手动设置） 数组 数组是一种特殊的对象，其下标实际上就是对象的属性，所以理论上是可以采用 Object.defineProperty() 方法处理数组对象。数组对象的 length 属性的描述符天生独特：这就意味着无法通过 Object.defineProperty() 方法劫持 length 属性的读取和设置方法。相比较对象的属性，数组下标变化地相对频繁，并且改变数组长度的方法也比较灵活，一旦数组的长度发生变化，那么在无法自动感知的情况下，开发者只能手动更新新增的数组下标，这可是一个很繁琐的工作。数组主要的操作场景还是遍历，而对于每一个元素都挂载一个 get 和 set 方法，恐怕也是不小的性能负担。最终 Vue 选择劫持一些常用的数组操作方法，从而知晓数组的变化情况： 123456789const methods = [ 'push', 'pop', 'shift', 'unshift', 'sort', 'reverse', 'splice'] 数组方法的劫持涉及到原型相关的知识，首先数组实例大部分方法都是来源于 Array.prototype 对象。 但是这里不能直接篡改 Array.prototype 对象，这样会影响所有的数组实例，为了避免这种情况，需要采用原型继承得到一个新的原型对象： 12const arrayProto = Array.prototypeconst injackingPrototype = Object.create(arrayProto) 拿到新的原型对象之后，再重写这些常用的操作方法： 12345678910111213141516171819202122methods.forEach(method =&gt; { const originArrayMethod = arrayProto[method] injackingPrototype[method] = function (...args) { const result = originArrayMethod.apply(this, args) let inserted switch (method) { case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break } if (inserted) { // 对于新增的元素，继续劫持 // ob.observeArray(inserted) } // 通知变化 return result }}) 最后，更新劫持数组实例的原型，在 ES6 之前，可以通过浏览器私有属性 proto 指定原型，之后，便可以采用如下方法： 1Object.setPrototypeOf(arr, injackingPrototype) 顺便提一下，采用 Vue.set() 方法设置数组元素时，Vue 内部实际上是调用劫持后的 splice() 方法来触发更新。 Object.defineProperty()的缺点1).不能监听数组的变化数组的以下几个方法不会触发 set： push、pop、shift、unshift、splice、sort、reverse Vue 把这些方法定义为变异方法 (mutation method)，指的是会修改原来数组的方法。与之对应则是非变异方法 (non-mutating method)，例如 filter, concat, slice 等，它们都不会修改原始数组，而会返回一个新的数组。 2).必须遍历对象的每个属性使用 Object.defineProperty() 多数要配合 Object.keys() 和遍历，于是多了一层嵌套。如： 12345Object.keys(obj).forEach(key =&gt; { Object.defineProperty(obj, key, { // ... })}) 给出完整版的数据劫持代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const arrayProto = Array.prototype;// 得到原型上的方法const proto = Object.create(arrayProto) // 复制一份原型上的方法 ;['push', 'shift', 'pop', 'splice'].forEach(method =&gt; { // console.log(method) // 重写'push','shift','pop','splice',当然也可以多加几个方法，想加什么就加什么 proto[method] = function (...args) { // console.log(this) // [ 1, 2, 3, { age: [Getter/Setter] } ] updateView(); arrayProto[method].call(this, ...args) } })function updateView() { console.log(&quot;更新视图成功了...&quot;)}function observer(obj) { if (typeof obj !== &quot;object&quot; || obj == null) { return obj } if (Array.isArray(obj)) { // 如果是一个数组要重写数组上原型上的方法 Object.setPrototypeOf(obj, proto) for (let i = 0; i &lt; obj.length; i++) { let item = obj[i]; observer(item) } } else { for (let key in obj) { definedReactive(obj, key, obj[key]) } }}function definedReactive(obj, key, value) { observer(value) Object.defineProperty(obj, key, { get() { console.log(&quot;获取数据成功了...&quot;) return value; }, set(newValue) { if (value !== newValue) { observer(newValue) value = newValue; updateView(); } } })}let data = { name: [1, 2, 3, { age: 888 }] }observer(data)// 数据改变了// data.name[3].age = 666; // push shift unshift pop 也能改变数组中的数组data.name.push({ address: &quot;xxx&quot; }) // 目的是：更新视图// 思路：重写Push方法 这些方法在Array的原型上// 不要把Array原型上的方法直接重写了// 先把原型上的方法copy一份，去重写（加上视图更新的操作）// 再去调用最原始的push方法 Vue3: Proxy数据代理在数据劫持这个问题上，Proxy 可以被认为是 Object.defineProperty() 的升级版。外界对某个对象的访问，都必须经过这层拦截。因此它是针对 整个对象，而不是 对象的某个属性。 proxy即代理的意思。个人理解，建立一个proxy代理对象（Proxy的实例），接受你要监听的对象和监听它的handle两个参数。当你要监听的对象发生任何改变，都会被proxy代理拦截来满足需求。 12345678910111213141516var arr = [1,2,3]var handle = { //target目标对象 key属性名 receiver实际接受的对象 get(target,key,receiver) { console.log(`get ${key}`) // Reflect相当于映射到目标对象上 return Reflect.get(target,key,receiver) }, set(target,key,value,receiver) { console.log(`set ${key}`) return Reflect.set(target,key,value,receiver) }}//arr要拦截的对象，handle定义拦截行为var proxy = new Proxy(arr,handle)proxy.push(4) //可以翻到控制台测试一下会打印出什么 优点： 1.使用proxy可以解决defineProperty不能监听数组的问题，避免重写数组方法； 2.不需要再遍历key。 3.Proxy handle的拦截处理器除了get、set外还支持多种拦截方式。 4.嵌套查询。实际上proxy get()也是不支持嵌套查询的。解决方法： 123456789let handler = { get (target, key, receiver) { // 递归创建并返回 if (typeof target[key] === 'object' &amp;&amp; target[key] !== null) { return new Proxy(target[key], handler) } return Reflect.get(target, key, receiver) }} 依赖管理方案Object.defineProperty 只是解决了状态变更后，如何触发通知的问题，那要通知谁呢？谁会关心那些属性发生了变化呢？在 Vue 中，使用 Dep 解耦了依赖者与被依赖者之间关系的确定过程。简单来说： 第一步，通过 Observer 提供的接口，遍历状态对象，给对象的每个属性、子属性都绑定了一个专用的 Dep 对象。这里的状态对象主要指组件当中的data属性。 第二步，创建三中类型的watcher： 1.调用 initComputed 将 computed 属性转化为 watcher 实例 2.调用 initWatch 方法，将 watch 配置转化为 watcher 实例 3.调用 mountComponent 方法，为 render 函数绑定 watcher 实例 第三步，状态变更后，触发 dep.notify() 函数，该函数再进一步触发 Watcher 对象 update 函数，执行watcher的重新计算。 我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下3个步骤，实现数据的双向绑定：1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。2.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。 总结： 数据劫持只是解决了属性变更后，触发通知的问题。通知谁是由Dep来做，数据劫持触发Dep，Dep进一步触发Watcher，Watcher收到属性变化通知后，执行render，生成新的 virutal-dom 结构，再交由 Vue 做diff，更新视图。 v-model是语法糖 为什么v-model是语法糖 前面说到，React之所以是单向绑定，是因为视图层的更改无法带动Model层的更改，而v-model本质就是对视图层添加监听事件，然后监听到后去修改Model层。 V-model底层实现，最后有2句关键代码： 12addProp(el, 'value', `(${value})`)addHandler(el, event, code, null, true) 这实际上就是 input 实现 v-model 的精髓，通过修改 AST 元素，给 el 添加一个 prop，相当于我们在 input 上动态绑定了 value，又给 el 添加了事件处理，相当于在 input 上绑定了 input 事件，其实转换成模板如下： 123&lt;input v-bind:value=&quot;message&quot; v-on:input=&quot;message=$event.target.value&quot;&gt; 其实就是动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message 设置为目标值，这样实际上就完成了数据双向绑定了，所以说 v-model 实际上就是语法糖。 其他补充 其他补充 v-bind指令用于设置HTML属性：v-bind:href 缩写为 :href 1&lt;a :href=&quot;{{url}}&quot;&gt;aa&lt;/a&gt; v-on 指令用于绑定HTML事件 ：v-on:click 缩写为 @click 1&lt;a @click=&quot;get()&quot;&gt;aa&lt;/a&gt; 引用与参考 [1]: https://juejin.cn/post/7085139499767840782 “Vue的双向绑定和单向数据流冲突吗?”[2]: https://ustbhuangyi.github.io/vue-analysis/v2/extend/v-model.html#%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0 “Vue.js 技术揭秘”[3]: https://juejin.cn/post/6844903913217327111 “Vue 数据劫持”[4]: https://juejin.cn/post/7135290464319733768 “聊聊 Vue3 是如何工作的” [5]: https://juejin.cn/post/6854573208646090765 “前端三大框架：数据绑定与数据流”[6]: https://cloud.tencent.com/developer/article/1020807 “前端三大框架vue，angular，react大杂烩”[7]: https://juejin.cn/post/6844903828593049613#heading-5 “深入浅出 Vue 系列 – 数据劫持实现原理”[8]: https://juejin.cn/post/6844903463285948423 “Vue 核心之数据劫持”","link":"/2022/10/12/Vue-Relation/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/10/10/hello-world/"},{"title":"Deploy Hexo","text":"本文主要介绍 Hexo + icarus 基础环境搭建，包含 Hexo 框架的下载安装，icarus 及其组件的下载安装，完成以下操作步骤将初步完成 Hexo 博客 + icarus 主题的配置。后续将对 Hexo 博客进行功能扩展。 即： 已安装 Git 1$ git --version # 查看 git 版本 已安装 Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本) 12$ node -v # 查看 node.js 版本$ npm -v # 查看 npm 包管理器版本 如未正确安装，请参照 Hexo官方文档 进行安装，以下操作均基于Mac平台。 我的电脑需要如下操作，至今没去查为何每次使用node都需要source一下。 12$ source ~/.bash_profile # 编译一下bash文件 ？？？ $ nvm use 16 # 使用nvm切换node版本 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo 框架。 1$ npm install -g hexo-cli # 全局安装 Hexo 框架 查看 Hexo 版本，检查是否安装成功。 1$ hexo -v Hexo 初始化在任意位置新建一个文件夹，取名 blog，在blog/ 目录下 打开 CMD 窗口，运行以下命令，进行 Hexo 框架初始化。 1$ hexo init # Hexo 初始化 我安装时候，vpn有毒，即使复制终端代理命令也不行，老是断一下连一下 出现问题： 1$ npm not working - &quot;read ECONNRESET&quot; 后面用如下命令解决： use so that npm requests for http url instead of https. and then try the same npm install command 1$ npm config set registry http://registry.npmjs.org/ 我原本的源 12$ npm config get registryhttp://registry.npmjs.org/ 最后换源了 1$ npm config set registry http://registry.npmjs.org/ 下载icarus主题运行下列命令以下载 icarus 主题，此处可能下载较慢，请耐心等待。 1$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 切换icarus主题打开 _config.yml 文件，将 thems 项的值更改为 icarus 启动Hexo1$ hexo g # 生成静态页面 这里会提示错误 ERROR 我们根据上图中的错误提示安装 icarus 主题所需组件。 1$ npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 hexo-component-inferno@^0.10.1 inferno@^7.3.3 inferno-create-element@^7.3.3 再依次运行命令行，重新生成静态页面，并启动 Hexo 服务。 12$ hexo g # 生成静态页面$ hexo s # 启动服务 打开浏览器输入下列网址预览效果。 1http://localhost:4000 添加 自定义页面 新建一个 分类 页面 1$ hexo new page categories 新建一个 标签 页面 1$ hexo new page tags 新建一个 关于我 页面 1$ hexo new page &quot;about&quot; 写作123$ hexo new [layout] &lt;title&gt; # layout布局默认为post，有三种默认布局即post、page 和 draft，在创建者三种不同类型的文件时，它们将会被保存到不同的路径；# 而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 新建一篇文章示例： 1$ hexo new 第一篇文章的名字 在此之前通常建议开启 _config.yml 中的资源文件夹，以便创建文章的同时，自动为你创建同名资源文件夹，这通常用于存放你在本篇文章所用到的图片等资源。存在此文件夹中的图片，Hexo 生成静态页面时，将会将二者存放在同一文件夹下。 1post_asset_folder: true # 开启文章资源文件夹 部署在正式开始部署上传到 GitHub 上前，通常建议配置 SSH 秘钥，这样不用每次上传部署都要进行登录验证，有关如何配置 SSH 秘钥，请参阅 ————–此处省略10000字————————- ————–挖坑1：GitHub 添加 SSH————— 详情请参阅：Git配置SSH秘钥 ————–挖坑2：GitHub 静态页面————— 首先在_config.yml中修改添加以下内容，指定部署上传的 GitHub 库。 123456789deploy: type: git repo: git@github.com:local-host-8080/local-host-8080.github.io.git branch: master type: git repo: &lt;repository url&gt; branch: [branch] message: [message]Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}) 安装 1git 组件 1$ npm install hexo-deployer-git --save 此外，如果您的 Github Pages 需要使用 CNAME 文件自定义域名，请将 CNAME 文件置于 source/ 目录下，只有这样 hexo deploy 才能将 CNAME 文件一并推送至部署分支。 上传至GitHub 123$ hexo clean$ hexo g$ hexo d Hexo 一篇文章多个 categories子分类下面的分类配置会将该文章放到 Sports/Baseball 这个分类下。 123categories: - Sports - Baseball 同样的作用还可以这样写： 1categories: [Sports,Baseball] 上面两种写法最终的效果都是一样的，都是将文章放在了一个子分类目录下。 多个分类如果我们的要求是将文章同时分到两个或者多个不同的类目下呢？官方给出的方法是： 123categories: - [Sports] - [Baseball] 只需要用中括号将独立的分类括起来即可，这样上面的文章就会被分类在 Sports 和 Baseball 这两个不同的目录中了。 扩展一下，如果我们要将其分类到 Sports/Baseball 和 Play 两个不同的目录下（一个是子目录，一个是一级目录），我们该怎么写呢？如下： 123categories: - [Sports,Baseball] - [Play] 图片放置1{% asset_img 1.jpg This is an image %} 摘要1&lt;!--more--&gt; 评论Gitalk安装指南在线预览 登录GitHub并点此注册一个新的OAuth应用。填写”应用名称“(Application name)，”应用主页“(Homepage URL)，”应用描述“(Application description)。然后，在”认证回调地址“(Authorization callback URL)填写你的博客的根URL地址。点击“注册应用”(Register application)按钮来跳转到应用详情界面。 复制”Client ID“与”Client Secret“的值并填入主题配置的相应配置项中。 例如，对于下面的”Client ID“和”Client Secret“： 1234Client IDxxxxxxxxxxxxxxxxxxxxClient Secretxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 对应如下的Gitalk的配置： 123456789101112131415comment: type: gitalk client_id: xxxxxxxxxxxxxxxxxxxx client_secret: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx repo: Some-of-Your-GitHub-Repo # 你的github分支名字就好，不用全部 owner: you_github_name admin: - you_github_name per_page: 20 # 可选填 distraction_free_mode: false # 可选填 pager_direction: last # 可选填 create_issue_manually: false # 可选填 proxy: # 可选填 flip_move_options: # 可选填 enable_hotkey: true # 可选填 Markdown 链接语法链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。 超链接Markdown语法代码：[超链接显示名](超链接地址 &quot;超链接title&quot;) 对应的HTML代码：&lt;a href=&quot;超链接地址&quot; title=&quot;超链接title&quot; style=&quot;text-decoration:none;&quot;&gt;超链接显示名&lt;/a&gt; 1这是一个链接 [Markdown语法](https://markdown.com.cn)。 渲染效果如下： 这是一个链接 Markdown语法。 #给链接增加 Title链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。 1这是一个链接 [Markdown语法](https://markdown.com.cn &quot;最好的markdown教程&quot;)。 渲染效果如下： 这是一个链接 Markdown语法。 侧边栏设置sidebar中某个侧边栏的sticky为true来让它的位置固定而不跟随页面滚动。 1234567_config.icarus.ymlsidebar: left: sticky: false right: sticky: true 布局配置文件布局配置文件遵循着与主题配置文件相同的格式和定义。 _config.post.yml中的配置对所有文章生效，而_config.page.yml中的配置对所有自定义页面生效。 这两个文件将覆盖主题配置文件中的配置。 例如，你可以在_config.post.yml中把所有文章变为两栏布局： 123456789101112_config.post.ymlwidgets: - type: recent_posts position: left - type: categories position: left - type: tags position: left 同时所有其他页面仍保持三栏布局： 123456789101112_config.icarus.ymlwidgets: - type: recent_posts position: left - type: categories position: right - type: tags position: right 业内跳转.html标签实现 定义一个锚(id)： &lt;span id=&quot;jump&quot;&gt;跳转到的地方&lt;/span&gt; 使用markdown语法：[点击跳转](#jump) 自定义Hexo标签插件Mdx123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419&lt;article class=&quot;message message-immersive is-primary&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-globe-americas mr-2&quot;&gt;&lt;/i&gt;本文同时提供以下语言的翻译：&lt;a href=&quot;{% post_path en/Custom-Hexo-Tag-Helpers %}&quot;&gt;English&lt;/a&gt;。&lt;/div&gt;&lt;/article&gt;&lt;article class=&quot;message message-immersive is-primary&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-info-circle mr-2&quot;&gt;&lt;/i&gt;下面的标签插件由&lt;a href=&quot;https://github.com/ppoffice/hexo-component-inferno&quot;&gt;ppoffice/hexo-component-inferno&lt;/a&gt;提供，完整的支持插件列表和配置详情以其为准。&lt;/div&gt;&lt;/article&gt;&lt;style&gt;.example-tab-container { margin: 0 0 20px 0; padding: 10px 20px 20px 20px; border-radius: 6px; box-shadow: 0 0.5em 0.75em -0.125em rgba(10,10,10,0.1), 0 0px 0 1px rgba(10,10,10,0.02);}&lt;/style&gt;## 消息五颜六色的消息块可以用来强调你文章中的部分文本。它的语法定义如下：```{% message color:&lt;颜色&gt; size:&lt;大小&gt; icon:&lt;图标&gt; title:&lt;标题&gt; %} &lt;内容&gt;{% endmessage %}```### color此选项定义消息块的颜色。其为可选项。它可用的配置值与示例如下：{% message &quot;title:default&quot; %} 一个没有设置颜色的代码块。{% endmessage %}{% message color:dark &quot;title:dark&quot; %} 一个深色(`dark`)的代码块。{% endmessage %}{% message color:primary &quot;title:primary&quot; %} 一个主题色(`primary`)的代码块。{% endmessage %}{% message color:info &quot;title:info&quot; %} 一个提示色(`info`)的代码块。{% endmessage %}{% message color:success &quot;title:success&quot; %} 一个成功色(`success`)的代码块。{% endmessage %}{% message color:warning &quot;title:warning&quot; %} 一个警示色(`warning`)的代码块。{% endmessage %}{% message color:danger &quot;title:danger&quot; %} 一个危险色(`danger`)的代码块。{% endmessage %}### size此选项定义消息块的大小。其为可选项。它可用的配置值与示例如下：{% message size:small &quot;title:small&quot; %} 一个小(`small`)的代码块。{% endmessage %}{% message &quot;title:default&quot; %} 一个没有设置大小的代码块。{% endmessage %}{% message size:medium &quot;title:medium&quot; %} 一个中等大小(`small`)的代码块。{% endmessage %}{% message size:large &quot;title:large&quot; %} 一个大(`small`)的代码块。{% endmessage %}### icon此选项定义显示在消息块头部的图标。其为可选项。它的值应为FontAwesome的图标class name。如果图标的class name含有空格，则配置名与配置值需要用引号包裹住。{% message &quot;icon:fa-brands fa-github&quot; &quot;title:一个有着GitHub图标的消息块&quot; %} 一个有着GitHub图标(`&quot;icon:fa-brands fa-github&quot;`)的消息块。{% endmessage %}{% message color:success &quot;icon:fa-brands fa-node-js&quot; &quot;title:一个有着Node.js图标的消息块&quot; %} 一个有着Node.js图标(`&quot;icon:fa-brands fa-node-js&quot;`)的消息块。{% endmessage %}{% message color:danger &quot;icon:fa-brands fa-npm&quot; &quot;title:一个有着NPM图标的消息块&quot; %} 一个有着NPM图标(`&quot;icon:fa-brands fa-npm&quot;`)的消息块。{% endmessage %}### title此选项定义消息块的标题。其为可选项。如果标题含有空格，则配置名与配置值需要用引号包裹住。{% message &quot;title:有标题的消息块&quot; %} 有标题的消息块(`&quot;title:有标题的消息块&quot;`)。{% endmessage %}{% message %} 没有标题的消息块。{% endmessage %}{% message color:dark %} 没有标题的消息块。{% endmessage %}{% message color:primary %} 没有标题的消息块。{% endmessage %}{% message color:info %} 没有标题的消息块。{% endmessage %}{% message color:success %} 没有标题的消息块。{% endmessage %}{% message color:warning %} 没有标题的消息块。{% endmessage %}{% message color:danger %} 没有标题的消息块。{% endmessage %}## 标签页标签页是一个功能强大的用于展示平行内容的标签插件。同一时间内，只有活动的标签页内容才能展示给用户。它的语法定义如下：```{% tabs size:&lt;大小&gt; align:&lt;对齐&gt; style:&lt;样式&gt; %}&lt;!-- tab id:&lt;标签ID&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; active --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;&lt;!-- tab id:&lt;标签ID&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;...{% endtabs %}```### 标签容器一个标签容器有着以下选项：#### size此选项定义标签页的大小。其为可选项。它可用的配置值与示例如下：&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs size:small %}&lt;!-- tab id:tab_size_small_1 &quot;title:第一页&quot; active --&gt;这是一个小(`small`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_size_small_2 &quot;title:第二页&quot; --&gt;这是一个小(`small`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs %}&lt;!-- tab id:tab_size_default_1 &quot;title:第一页&quot; active --&gt;这是一个没有指定大小的标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_size_default_2 &quot;title:第二页&quot; --&gt;这是一个没有指定大小的标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs size:medium %}&lt;!-- tab id:tab_size_medium_1 &quot;title:第一页&quot; active --&gt;这是一个中等大小(`medium`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_size_medium_2 &quot;title:第二页&quot; --&gt;这是一个中等大小(`medium`)标签页容器的第一页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs size:large %}&lt;!-- tab id:tab_size_large_1 &quot;title:第一页&quot; active --&gt;这是一个大(`large`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_size_large_2 &quot;title:第二页&quot; --&gt;这是一个大(`large`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;#### align此选项定义标签页按钮的对齐方式。其为可选项。它可用的配置值与示例如下：&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs %}&lt;!-- tab id:tab_align_default_1 &quot;title:第一页&quot; active --&gt;这是一个没有指定对齐方式的标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_align_default_2 &quot;title:第二页&quot; --&gt;这是一个没有指定对齐方式的标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs align:centered %}&lt;!-- tab id:tab_align_centered_1 &quot;title:第一页&quot; active --&gt;这是一个居中对齐的(`centered`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_align_centered_2 &quot;title:第二页&quot; --&gt;这是一个居中对齐的(`centered`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs align:right %}&lt;!-- tab id:tab_align_right_1 &quot;title:第一页&quot; active --&gt;这是一个右对齐的(`centered`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_align_right_2 &quot;title:第二页&quot; --&gt;这是一个右对齐的(`centered`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs align:fullwidth %}&lt;!-- tab id:tab_align_fullwidth_1 &quot;title:第一页&quot; active --&gt;这是一个全宽的(`fullwidth`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_align_fullwidth_2 &quot;title:第二页&quot; --&gt;这是一个全宽的(`fullwidth`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;#### style此选项定义标签页按钮的样式。其为可选项。此外你可以将样式与全宽(`fullwidth`)对齐方式结合。它可用的配置值与示例如下：&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs style:boxed %}&lt;!-- tab id:tab_style_boxed_1 &quot;title:第一页&quot; active --&gt;这是一个盒状(`boxed`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_style_boxed_2 &quot;title:第二页&quot; --&gt;这是一个盒状(`boxed`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs style:toggle %}&lt;!-- tab id:tab_style_toggle_1 &quot;title:第一页&quot; active --&gt;这是一个拨动开关状(`toggle`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_style_toggle_2 &quot;title:第二页&quot; --&gt;这是一个拨动开关状(`toggle`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs style:toggle-rounded %}&lt;!-- tab id:tab_style_toggle_rounded_1 &quot;title:第一页&quot; active --&gt;这是一个圆角拨动开关状(`toggle-rounded`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_style_toggle_rounded_2 &quot;title:第二页&quot; --&gt;这是一个圆角拨动开关状(`toggle-rounded`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs align:fullwidth style:boxed %}&lt;!-- tab id:tab_style_boxed_fullwidth_1 &quot;title:第一页&quot; active --&gt;这是一个全宽(`fullwidth`)盒状(`boxed`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_style_boxed_fullwidth_2 &quot;title:第二页&quot; --&gt;这是一个全宽(`fullwidth`)盒状(`boxed`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs align:fullwidth style:toggle %}&lt;!-- tab id:tab_style_toggle_fullwidth_1 &quot;title:第一页&quot; active --&gt;这是一个全宽(`fullwidth`)拨动开关状(`toggle`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_style_toggle_fullwidth_2 &quot;title:第二页&quot; --&gt;这是一个全宽(`fullwidth`)拨动开关状(`toggle`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs align:fullwidth style:toggle-rounded %}&lt;!-- tab id:tab_style_toggle_rounded_fullwidth_1 &quot;title:第一页&quot; active --&gt;这是一个全宽(`fullwidth`)圆角拨动开关状(`toggle-rounded`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_style_toggle_rounded_fullwidth_2 &quot;title:第二页&quot; --&gt;这是一个全宽(`fullwidth`)圆角拨动开关状(`toggle-rounded`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;### Tab一个标签页有如下选项：#### id此选项为标签页元素的独特标识符(ID)。此项为必填项。一个标签页ID应当在整个页面内为独一无二的，这样Icarus才能定位、显示、和隐藏正确的标签页内容。#### active此选项标记当前的标签页是否默认显示。此项为选填项。同一时刻一个标签组中只有一个标签页可以标记为活动(`active`)标签页。#### icon此选项定义标签按钮中显示的图标。此项为选填项。它的值应为FontAwesome图标的class name。如果图标的class name含有空格，则配置名与配置值需要用引号包裹住。&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs %}&lt;!-- tab id:tab_icon_1 &quot;icon:fa-brands fa-github&quot; &quot;title:GitHub&quot; active --&gt;这个标签页的图标(`icon`)为`&quot;icon:fa-brands fa-github&quot;`。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_icon_2 &quot;icon:fa-brands fa-node-js&quot; &quot;title:Node.js&quot; --&gt;这个标签页的图标(`icon`)为`&quot;icon:fa-brands fa-node-js&quot;`。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs align:fullwidth style:toggle-rounded %}&lt;!-- tab id:tab_boxed_icon_1 &quot;icon:fa-brands fa-github&quot; &quot;title:GitHub&quot; active --&gt;这个标签页的图标(`icon`)为`&quot;icon:fa-brands fa-github&quot;`。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_boxed_icon_2 &quot;icon:fa-brands fa-node-js&quot; &quot;title:Node.js&quot; --&gt;这个标签页的图标(`icon`)为`&quot;icon:fa-brands fa-node-js&quot;`。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;#### title此选项定义标签按钮的标题。其为可选项。如果标题含有空格，则配置名与配置值需要用引号包裹住。&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs style:toggle %}&lt;!-- tab id:tab_title_boxed_1 &quot;title:有标题的标签页&quot; active --&gt;这个标签页的标题(`title`)为(`&quot;title:有标题的标签页&quot;`)。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_title_boxed_2 &quot;title:另一个有标题的标签页&quot; --&gt;这个标签页的标题(`title`)为(`&quot;title:另一个有标题的标签页&quot;`)。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt; 增加文献引用增加引用的文献列表示例如下： 参考 [1] 百度学术 [2] Wikipedia1增加锚点 参考 - [1] [百度学术](http://xueshu.baidu.com/) - [2] [Wikipedia](https://en.wikipedia.org/wiki/Main_Page) ———————————————— 版权声明：本文为CSDN博主「MurphyZhao」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/u012349679/article/details/103815049 增加引用使用 标注引用，如下所示： Markdown 增加文献引用这边文章是介绍如何在 Markdown 中增加文献引用。1 参考 [1] 百度学术 [2] Wikipedia 其他配置你可以参考Icarus用户指南来了解更多第三方的插件、挂件、以及CDN提供商的配置。 更多请参考[1]: https://ppoffice.github.io/hexo-theme-icarus/Configuration/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/ “Icarus用户指南” 暂时就这样…","link":"/2022/10/08/%E9%83%A8%E7%BD%B2Hexo/"},{"title":"Responsive Image Design","text":"Responsive images that are in the wrong format, images that are not compressed properly, and images that are too big will all decrease the page speed and impact your SEO. According to Google, anything above 2 seconds of download time will put off your users and discourage the crawlers from indexing your website. 本文目的：快速生成适用于所有浏览器的响应式图像并且大大降低下载速度。 方法： WebP格式、picture标签、@media规则、srcset与image-set属性 响应式图片设计 Tips 如果要优化图像，则必须从具有正确格式和正确大小的高质量图像开始： 将 JPG 用于照片，将 PNG 用于需要透明度的图形或其他图像 对于颜色数量有限的图形，请使用较小的 PNG-8 而不是 PNG-24。要进一步减小尺寸，您还可以将颜色数量从 256 减少到 16 将 SVG（矢量图形图像）用于图标和徽标。它们将很好地扩展而不会增加文件的大小 使用 10KB 以下的内联图像作为 64base 编码字符串（谨慎） 图像的实际宽度不应超过将在其中显示的最大容器的宽度乘以 2（对于视网膜显示器） 硬件像素 VS 软件像素 硬件和 CSS 像素之间的关系由以下公式描述： CSS 像素 = 硬件像素 / 像素密度 比如 Macbook Pro 屏幕全宽的图像是 1440 像素宽，但视网膜显示器的实际分辨率是 2880x1800 的两倍。因为显示器的像素密度因子为 2。 放置图片的方法There are two primary ways to put an image on a website, either by using HTML’s img element or a background-image in CSS. 浏览器兼容 srcset 目前，除了 IE、Edge 和 Opera Mini 之外的大多数浏览器都srcset实现了该属性。 WebP Chrome 和 Opera 支持 WebP 格式，约占所有浏览器的 60% 。 picture 让我们将元素添加为source元素内的第一个选项picture，您的图像采用 WebP 格式，然后img指向常规 JPG 图像。现在，当浏览器不支持 WebP 时，它会优雅地回退到img元素（例如 Safari）。 image-set 目前，它在 Chrome、Android 版 Chrome、Safari、iOS Safari 和其他一些浏览器中实现。您可以添加polyfill以使其image-set在其他浏览器上工作，但鉴于 Chrome 和 Safari 组合是当今 70% 用户的首选浏览器，大多数浏览器很有可能在不久的将来实现该属性。但不用担心，background-image作为后备选项的常规选项可以解决问题。 HTML方法12345678910111213141516171819&lt;picture&gt; &lt;source media=&quot;(min-width: 900px)&quot; srcset=&quot;image-lg_1x.webp 1x, image-lg_2x.webp 2x&quot; type=&quot;image/webp&quot; /&gt; &lt;source media=&quot;(min-width: 601px)&quot; srcset=&quot;image-md_1x.webp 1x, image-md_2x.webp 2x&quot; type=&quot;image/webp&quot; /&gt; &lt;source srcset=&quot;image-sm_1x.webp 1x, image-sm_2x.webp 2x&quot; type=&quot;image/webp&quot; /&gt; &lt;img srcset=&quot;image-sm_1x.jpg 600w, image-md_1x.jpg 900w, image-lg_1x.jpg 1440w&quot; src=&quot;image_lg_1x.jpg&quot; type=&quot;image/jpeg&quot; alt=&quot;image description&quot; /&gt;&lt;/picture&gt; 1、基本 HTMLimg元素具有src指向图像 URL 的属性 2、如果要优化图像，使用srcset属性。 3、scrset属性后跟空格是像素密度，例如1x, 2x …… 4、请注意，在img元素中，srcset属性应放在src属性之前。否则，浏览器会src先下载图像，然后，如果它在 中找到更好的图像srcset，它也会下载这个图像。这样我们最终会得到两个图像。 5、img标签，当浏览器不支持scrset属性时，会回退到src属性。 6、img标签，scrset属性接受宽度单位w，相当于 CSS 像素。宽度单位使浏览器能够为给定的显示功能选择正确的图像尺寸。 7、img标签，如果想要全宽图像（full-image)，就使用sizes属性 8、img标签，如果希望600px上使用100vw，以下使用50vw，则可以添加媒体查询 1234567&lt;img srcset=&quot;image-sm.jpg 600w, image-md.jpg 900w, image-lg.jpg 1440w&quot; sizes=&quot;(max-width: 600px) 100vw, 50vw&quot; src=&quot;image_1x.jpg&quot;/&gt; 9、picture元素接受source和img元素作为子元素，我们可以使用source元素列出希望提供给浏览器的其他图像格式。 10、如果浏览器不支持webp，会回退到img元素。 CSS方法1234567891011121314151617181920212223242526272829303132333435363738394041.bg-image { width: 100vw; height: 500px; background-size: cover; background-position: center; background-image: url(/images/image-lg_1x.jpg); // 负责处理不支持该image-set属性的浏览器。 background-image: -webkit-image-set( url(/images/image-lg_1x.webp) 1x, url(/images/image-lg_2x.webp) 2x ); background-image: image-set( url(/images/image-lg_1x.jpg) 1x, url(/images/image-lg_2x.jpg) 2x ); @media (max-width: 900px) { background-image: url(/images/image-md_2x.jpg); background-image: -webkit-image-set( url(/images/image-md_1x.webp) 1x, url(/images/image-md_2x.webp) 2x ); background-image: image-set( url(/images/image-md_1x.jpg) 1x, url(/images/image-md_2x.jpg) 2x ); } @media (max-width: 600px) { background-image: url(/images/image-sm_2x.jpg); background-image: -webkit-image-set( url(/images/image-sm_1x.webp) 1x, url(/images/image-sm_2x.webp) 2x ); background-image: image-set( url(/images/image-sm_1x.jpg) 1x, url(/images/image-sm_2x.jpg) 2x ); }} 1、如果我们不知道要用图像覆盖的容器的确切高度和宽度，我们可以使用通用元素，例如指向图像 URLdiv的属性：background-image 1background-image: url(&quot;/images/image.jpg&quot;); 2、如果要优化图像，使用image-set, image-setin CSS 相当于srcsetin HTML 。 3、使用-webkit-image-set，我们需要列出不同像素密度的 WebP 图像。 4、要记住的一件重要事情是 Chrome 和 Safari 都使用 WebKit 布局引擎，但 Safari 不支持 WebP 格式。这就是为什么我们必须为image-setJPG 图像添加最后一组属性（Safari 将使用它，即使它不以 开头-webkit）。 5、备选选项必须放在优化前面(background-imageswith the image-set attribute), 否则Safari会下载两张图片。 总结CSS与HTML方法 1、HTML的备选img与CSSbackground-image一样。 2、备选是指不支持优化属性是程序员指示浏览器加载的代码，备选的图片格式一般都是jpg。 3、HTML的优化srcset与CSSimage-set一样。 4、优化就是先细分断点，再细分像素密度，再针对不同浏览器规则细分。 如何内联小图像 为了改善用户体验，我们不仅应该压缩和提供尽可能小的图像，还应该减少发送到服务器的请求数量。浏览器必须为每个图像发送单独的请求。当发送到服务器时，请求必须首先在队列中等待，这需要时间。浏览器调用的次数越多，用户等待的时间就越长。当您必须下载许多小图像时尤其如此。如果可能，应将徽标和图标保存为矢量图形 (SVG)。小图像可以作为 base64 编码字符串直接嵌入 HTML 或 CSS 中。我们可以将图像作为字符串传递，而不是将常规 URL 传递给元素中的src属性：img。 在大多数情况下，生成的字符串将比原始图像大 30% 左右，但您将节省另一次往返服务器的时间。 反对在 CSS 文件中使用 base64 编码图像的最常见论点是图像是非阻塞资源，而 CSS 文件是。这意味着如果您在 CSS 中嵌入过多的小图像，则会增加 CSS 文件的大小并延长网站第一次绘制的时间，这将使用户等待更长时间才能看到任何内容。可以观看这篇文章，不使用Base64. [Base64 Encoding &amp; Performance, Part 1: What’s Up with Base64?]: https://csswizardry.com/2017/02/base64-encoding-and-performance/ “Base64 Encoding &amp; Performance, Part 1: What’s Up with Base64?” The truth lays probably somewhere in the middle, and injecting one or two small files as base64 strings into CSS or HTML shouldn’t do any harm. 其他什么是SVG？（伸缩矢量） SVG 指可伸缩矢量图形 (Scalable Vector Graphics) SVG 用来定义用于网络的基于矢量的图形 SVG 使用 XML 格式定义图形 SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失 SVG 是万维网联盟的标准 SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体 什么是PNG？（无损压缩）便携式网络图形（英语：Portable Network Graphics，PNG）是一种支持无损压缩的位图图形格式，支持索引、灰度、RGB三种颜色方案以及Alpha通道等特性。PNG的开发目标是改善并取代GIF作为适合网络传输的格式而不需专利许可，所以被广泛应用于互联网及其他方面上。 什么是JPG？（失真压缩）JPEG（ Joint Photographic Experts Group）即联合图像专家组，是用于连续色调静态图像压缩的一种标准，文件后缀名为.jpg或.jpeg，是最常用的图像文件格式。其主要是采用预测编码（DPCM）、离散余弦变换（DCT）以及熵编码的联合编码方式，以去除冗余的图像和彩色数据，属于**有损压缩**格式，它能够将图像压缩在很小的储存空间，一定程度上会造成图像数据的损伤。尤其是使用过高的压缩比例，将使最终解压缩后恢复的图像质量降低，如果追求高品质图像，则不宜采用过高的压缩比例。 Base64In computer programming, Base64 is a group of binary-to-text encoding schemes that represent binary data (more specifically, a sequence of 8-bit bytes) in sequences of 24 bits that can be represented by four 6-bit Base64 digits. Base64 是一种编码方式，最早出现在电子邮件传输协议中。电子邮件问世之初，传递消息时只支持 ASCII 字符，后来随着电子邮件的广泛使用，传递非ASCII字符内容的需求增加，例如：传输中文、传输文件（图片、视频）。为解决这一问题，最好的方案是在不改变传输协议的基础上，做一种扩展方案来支持非ASCII内容传输，把非 ASCII 字符用ASCII来表示，Base64编码应运而生。1 二、Base64定义Base64 是一种基于64个 ASCII 字符来表示二进制数据的表示方法。Base64 将8比特位为一个单元的字节数据拆分为以6个比特位为一个单元的二进制片段，每6个比特位单元对应Base64索引表中的一个字符，这样最终构成一个超过编码前字节数据33%的字符串。 Base64 中64个可打印字符包括字母A-Z、a-z、数字0-9，此外还有两个字符为+和/，这样构成了共有64字符的Base64索引表 字符串转base64的转码规则： Base64 将8比特位为一个单元的字节数据拆分为以6个比特位为一个单元的二进制片段；每6个比特位单元对应Base64索引表中的一个字符；按照以上方式可以算出base64编码后的字符串大约比编码前增加了33%。 为什么一些Base64后的字符中末尾有“==” 以上举例中：编码前字节数正好被3整除，转化为二进制ASCII 编码（ 3*8=24 ）后，正好可以被6整除。若编码前字节数不能被3整除，最后会余出1个或2个字节，那么编码时需要： 使用 000000 字节值在末尾补足，使其字节数能够被3整除； 编码时补位的6个比特位单元用 = 表示。 举例如下：编码 Lucy 的Base64结果为THVjeQ==，Base64编码计算过程如下： 123456文 本：L u c yASCII 编码：76 117 99 1218bit 字节：01001100 01110101 01100011 01111001 (补)00000000 (补)000000006bit 字节：010011 000111 010101 100011 011110 010000 000000 000000Base64索引：19 7 21 35 30 16 (补位) (补位)Base64编码：T H V j e Q = = WebP （有损/无损）WebP（发音：weppy）是一种同时提供了有损压缩与无损压缩（可逆压缩）的图片文件格式，派生自影像编码格式VP8，被认为是WebM多媒体格式的姊妹项目，是由Google在购买[On2 Technologies](https://baike.baidu.com/item/On2 Technologies?fromModule=lemma_inlink)后发展出来，以BSD授权条款发布。 WebP支持的像素最大数量是16383x16383。有损压缩的WebP仅支持8-bit的YUV 4:2:0格式。而无损压缩（可逆压缩）的WebP支持VP8L编码与8-bit之ARGB色彩空间。又无论是有损或无损压缩皆支持Alpha透明通道、ICC色彩配置、XMP诠释数据。 WebP有静态与动态两种模式。动态WebP（Animated WebP）支持有损与无损压缩、ICC色彩配置、XMP诠释数据、Alpha透明通道。 什么是media queryMedia Types Value Description all Default. Used for all media type devices print Used for printers screen Used for computer screens, tablets, smart-phones etc. speech Used for screenreaders that “reads” the page out loud Media Features Value Description any-hover Does any available input mechanism allow the user to hover over elements? (added in Media Queries Level 4) any-pointer Is any available input mechanism a pointing device, and if so, how accurate is it? (added in Media Queries Level 4) aspect-ratio The ratio between the width and the height of the viewport color The number of bits per color component for the output device color-gamut The approximate range of colors that are supported by the user agent and output device (added in Media Queries Level 4) color-index The number of colors the device can display grid Whether the device is a grid or bitmap height The viewport height hover Does the primary input mechanism allow the user to hover over elements? (added in Media Queries Level 4) inverted-colors Is the browser or underlying OS inverting colors? (added in Media Queries Level 4) light-level Current ambient light level (added in Media Queries Level 4) max-aspect-ratio The maximum ratio between the width and the height of the display area max-color The maximum number of bits per color component for the output device max-color-index The maximum number of colors the device can display max-height The maximum height of the display area, such as a browser window max-monochrome The maximum number of bits per “color” on a monochrome (greyscale) device max-resolution The maximum resolution of the device, using dpi or dpcm max-width The maximum width of the display area, such as a browser window min-aspect-ratio The minimum ratio between the width and the height of the display area min-color The minimum number of bits per color component for the output device min-color-index The minimum number of colors the device can display min-height The minimum height of the display area, such as a browser window min-monochrome The minimum number of bits per “color” on a monochrome (greyscale) device min-resolution The minimum resolution of the device, using dpi or dpcm min-width The minimum width of the display area, such as a browser window monochrome The number of bits per “color” on a monochrome (greyscale) device orientation The orientation of the viewport (landscape or portrait mode) overflow-block How does the output device handle content that overflows the viewport along the block axis (added in Media Queries Level 4) overflow-inline Can content that overflows the viewport along the inline axis be scrolled (added in Media Queries Level 4) pointer Is the primary input mechanism a pointing device, and if so, how accurate is it? (added in Media Queries Level 4) resolution The resolution of the output device, using dpi or dpcm scan The scanning process of the output device scripting Is scripting (e.g. JavaScript) available? (added in Media Queries Level 4) update How quickly can the output device modify the appearance of the content (added in Media Queries Level 4) width The viewport width More ExamplesExampleHide an element when the browser’s width is 600px wide or less: 12345@media screen and (max-width: 600px) { div.example { display: none; }} What is GatsbyGatsby 是一个基于React ，用于搭建静态站点的开源框架，用于帮助开发者构建运行速度极快的网站。 可以说它是一个静态站点生成器，Gatsby 主要的应用的技术是React 和GraphQL。 What is PageSpeedGoogle PageSpeed工具集是一組由Google提供的網站性能優化工具集。 Google於2010年的開發者大會上推出。page speed是开源Firefox、Firebug 插件，网站管理员和网络开发人员可以使用来评估他们网页的性能，并获得有关如何改进性能的建议。 如何生成响应式图像假设您刚刚保存了一张完美的图像，并且您想创建所有变体，以便您可以在您的网站上使用它。 有许多工具可以提供帮助。简单的工具包括compressjpeg.com、compresspng.com和tinyjpg.com。更高级的工具包括用于 JPEG、PNG 和 GIF 的ImageOptim以及用于 PNG 的ImageAlpha。 在我寻求完全控制压缩级别、格式和缩放的过程中，我需要一个工具来帮助我自动化整个过程。而且我不喜欢拖放几十张图像。 ImageMagic和GraphicsMagick都是免费且功能强大的软件，可与JavaScript 任务运行器Grunt 轻松配对。 更好的是，有 Grunt 插件可以进一步简化任务。几项快速测试表明，在相同压缩级别下，GraphicsMagick 生成的 JPG 图像比 ImageMagic 小 20%。所以选择很明确。 在我们开始穿越像素丛林之前，我们必须准备好工具并磨砺我们的斧头。从这里下载 GraphicsMagick或使用Homebrew安装它。 1brew install graphicsmagick 接下来，全局安装 Grunt 的 CLI： 1npm install -g grunt-cli 创建一个单独的文件夹responsive-images并初始化项目： 123mkdir responsive-imagescd responsive-imagesnpm init 最后，安装本地版本的 Grunt： 1npm install grunt --save-dev 创建两个文件夹：src/用于原始图像和dest/Grunt 和 GraphicsMagick 将生成的响应式图像： 12mkdir srcmkdir dest 原始图像应以等于或大于您要在src/文件夹中生成的最大图像的分辨率保存。我以 100% 质量和 2880 像素宽将我的保存为 JPG。大约是 2.5MB。 首先，让我们使用grunt-responsive-images插件生成响应式图像。安装它： 1npm install grunt-responsive-images --save-dev 现在，在项目的根目录中，创建一个附加文件Gruntfile.js： 1touch Gruntfile.js 这是我们必须配置插件的地方。 将代码复制并粘贴到Gruntfile.js，让我引导您完成代码： 1234567891011121314151617181920212223242526272829module.exports = function (grunt) { grunt.initConfig({ responsive_images: { dev: { options: { engine: &quot;gm&quot;, sizes: [ { name: &quot;sm&quot;, suffix: &quot;_1x&quot;, quality: 60, width: 600 }, { name: &quot;sm&quot;, suffix: &quot;_2x&quot;, quality: 60, width: 1200 }, { name: &quot;md&quot;, suffix: &quot;_1x&quot;, quality: 60, width: 900 }, { name: &quot;md&quot;, suffix: &quot;_2x&quot;, quality: 60, width: 1800 }, { name: &quot;lg&quot;, suffix: &quot;_1x&quot;, quality: 60, width: 1440 }, { name: &quot;lg&quot;, suffix: &quot;_2x&quot;, quality: 60, width: 2880 }, ], }, files: [ { expand: true, src: [&quot;**/*.{jpg,png}&quot;], cwd: &quot;src/&quot;, dest: &quot;dest/&quot;, }, ], }, }, }); grunt.loadNpmTasks(&quot;grunt-responsive-images&quot;); grunt.registerTask(&quot;default&quot;, [&quot;responsive_images&quot;]);}; 在options中，我们将 GraphicsMagick 设置为我们选择的引擎：engine: &quot;gm&quot;. 您还可以通过将 ImageMagick 更改为engine: &quot;im&quot;. 接下来，在sizes数组中，我们必须指定要生成的图像的参数，例如name将附加到原始名称的 a suffix，也将添加到名称的 a ， aquality和 a width。 生成的图像将具有以下命名结构： 1original-[name]_[suffix}.jpg 例如，使用第一个sizes对象，Grunt 将从原始图像中生成 60% 压缩级别和 600 像素宽my-image.jpg的图像。my-image-sm_1x.jpg 在选项下方，我们需要列出源文件夹和目标文件夹以及我们想要处理的文件名模式。 要启用文件对象的动态构建，让我们将expand属性设置为true并定义： cwd— 源文件夹 src— 要匹配的模式数组。在我们的例子中，我们希望匹配**源文件夹中的任何文件夹 ( ) 以及所有带有扩展名jpg或png dest— 目标文件夹 上述 Grunt 任务将根据源图像文件扩展名生成一组 JPG 和/或 PNG 文件。 我们还想生成一组相应的 WebP 图像。 我们需要另一个插件来完成这项工作：grunt-cwebp. 让我们安装它： 1npm install grunt-cwebp --save-dev 使用以下配置附加 Gruntfile.js： 12345678910111213141516171819202122232425module.exports = function (grunt) { grunt.initConfig({ responsive_images: { ... }, cwebp: { dynamic: { options: { q: 60, }, files: [ { expand: true, cwd: &quot;dest/&quot;, src: [&quot;**/*.{jpg,png}&quot;], dest: &quot;dest/&quot;, }, ], }, }, }); grunt.loadNpmTasks(&quot;grunt-responsive-images&quot;); grunt.loadNpmTasks(&quot;grunt-cwebp&quot;); grunt.registerTask(&quot;default&quot;, [&quot;responsive_images&quot;, &quot;cwebp&quot;]);}; 该grunt-cwebp插件使用该dest/文件夹作为图像的来源。我们希望所有新生成的 JPG 都有它们的 WebP 兄弟，我们应该将它们放在同一个文件夹中。 现在，我们可以处理图像： 1grunt 对于src/文件夹中的每张图片，Grunt 将生成 12 张所有必要尺寸、像素密度以及 JPG 和 WebP 格式的图片！ 如何生成base64字符串如果你想生成 base64 字符串来内联你的图像，这里是如何做的。 这一次，让我们使用 Grunt 插件：grunt-base64. 在单独的文件夹中创建一个新项目base64-images。npm使用本地版本的 Grunt初始化并安装它： 1234mkdir base64-imagescd base64-imagesnpm initnpm install grunt --save-dev 安装grunt-base64插件： 1npm install grunt-base64 --save-dev 在根目录中，创建一个新images/文件夹和Gruntfile.js： 12mkdir imagestouch Gruntfile.js 并将代码复制并粘贴到Gruntfile.js： 12345678910111213module.exports = function (grunt) { grunt.initConfig({ base64: { dev: { files: { &quot;images/output.b64&quot;: [&quot;images/*.{jpg,png}&quot;], }, }, }, }); grunt.loadNpmTasks(&quot;grunt-base64&quot;); grunt.registerTask(&quot;default&quot;, [&quot;base64&quot;]);}; 将小的原始图像放在images/文件夹中并运行 Grunt： 1grunt 任务完成后，复制文件中的全部内容output.b64——这是您可以粘贴到元素url的属性background-image或src属性中的 base64 字符串。img 还有一种更简单的方法（在 Mac OS X 或 Linux 上）： 1uuencode -m image-file-name remotename remotename不使用，您甚至可以将xyzbase64 字符串打印到标准输出中——在大多数情况下，打印到终端窗口中。您必须使用-m选项来获取 base64 编码。 引用 [1]: https://en.wikipedia.org/wiki/Email#Internet_Message_Format “Email “[2]: https://www.cnblogs.com/xiaxveliang/p/15097947.html “一文详解 Base64 编码原理”[3]: https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images “Responsive images”[4]: https://www.freecodecamp.org/news/a-guide-to-responsive-images-with-ready-to-use-templates-c400bd65c433 “A Guide to Responsive Images with Ready-to-Use Templates”[5]: https://www.youtube.com/watch?v=fgOO9YUFlGI “Responsive Design Tutorial - Tips for making web sites look great on any device”","link":"/2022/10/16/responsive-design/"}],"tags":[{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Modular","slug":"Modular","link":"/tags/Modular/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Vue3","slug":"Vue3","link":"/tags/Vue3/"},{"name":"Vite","slug":"Vite","link":"/tags/Vite/"},{"name":"Flask","slug":"Flask","link":"/tags/Flask/"},{"name":"uWsgi","slug":"uWsgi","link":"/tags/uWsgi/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"Echarts","slug":"Echarts","link":"/tags/Echarts/"},{"name":"Vue2","slug":"Vue2","link":"/tags/Vue2/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"}],"categories":[{"name":"FrontEnd","slug":"FrontEnd","link":"/categories/FrontEnd/"},{"name":"Personal works","slug":"Personal-works","link":"/categories/Personal-works/"},{"name":"BackEnd","slug":"BackEnd","link":"/categories/BackEnd/"},{"name":"Deploy","slug":"Deploy","link":"/categories/Deploy/"}],"pages":[{"title":"About","text":"关于 ‘ JS原型 ’ 套娃一开始，先说说为何这个知识点为什么理解起来这么乱个人感觉原因有三： JS内函数即对象。 Function对象和Object对象这两个内置对象的特殊性。（官方的神仙操作） 很多讲解图的指向一眼下去花里胡哨，看着都头疼[手动狗头]。 再说说，为何网上各位前辈的相关文章都难以参透很多前辈在讲解相关知识点的时候都是从__proto__开始讲起，但在我看来，__proto__与prototype关系之密切是无法单独提出来讲的（单独讲就意味着难以理解）；而prototype与constructor又有密切关系，这就造成一种很尴尬的处境，要先讲__proto__就必然需要同时讲解prototype和constructor属性，这个也就是为何对于小白的我们而言这些概念是那么的难以理解。（以上个人看法，仅供参考） 关于 ‘Undateable‘这是电影《弗兰西斯·哈》里主角用来形容自己的一个词语。 很喜欢电影的一段旁白撒 ～ “ 你和别人在一起的时候，有这样的瞬间，他们知道你爱他们，你也知道他们爱着你。你们在一个派对里，在跟不同的人说这话，都在开心的笑着，这时候你望向屋子的另一边，两个人的眼光交汇了，并不是那种占有欲的意思，也不是那种色眯眯的眼神，只是因为那就是你生命中的那个人。“ 改进目前大部分blog都是在二手资料基础上阅读进而整理或者直接复制得来，缺乏个人思考以及阅读官方材料，问题很大，希望未来改进，多一些原创，多看英文资料，少看中文博客（坑很多撒）～ 对用户的期望有更低的阈值～ 未填的坑[1]: https://www.youtube.com/watch?v=fgOO9YUFlGI “Responsive Design Tutorial - Tips for making web sites look great on any device” [3]: https://juejin.cn/post/6844903506797658119 “手把手教你 React 添加双向数据绑定”[4]: “计算机网络”[5]: “浏览器渲染过程与性能优化”[6]: JS的模块化[7]: JS异步 本网站依托于GitHub pages，采用Hexo，主题为Icarus，图床采用SM.MS。Repository","link":"/about/index.html"},{"title":"Resume","text":"CN EN 林佑光 18810018512 ｜ 1093742432@qq.com Github ｜个人博客 教育经历 香港中文大学 2021年09月-2022年11月 香港 信息工程 硕士 工程学院 GPA: 3.54/4.00 北京邮电大学 2017年09月-2021年06月 北京 物联网工程 学士 物联网工程 GPA: 3.45/4.00 实习经历 公司名称：HelloToby 2022年 05月 - 2022年 08月 实习背景：该公司为香港一家一站式服务配对公司。本人工作是维护面向后端人员使用的数据管理系统，完善支持后端管理人员对客户合同与任务的增删改查的功能。 主要工作： 解决开发和测试环境下的跨域问题 编写SendGrid模版作为公司邮件模版 更换组件库(Vue Material替换为Ant Design Vue) 使用Vue2框架维护现有组件 使用Git进行代码提交 公司名称：清氢捷能科技有限公司 2021年 06月 - 2021年 08月 实习背景：此项目为清华大学车辆与运载学院新能源汽车测试组参与的国家重点研发计划科技冬奥重点专项“氢能出行”。本人的工作是负责构建信息监控大数据平台，实时展示新能源汽车的数据信息。 主要工作： 使用Vue2框架搭配Echarts与百度地图通过点聚合方式显示78辆氢能源汽车的数据 使用Flex与Grid布局 使用Webpack打包与部署前端应用 项目地址：https://blog.linyouguang.com/2021/09/08/New-Energy-Car/ 项目经历 项目名称：前端监控系统 2022年 07月 - 2022年 09月 技术栈：前端：Vue3 + Vite + TypeScript + Arco Design 后端： Flask + MongoDB + Nginx 项目介绍：本项目主要是实现一个前端监控系统，使用者将本项目开发的埋点代码放置在需要被监控的前端项目中，用户的行为数据会被记录，使用者可以通过一个中台页面监控项目情况。 主要工作： 负责用户细查及总概览页面，编写相关前后端接口、用户行为捕获sdk。 使用Nginx部署前后端。 使用Swagger自动生成文档 项目地址：www.linyouguang.com:8080/login 项目文档：https://blog.linyouguang.com/2022/09/01/Monitor-SDK/ 项目名称：购物网站 2022年 01月 - 2022年 03月 技术栈：前端：JS + CSS + HTML 后端：SqlLite + PHP 项目介绍：开发一个运作良好且安全的购物网站。 主要工作： 使用HTML，CSS和JS搭建购物网站并基于AJAX与JS实现购物车功能。 基于Amazon EC2的Linux系统配置环境(Apache,PHP和SQLite)与安全设置。 基于Cookie与Session实现免登录功能。设置HttpOnly防止XSS。 使用PHP减少Web应用程序安全威胁。比如SQL注入、XSS注入与参数篡改漏洞、CSRF。 为域名申请SSL证书并使用Paypal的SDK实现支付功能。 项目名称：基于图数据库HugeGraph的医学知识图谱可视化系统 2020年 05月 - 2021年 05月 技术栈：前端：Vue + Echarts + Element-UI 后端：SpringBoot + HugeGraph 项目介绍：本项目是我的本科毕设，背景是实验室与协和医院合作开发智能医疗项目，旨在提高就诊效率等。本人的工作是将存在图数据库里的医学数据通过可视化的方式呈现出来，方便病人查阅相关医学资料。 主要工作： 利用Vue2+Echarts+Element-UI实现可视化界面。 运用Springboot实现后端查询数据接口。 运用拦截器和JWT实现特定请求的登录认证和鉴权。 利用ExceptionHandler统一处理异常，减少代码耦合度。 项目地址：https://blog.linyouguang.com/2020/09/08/Graph-Database-Visualization/ 研究经历 研究项目名称：大学生创新创业训练项目 项目名称：基于深度学习遥感图像信息提取 项目描述：我们将自动驾驶领域的实时语义模型BiseNet复现于遥感数据集Postdam上，实现了在具有实时处理速度的情况下达到了0.88的高精度。 项目成果：国家级 论文链接：https://ieeexplore.ieee.org/document/9553336 专业技能 前端：熟悉JS/HTML/CSS，ES6，了解前端页面性能监控相关知识 后端：了解Java，了解其集合类，JVM，Java内存区域，垃圾回收。掌握多线程编程，java内存模型，AQS。 计算机基础：了解操作系统，了解虚拟内存，了解TCP/IP 网络架构与HTTP协议 数据库：了解SQL语句的基本用法，了解MySQL基本架构，索引，锁，事务机制。 技能/证书及其他 证书：字节前端青训营结营证书、校级三等奖学金、优秀团员 语言：IELTS-6.5 Youguang Lin 18810018512 ｜ 1093742432@qq.com Github ｜Blog Education The Chinese University of Hong Kong Sep 2021 - Nov 2022 Information Engineering - Master - College of Engineering 3.54/4.00 Beijing University of Posts and Telecommunications Sep 2017 - Jun 2021 Internet of Things Engineering - Bachelor - International College 3.45/4.00 INTERNSHIP EXPERIENCE Company Name：HelloToby May 2022 - Aug 2022 BackGround：Toby is a community driven marketplace for services. My job is to maintain and develop the background data management system, which mainly includes the contract management and the task center, etc. In addition, it also includes support for management personnel to add, delete, modify and check contracts. Works： Solve cross-domain problems in development and testing environments Write a SendGrid template as a company email template Replace component library (Vue Material replaced with Ant Design Vue) Maintain existing components PROJECT Project Name：Monitoring System July 2022 - Sep 2022 Technology stack： Vue3 + Vite + TypeScript + Arco Design + Flask + MongoDB + Nginx Project introduction：This project mainly implements a front-end monitoring system. The user places the buried code developed by this project in the front-end project that needs to be monitored, and the user's behavior data will be recorded. Users can monitor the project status through a middle platform page. Works： Responsible for user detailed inspection and general overview page, write related front-end and back-end interfaces, user behavior capture SDK. Use Nginx to deploy the front and back ends. Automatically generate documents using Swagger Project Address：www.linyouguang.com:8080/login Project Document：https://blog.linyouguang.com/2022/09/01/Monitor-SDK/ Project Name：Shopping Website Jan 2022 - Mar 2022 Technology stack：FrontEnd：JS + CSS + HTML BackEnd：SqlLite + PHP Project introduction：The postgraduate course \"Network Programming and Security. The aim is to develop a well-functioning and secure shopping site. Works： Use HTML,CSS and JS to build shopping websites and implement shopping cart function based on AJAX and JS. Linux system configuration environment (Apache,PHP and SQLite) and security settings based on Amazon EC2. Implement login-free function based on Cookie and Session. Set HttpOnly to prevent XSS. Use PHP to reduce security threats to Web applications. Such as SQL injection, XSS injection and parameter tampering vulnerabilities, CSRF. Apply for SSL certificate for domain name and use Paypal SDK to realize payment function. Project Name：Medical Knowledge Atlas Visualization System Based on Graph Database HugeGraph May 2020 - May 2021 Technology stack：FrontEnd：Vue + Echarts + Element-UI BackEnd：SpringBoot + HugeGraph Project introduction：This project is my undergraduate program. The background is the cooperation between the laboratory and Union Medical College Hospital to develop an intelligent medical project to improve the efficiency of medical treatment. My job is to present the medical data in the graph database in a visual way to facilitate patients to consult relevant medical data. Works： Use Vue framework to cooperate with UI component library Element and visual library Echarts to build a front-end display platform Use the Springboot framework to independently build a back-end platform based on MVC pattern Obtain data through Restful API and Gremlin query language provided by HugeGraph officials Project address：https://blog.linyouguang.com/2020/09/08/Graph-Database-Visualization/ RESEARCH EXPERIENCE Innovation and entrepreneurship training program for college students Project name：Remote sensing image information extraction based on deep learning Project description：We reproduced the real-time semantic model BiseNet in the field of autonomous driving on the remote sensing dataset Postdam, and achieved a high accuracy of 0.88 with real-time processing speed. Project achievements：National level Paper Link：https://ieeexplore.ieee.org/document/9553336 SKILLS Front-end：Familiar with JS/HTML/CSS, ES6, and knowledge about front-end page performance monitoring Backend Java：Familiar with collection classes, familiar with JVM, familiar with Java memory area, garbage collection. Master multi-threaded programming, java memory model, AQS. Computer Basics：Master the operating system, understand the virtual memory, understand the TCP/IP network architecture and the HTTP protocol Database MySQL：Master the basic usage of SQL statements, familiar with the basic MySQL architecture, indexes, locks, and transaction mechanisms. AWARDS Certificate： Byte Front-end Youth Training Camp Completion Certificate School-level Third-Class Scholarship Language：IELTS-6.5","link":"/resume/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"中文简历","text":"第一页 第二页 这是一个全宽(fullwidth)圆角拨动开关状(toggle-rounded)标签页容器的第一页。 这是一个全宽(fullwidth)圆角拨动开关状(toggle-rounded)标签页容器的第二页。 林佑光 18810018512 ｜ 1093742432@qq.com Github ｜个人博客 应届生 教育经历 primary 一个主题色(primary)的代码块。 香港中文大学 2021年09月-2022年11月 香港 信息工程 硕士 工程学院 GPA: 3.54/4.00 北京邮电大学 2017年09月-2021年06月 北京 物联网工程 学士 物联网工程 GPA: 3.45/4.00 实习经历 公司名称：HelloToby 2022年 05月 - 2022年 08月 实习背景：该公司为香港一家一站式服务配对公司。本人工作是维护面向后端人员使用的数据管理系统，完善支持后端管理人员对客户合同与任务的增删改查的功能。 主要工作： 1、解决开发和测试环境下的跨域问题 2、编写SendGrid模版作为公司邮件模版 3、更换组件库(Vue Material替换为Ant Design Vue) 4、使用Vue2框架维护现有组件 5、使用Git进行代码提交 公司名称：清氢捷能科技有限公司 2021年 06月 - 2021年 08月 项目介绍：此项目为清华大学车辆与运载学院新能源汽车测试组参与的国家重点研发计划科技冬奥重点专项“氢能出行”。本人的工作是负责构建信息监控大数据平台，实时展示新能源汽车的数据信息。 主要工作： 1、使用Vue2框架搭配Echarts与百度地图通过点聚合方式显示78辆氢能源汽车的数据 2、使用Flex与Grid布局 3、使用Webpack打包与部署前端应用 项目地址：https://blog.linyouguang.com/2021/09/08/New-Energy-Car/ 项目经历 项目名称：前端监控系统 2022年 07月 - 2022年 09月 技术栈：前端：Vue3 + Vite + TypeScript + Arco Design 后端： Flask + MongoDB + Nginx 项目介绍：本项目主要是实现一个前端监控系统，使用者将本项目开发的埋点代码放置在需要被监控的前端项目中，用户的行为数据会被记录，使用者可以通过一个中台页面监控项目情况。 主要工作： 1、负责用户细查及总概览页面，编写相关前后端接口、用户行为捕获sdk。 2、使用Nginx部署前后端。 3、使用Swagger自动生成文档 项目地址：www.linyouguang.com:8080/login 项目文档：https://blog.linyouguang.com/2022/09/01/Monitor-SDK/ 项目名称：购物网站 2022年 01月 - 2022年 03月 技术栈：前端：JS + CSS + HTML 后端：SqlLite + PHP 项目介绍：开发一个运作良好且安全的购物网站。 主要工作： 1、使用HTML，CSS和JS搭建购物网站并基于AJAX与JS实现购物车功能。 2、基于Amazon EC2的Linux系统配置环境(Apache,PHP和SQLite)与安全设置。 3、基于Cookie与Session实现免登录功能。设置HttpOnly防止XSS。 4、使用PHP减少Web应用程序安全威胁。比如SQL注入、XSS注入与参数篡改漏洞、CSRF。 5、为域名申请SSL证书并使用Paypal的SDK实现支付功能。 项目名称：基于图数据库HugeGraph的医学知识图谱可视化系统 2020年 05月 - 2021年 05月 技术栈：前端：Vue + Echarts + Element-UI 后端：SpringBoot + HugeGraph 项目介绍：本项目是我的本科毕设，背景是实验室与协和医院合作开发智能医疗项目，旨在提高就诊效率等。本人的工作是将存在图数据库里的医学数据通过可视化的方式呈现出来，方便病人查阅相关医学资料。主要工作： 1、利用Vue2+Echarts+Element-UI实现可视化界面 2、运用Springboot实现后端查询数据接口 3、运用拦截器和JWT实现特定请求的登录认证和鉴权； 4、利用ExceptionHandler统一处理异常，减少代码耦合度； 项目地址：https://blog.linyouguang.com/2020/09/08/Graph-Database-Visualization/ 研究经历 研究项目名称：大学生创新创业训练项目 项目名称：基于深度学习的遥感图像信息提取 项目描述：我们将自动驾驶领域的实时语义模型BiseNet复现于遥感数据集Postdam上，实现了在具有实时处理速度的情况下达到了0.88的高精度。 项目成果：国家级 论文链接：https://ieeexplore.ieee.org/document/9553336 专业技能 前端JS：熟悉JS/HTML/CSS，ES6，了解前端页面性能监控相关知识 后端Java：熟悉集合类，了解JVM，熟悉Java内存区域，垃圾回收。掌握多线程编程，java内存模型，AQS。 计算机基础：掌握操作系统，了解虚拟内存，了解TCP/IP 网络架构与HTTP协议数据库MySQL：掌握SQL语句的基本用法，熟悉MySQL基本架构，索引，锁，事务机制。 技能/证书及其他 证书：字节前端青训营结营证书、校级三等奖学金、优秀团员 语言：IELTS-6.5 Youguang Lin 18810018512 ｜ 1093742432@qq.com Github ｜Blog Education The Chinese University of Hong Kong Sep 2021 - Nov 2022 Hong Kong Information Engineering - Master - College of Engineering GPA: 3.54/4.00 Beijing University of Posts and Telecommunications Sep 2017 - Jun 2021 Beijing Internet of Things Engineering - Bachelor - International College GPA 3.45/4.00 INTERNSHIP EXPERIENCE HelloToby May 2022 - Aug 2022 Internship background: Toby is a community driven marketplace for services. My job is to maintain and develop the background data management system, which mainly includes the contract management and the task center, etc. In addition, it also includes support for management personnel to add, delete, modify and check contracts. Main tasks: Solve cross-domain problems in development and testing environments Write a SendGrid template as a company email template Replace component library (Vue Material replaced with Ant Design Vue) Maintain existing components PROJECT EXPERIENCE Project Name : Front-end Monitoring System July 2022 - Sep 2022 Technology stack: Vue3 + Vite + TypeScript + Arco Design + Flask + MongoDB + Nginx Project introduction: This project mainly implements a front-end monitoring system. The user places the buried code developed by this project in the front-end project that needs to be monitored, and the user’s behavior data will be recorded. Users can monitor the project status through a middle platform page. Main tasks Responsible for user detailed inspection and general overview page, write related front-end and back-end interfaces, user behavior capture SDK. Use Nginx to deploy the front and back ends. Project address: www.linyouguang.com:8080/login Project Name : Shopping Website Jan 2022 - Mar 2022 Technology stack :PHP, JS, CSS, HTML, SqlLite Project Introduction: The postgraduate course “Network Programming and Security. The aim is to develop a well-functioning and secure shopping site. Main tasks: Use HTML,CSS and JS to build shopping websites and implement shopping cart function based on AJAX and JS. Linux system configuration environment (Apache,PHP and SQLite) and security settings based on Amazon EC2. Implement login-free function based on Cookie and Session. Set HttpOnly to prevent XSS. Use PHP to reduce security threats to Web applications. Such as SQL injection, XSS injection and parameter tampering vulnerabilities, CSRF. Apply for SSL certificate for domain name and use Paypal SDK to realize payment function. Project Name: Medical Knowledge Atlas Visualization System Based on Graph Database HugeGraph Technology Stack :SpringBoot, HugeGraph, Vue, Echarts, Element-UI Project Description: This project is my undergraduate program. The background is the cooperation between the laboratory and Union Medical College Hospital to develop an intelligent medical project to improve the efficiency of medical treatment. My job is to present the medical data in the graph database in a visual way to facilitate patients to consult relevant medical data. Main tasks: Use Vue framework to cooperate with UI component library Element and visual library Echarts to build a front-end display platform Use the Springboot framework to independently build a back-end platform based on MVC pattern Obtain data through Restful API and Gremlin query language provided by HugeGraph officials RESEARCH EXPERIENCE Innovation and entrepreneurship training program for college students Project name: Remote sensing image information extraction based on deep learning Project description: We reproduced the real-time semantic model BiseNet in the field of autonomous driving on the remote sensing dataset Postdam, and achieved a high accuracy of 0.88 with real-time processing speed. Project achievements: National level Paper Link :https://ieeexplore.ieee.org/document/9553336 SKILLS LIST Front-end JS: Familiar with JS/HTML/CSS, ES6, and knowledge about front-end page performance monitoring Backend Java: Familiar with collection classes, familiar with JVM, familiar with Java memory area, garbage collection. Master multi-threaded programming, java memory model, AQS. Computer Basics: Master the operating system, understand the virtual memory, understand the TCP/IP network architecture and the HTTP protocolDatabase MySQL: Master the basic usage of SQL statements, familiar with the basic MySQL architecture, indexes, locks, and transaction mechanisms. AWARDS Certificate Byte Front-end Youth Training Camp Completion Certificate School-level Third-Class Scholarship Language IELTS-6.5","link":"/resume/index%E7%9A%84%E5%89%AF%E6%9C%AC.html"}]}