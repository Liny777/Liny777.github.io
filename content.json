{"posts":[{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2022/10/08/hello-world/"},{"title":"Graph-Database-Visualization","text":"技术栈：前端：Vue + Echarts + Element-UI 后端：SpringBoot + HugeGraph 项目介绍：本项目是我的本科毕设，背景是实验室与协和医院合作开发智能医疗项目，旨在提高就诊效率等。本人的工作是将存在图数据库里的医学数据通过可视化的方式呈现出来，方便病人查阅相关医学资料。主要工作： 1、利用Vue2+Echarts+Element-UI实现可视化界面 2、运用Springboot实现后端查询数据接口 3、运用拦截器和JWT实现特定请求的登录认证和鉴权； 4、利用ExceptionHandler统一处理异常，减少代码耦合度； 作品展示： 视频展示-1： 视频展示-2: 代码地址： https://github.com/Liny777/Visualization-vue-sample","link":"/2020/09/08/Graph-Database-Visualization/"},{"title":"Monitor-SDK","text":"本项目主要是实现一个前端监控系统，使用者将本项目开发的埋点代码放置在需要被监控的前端项目中，用户的行为数据会被记录，使用者可以通过一个中台页面监控项目情况。 一、项目介绍Root：一个轻量、快速的全栈前端监控系统。 项目地址 1 项目地址 2 Github 地址： 前端 后端 埋点 测试应用 二、项目分工 团队成员 主要贡献 郑琬仪 异常概览、总概览和其他页面和接口、页面异常捕获sdk、项目进度与其他事项 林佑光 用户细查及总概览页面、相关前后端接口、用户行为捕获sdk 田雨沛 用户详情页面、相关前后端接口、Flask后端框架搭建、项目自动化构建部署、辅助组员完成代码 熊恺杰 异常详情页面、相关前后端接口、MongoDB数据库搭建、sdk打包、辅助组员完成代码 熊康伟 性能页面、相关前后端接口、页面性能sdk 龚恒 异常详情页面、相关前后端接口、HTTP请求监控sdk及打包 三、项目实现3.1 技术选型与相关开发文档 可以补充场景分析环节，明确要解决的问题和前提假设，比如按当前选型和架构总体预计需要xxx存储空间，xxx台服务器……。 本项目主要是实现一个前端监控系统，使用者将本项目开发的埋点代码放置在需要被监控的前端项目中，用户的行为数据会被记录，使用者可以通过一个中台页面监控项目情况。 3.1.1 前端技术选型：Vue3 + Vite + TypeScript + Arco Design 3.1.2 后端Flask + MongoDB 3.1.3 监控SDKWebpack 3.1.4 其他 为提升代码的可读性和可维护性，我们在前端监控系统仓库中使用 TS + ESLint 来规范成员的代码风格；为方便统计成员每次提交的内容，使用 commitlint 来规范仓库的提交信息。 网站监控系统项目中，使用 flask+mongodb 搭建数据服务器并模拟数据；在监控SDK项目中，通过设置 webpack 的请求中间件来实现虚拟服务器。 3.2 架构设计 可以补充场景分析环节，明确要解决的问题和前提假设，比如预计0.5%的用户属于大V，粉丝很多，也会经常上传视频，当前架构的解决方案是xxx。 为了使多人协同的项目进行部署时快捷高效，我们加入了自动化部署脚本 为了在有限的时间内快速开发具有良好交互特性和较美观的 UI 的网页，我们选择了字节的Arco Design组件库 为了良好的项目和组件结构，我们根据不同需求建立文件夹（概览、异常、用户、性能）内有index.vue 以及组件文件夹以存储组件，前端架构耦合度较低，便于查找和管理 3.2.1 数据库设计 3.3 项目代码介绍 前端监控系统： 123456789101112131415161718192021222324252627282930313233343536web-monitor-dashboard├─.husky├─config└─src ├─api // api接口 ├─assets // 静态资源 ├─components // 通用组件 ├─config // 项目配置 ├─directive // 自定义指令库 ├─hooks // 前端工具 ├─layout // 基础布局 ├─locale // 中英文编码 ├─mock // 数据mock ├─router // 路由文件 │ ├─appMenus │ ├─guard │ └─routes │ └─modules // 各个页面的router ├─store // 数据存储 ├─types // 数据类型定义 ├─utils // 数据类工具 └─views ├─error // 错误页面 │ ├─issue-details // 错误详情页面 │ └─issues // 错误概览页面 ├─login // 登入页面 ├─not-found // not-found 页面 ├─overview // 概览页面 │ ├─components │ └─locale ├─performance // 性能页面 │ ├─api // api性能及详情页面 │ └─page // 页面性能及详情页面 ├─user // 用户详情页面 ├─useraction // 用户细查页面 └─userinfo 后端： 123456789101112131415161718web-monitor-backend│ requirements.txt└─api │ __init__.py ├─mock │ data_generator.py │ mock_data_forger.py ├─model // 数据表定义 │ models.py ├─route │ api.py // 其他相关接口 │ errors.py // 错误相关后端接口 │ performance.py // 性能相关后端接口 │ user.py // 用户相关后端接口 │ mock_api.py └─util data_process.py utils.py 监控系统SDK： 12345678monitorSDK └─lib blankError.js // 白屏异常 jsError.js // 脚本异常 promiseError.js // Promise 脚本异常 resource.js // 资源加载异常 stayTime.js // 监控用户行为 xhr.js // 监控request 四、测试结果 建议从功能测试和性能测试两部分分析，其中功能测试补充测试用例，性能测试补充性能分析报告、可优化点等内容。 功能测试： 用户登录、路由切换 概览页面：流量数据、用户量统计、访客量趋势、页面浏览量趋势、用户平均停留时长、异常数据总览加载 用户细查页面：用户列表显示、根据用户编号查询功能 用户详情页面：用户相关信息显示 错误概览页面：异常数据图标显示、异常数据列表及根据异常类型即网页查询功能 页面性能页面：FP、FCP、DOM Ready、DNS渲染和页面列表 接口性能页面：平均请求概览、总请求量、接口列表 自适应测试 五、Demo 演示视频 六、项目总结与反思 目前仍存在的问题 数据加载速度较慢 由于对 typescript 使用上的不熟悉，类型声明考虑不周；因人力和时间关系，已完成的通用可配置组件较少 缺少强制代码评审，再加上不同成员对代码熟练程度和风格不一致，导致页面的代码结构差异较大，代码质量可以改善。 已识别出的优化项 针对服务器性能较弱的问题，应该定时整理日志的统计信息，在请求时直接返回，而不是每次都遍历全部日志进行统计。 项目的前端页面结构和功能不够完善，其中包括：缺乏切换监控不同项目、图表中可以选择更多不同的时间维度 数据结构设计存在改进空间，性能页面需要从多个表中获取不同的数据 架构演进的可能性 项目过程中的反思与总结 大部分同学对ts、python、github操作不是很熟悉 直接使用Arco Design Pro的代码为框架，但由于对代码的框架不是很熟悉导致出现问题 后期没有实时跟踪成员的进度，导致不能在成员出现代码困难第一时间发现 总结：经过这次项目，对前端监控的认识加深了很多，同时也进一步需要根据不同组员的能力进行良好和清晰的分工的重要性，尽管我们在很早就开始大项目，但是由于并没有很好组织代码提交进度，也面对了很多问题。无论如何，在大家的共同努力下依然完成了这次的大项目，辛苦大家了！ 没有进行批量上传 传输加密 sourceMap上传 sendBean上传请求 页面关闭的pv uv统计问题 七、其他补充资料（选填）7.1 用户行为PV：用户浏览量 UV：独立访客数 用户停留时长：用户在页面的停留时长 获取方法： 通过监听事件，获取用户跳转页面的行为，然后将跳转页面，用户停留时间等参数发给后端，这个时候已经获取到页面停留时间，同时可以获取pv，因为我们这里简化一下，浏览量只包括浏览页面的话，那每跳转一个页面就是一个浏览量，pv就+1，然后uv就只要对当天的统计的pv采集到的userid进行去重就可以拿到，或者直接到数据库里进行获取就好。 监听页面跳转方法：主要分为两种情况，单页面与多页面应用 单页面SPA：分为Hash模式，History模式 Hash：基于浏览器的hashchange事件，地址变化时，通过window.location.hash 获取地址上的hash值；并通过构造Router类，配置routes对象设置hash值与对应的组件内容。 History：基于HTML5新增的pushState()和replaceState()两个api，以及浏览器的popstate事件，地址变化时，通过window.location.pathname找到对应的组件。并通过构造Router类，配置routes对象设置pathname值与对应的组件内容 多页面MPA： 主要基于**onpageshow(页面显示的时候)和onpagehide(页面隐藏的时候)这两个API获取用户停留的时长。只要在onpageshow初始时间值，在onpagehide**的时间求出差值，然后上传到后台就行。但是目前没有考虑用户直接关闭浏览器的情况。 登录获取用户信息： 在安装SDK时，会先判断**localStorage里是否有用户ID，如果没有，会将请求页面发送给后端，然后后端获取用户的操作系统，设备信息以及IP信息后创建一个新用户并将新用户的ID返回给前端，前端获取到用户ID后将其存放于localStorage中。如果一开始就有用户ID，就直接从localStorage** 中获取。","link":"/2022/09/01/Monitor-SDK/"},{"title":"New-Energy-Car","text":"作品展示： 项目介绍：此项目为清华大学车辆与运载学院新能源汽车测试组参与的国家重点研发计划科技冬奥重点专项“氢能出行”。本人的工作是负责构建信息监控大数据平台，实时展示新能源汽车的数据信息。 主要工作： 1、使用Vue2框架搭配Echarts与百度地图通过点聚合方式显示78辆氢能源汽车的数据 2、使用Flex与Grid布局 3、使用Webpack打包与部署前端应用","link":"/2021/09/08/New-Energy-Car/"},{"title":"部署Hexo教程","text":"本文主要介绍 Hexo + icarus 基础环境搭建，包含 Hexo 框架的下载安装，icarus 及其组件的下载安装，完成以下操作步骤将初步完成 Hexo 博客 + icarus 主题的配置。后续将对 Hexo 博客进行功能扩展。 即： 已安装 Git 1$ git --version # 查看 git 版本 已安装 Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本) 12$ node -v # 查看 node.js 版本$ npm -v # 查看 npm 包管理器版本 如未正确安装，请参照 Hexo官方文档 进行安装，以下操作均基于Mac平台。 我的电脑需要如下操作，至今没去查为何每次使用node都需要source一下。 12$ source ~/.bash_profile # 编译一下bash文件 ？？？ $ nvm use 16 # 使用nvm切换node版本 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo 框架。 1$ npm install -g hexo-cli # 全局安装 Hexo 框架 查看 Hexo 版本，检查是否安装成功。 1$ hexo -v Hexo 初始化在任意位置新建一个文件夹，取名 blog，在blog/ 目录下 打开 CMD 窗口，运行以下命令，进行 Hexo 框架初始化。 1$ hexo init # Hexo 初始化 我安装时候，vpn有毒，即使复制终端代理命令也不行，老是断一下连一下 出现问题： 1$ npm not working - &quot;read ECONNRESET&quot; 后面用如下命令解决： use so that npm requests for http url instead of https. and then try the same npm install command 1$ npm config set registry http://registry.npmjs.org/ 我原本的源 12$ npm config get registryhttp://registry.npmjs.org/ 最后换源了 1$ npm config set registry http://registry.npmjs.org/ 下载icarus主题运行下列命令以下载 icarus 主题，此处可能下载较慢，请耐心等待。 1$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 切换icarus主题打开 _config.yml 文件，将 thems 项的值更改为 icarus 启动Hexo1$ hexo g # 生成静态页面 这里会提示错误 ERROR 我们根据上图中的错误提示安装 icarus 主题所需组件。 1$ npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 hexo-component-inferno@^0.10.1 inferno@^7.3.3 inferno-create-element@^7.3.3 再依次运行命令行，重新生成静态页面，并启动 Hexo 服务。 12$ hexo g # 生成静态页面$ hexo s # 启动服务 打开浏览器输入下列网址预览效果。 1http://localhost:4000b 添加 自定义页面 新建一个 分类 页面 1$ hexo new page categories 新建一个 标签 页面 1$ hexo new page tags 新建一个 关于我 页面 1$ hexo new page &quot;about&quot; 写作123$ hexo new [layout] &lt;title&gt; # layout布局默认为post，有三种默认布局即post、page 和 draft，在创建者三种不同类型的文件时，它们将会被保存到不同的路径；# 而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 新建一篇文章示例： 1$ hexo new 第一篇文章的名字 在此之前通常建议开启 _config.yml 中的资源文件夹，以便创建文章的同时，自动为你创建同名资源文件夹，这通常用于存放你在本篇文章所用到的图片等资源。存在此文件夹中的图片，Hexo 生成静态页面时，将会将二者存放在同一文件夹下。 1post_asset_folder: true # 开启文章资源文件夹 部署在正式开始部署上传到 GitHub 上前，通常建议配置 SSH 秘钥，这样不用每次上传部署都要进行登录验证，有关如何配置 SSH 秘钥，请参阅 ————–此处省略10000字————————- ————–挖坑1：GitHub 添加 SSH————— 详情请参阅：Git配置SSH秘钥 ————–挖坑2：GitHub 静态页面————— 首先在_config.yml中修改添加以下内容，指定部署上传的 GitHub 库。 123456789deploy: type: git repo: git@github.com:local-host-8080/local-host-8080.github.io.git branch: master type: git repo: &lt;repository url&gt; branch: [branch] message: [message]Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}) 安装 1git 组件 1$ npm install hexo-deployer-git --save 此外，如果您的 Github Pages 需要使用 CNAME 文件自定义域名，请将 CNAME 文件置于 source/ 目录下，只有这样 hexo deploy 才能将 CNAME 文件一并推送至部署分支。 上传至GitHub 123$ hexo clean$ hexo g$ hexo d Hexo 一篇文章多个 categories子分类下面的分类配置会将该文章放到 Sports/Baseball 这个分类下。 123categories: - Sports - Baseball 同样的作用还可以这样写： 1categories: [Sports,Baseball] 上面两种写法最终的效果都是一样的，都是将文章放在了一个子分类目录下。 多个分类如果我们的要求是将文章同时分到两个或者多个不同的类目下呢？官方给出的方法是： 123categories: - [Sports] - [Baseball] 只需要用中括号将独立的分类括起来即可，这样上面的文章就会被分类在 Sports 和 Baseball 这两个不同的目录中了。 扩展一下，如果我们要将其分类到 Sports/Baseball 和 Play 两个不同的目录下（一个是子目录，一个是一级目录），我们该怎么写呢？如下： 123categories: - [Sports,Baseball] - [Play] 图片放置1{% asset_img 1.jpg This is an image %} 摘要1&lt;!--more--&gt; 评论Gitalk安装指南在线预览 登录GitHub并点此注册一个新的OAuth应用。填写”应用名称“(Application name)，”应用主页“(Homepage URL)，”应用描述“(Application description)。然后，在”认证回调地址“(Authorization callback URL)填写你的博客的根URL地址。点击“注册应用”(Register application)按钮来跳转到应用详情界面。 复制”Client ID“与”Client Secret“的值并填入主题配置的相应配置项中。 例如，对于下面的”Client ID“和”Client Secret“： 1234Client IDxxxxxxxxxxxxxxxxxxxxClient Secretxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 对应如下的Gitalk的配置： 123456789101112131415comment: type: gitalk client_id: xxxxxxxxxxxxxxxxxxxx client_secret: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx repo: Some-of-Your-GitHub-Repo # 你的github分支名字就好，不用全部 owner: you_github_name admin: - you_github_name per_page: 20 # 可选填 distraction_free_mode: false # 可选填 pager_direction: last # 可选填 create_issue_manually: false # 可选填 proxy: # 可选填 flip_move_options: # 可选填 enable_hotkey: true # 可选填 暂时就这样…","link":"/2022/10/08/%E9%83%A8%E7%BD%B2Hexo/"},{"title":"Java Basics","text":"Java基础知识高频问题 1.Java语言的三大特性是什么？ 2.重载与重写的区别 3.接口和抽象类的区别是什么？ 4.Java中的内部类说一下 5.说一下final关键字的作用 6.说一下String，StringBuilder和StringBuffer的区别 7.说一下Java中的==与eaquels的区别 8.Java访问修饰符有哪些？都有什么区别？ 追问：怎么获取private修饰的变量 9.Java中的异常体系说一下？ 追问：异常的处理方式？ 10.Java中的深拷贝和浅拷贝说一下？ 追问：浅拷贝与深拷贝的特点是什么？ 1. 面向对象三大特征 封装封装是指将对象的属性私有化，提供一些可以访问属性的方法，我们可以通过访问这些方法得到对象的属性。 继承继承是指某新类继承已经存在的类，该新类拥有被继承的类的所有属性和方法，并且新类可以根据自己的情况拓展属性或方法。其中新类被称为子类，原存在的类被称为父类。1、子类拥有父亲类对象所有的属性和方法（包括私有属性和私有方法），但是父类中私有属性和方法子类是无法访问，只是拥有。2、子类可以拥有自己属性和方法，即子类可以对父类进行拓展。3、子类可以用自己的方式实现父类的方法。 子类不能直接访问父类的私有属性，子类只能在父类中写一个public的getXXX的方法来获取父类中的private属性，子类就调用父类的getXXX来获取private属性 在子类的构造方法中通过super()方法调用父类的构造方法来继承到父类的私有域。 构造子类的同时，为子类构造出跟父类相同的域。如此就在子类的对象中，也拥有了父类声明的域了 多态多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作。 多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。【摘自JavaGuide】 在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。 总结封装：封装起来，只提供访问接口 继承：新继承已有的，然后根据自己情况拓展 多态：同一个行为不同表现形式（比如飞，各种飞行姿势等）- 接口 和 继承来实现 2. 重载和重写 重载：重载是发生在同一个类中，具有相同的方法名，但是有不同的参数，参数的个数不一样、参数的位置不一样、这叫做重载，常见的就比如构造方法，有参构造和无参构造。 重写：发生在当子类继承父类时，对父类中的一些方法根据自己的需求进行重写操作。 父类方法被默认修饰时，只能在同一包中，被其子类被重写，如果不在同一包则不能重写。 父类的方法被protoeted时，不仅在同一包中，被其子类被重写，还可以不同包的子类重写。 重写方法的规则：1）、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。 2）、返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。 3）、访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private） 4）、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。 重载的规则：1）、必须具有不同的参数列表； 2）、可以有不同的返回类型，只要参数列表不同就可以了； 3）、可以有不同的访问修饰符； 4）、可以抛出不同的异常； 总结：重写：只有内容和权限可以不一样，其他必须一样 重载：函数名字一样，其他都可以不一样 3. 抽象类和接口的区别 接口（Interface）和抽象类（Abstract class）是支持抽象类定义的两种机制。抽象是对类的抽象。 接口是公开的，不能有私有的方法或变量，接口中的所有方法都没有方法体，通过关键字interface实现。接口是对行为的抽象。抽象类是一种模版，接口是一种行为规范。 抽象类是可以有私有方法或私有变量的，通过把类或者类中的方法声明为abstract来表示一个类是抽象类，被声明为抽象的方法不能包含方法体。子类实现方法必须含有相同的或者更低的访问级别（public-&gt;protected-&gt;private)。抽象类的子类为父类中所有抽象方法的具体实现，否则也是抽象类。特点： 被abstract修饰，没有方法体的方法称为抽象方法； 抽象方法必须存在于抽象类中，不能存在于非抽象类； 抽象方法必须在其子类中实现，除非子类也是抽象类； 如果一个类中含有抽象方法，该类一定是抽象类，该类必须被abstract修饰； 如果一个类是抽象类，该类可以含有抽象方法和非抽象方法 如果一个类为抽象类，则该类不能被实例化，必须通过该类的非抽象子类进行实例化 相同点：（1）：都不能被实例化（2）：接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。 不同点： （1）：接口只有定义，不能有方法的实现，但java1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。（2）：实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。（3）：接口强调特定功能的实现，而抽象类强调所属关系。（4）：接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）（5）：接口被用于常用的功能，便于日后维护和添加删除，而抽象类更倾向于充当公共类的角色，不适用于日后重新对立面的代码修改。从设计层面来说，抽象是对类的抽象，是一种设计模版，而接口是对行为的抽象，是一种行为的规范。 总结：接口：行为约束，只约束行为类别，不约束行为内容，implements，没有构造方法，一个类实现多个接口 抽象：代码复用，extends，有构造方法，一个类继承一个抽象 同：都不能实例化，不能private 4. Final修饰类、方法、字段分别起到的作用？ 总结：类：不能被继承，成员方法被隐式地指定为final方法。方法：不能被重写 字段 常量：不能修改 变量/引用型：不能指向其他人 5. String VS StringBuffer VS StringBuilder 总结String：不可变，原理final，private final char value[]，操作少量 StringBuffer：可变，继承自AbstractStringBuilder，加了同步锁，唯一一个线程安全，多线程选择他 StringBuilder：可变，继承自AbstractStringBuilder，单线程， 6. 说一下Java中的==与eaquels的区别 ==对于基本类型和引用类型 == 的作用效果是不同的，如下所示： 基本类型：比较的是值是否相同； 引用类型：比较的是引用是否相同； 1、比较的是操作符两端的操作数是否是同一个对象。 2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。 3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如： int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。 1234567String x = &quot;string&quot;;String y = &quot;string&quot;;String z = new String(&quot;string&quot;);System.out.println(x==y); // trueSystem.out.println(x==z); // falseSystem.out.println(x.equals(y)); // trueSystem.out.println(x.equals(z)); // true equalsequals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。 首先来看默认情况下 equals 比较一个有相同值的对象，代码如下： 12345678910111213141516171819class Cat { public Cat(String name) { this.name = name; } private String name; public String getName() { return name; } public void setName(String name) { this.name = name; }}Cat c1 = new Cat(&quot;王磊&quot;);Cat c2 = new Cat(&quot;王磊&quot;);System.out.println(c1.equals(c2)); // false 输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下： 123public boolean equals(Object obj) { return (this == obj);} 原来 equals 本质上就是 ==。 同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下： value哪来的？？？ – String底层是数组，value可以拿到String的char数组。 123456789101112131415161718192021public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false;} 源码里String的代码： 123456789101112public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String = aString = (String)anObject; if(coder() == aString.coder()) { return isLatin1() ? StringLatin1.equals(value, aString.value) : StringUTF16.equals(value, aString.value); } } return false;} 原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。 equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。 String s=”abce”是一种非常特殊的形式,和new 有本质的区别。它是java中唯一不需要new 就可以产生对象的途径。 以String s=”abce”;形式赋值在java中叫直接量,它是在常量池中而不是象new一样放在压缩堆中。这种形式的字符串，在JVM内部发生字符串拘留，即当声明这样的一个字符串后，JVM会在常量池中先查找有有没有一个值为”abcd”的对象。 如果有，就会把它赋给当前引用.即原来那个引用和现在这个引用指点向了同一对象，如果没有，则在常量池中新创建一个“abcd””，下一次如果有Strings1=”abcd”；又会将s1指向“abcd”这个对象，即以这形式声明的字符串，只要值相等，任何多个引用都指向同一对象。 而String s=new String（”abcd”）；和其它任何对象一样.每调用一次就产生一个对象，只要它们调用。 也可以这么理解：String str=”hello”；先在内存中找是不是有“hello”这个对象，如果有，就让str指向那个“hello”。 如果内存里没有”hello”，就创建一个新的对象保存”hello”.String str=new String（“hello”）就是不管内存里是不是已经有”hello”这个对象，都新建一个对象保存”hello”。 总结==：对象地址，基本数据类型 == 比较的是值，引用数据类型==比较的是内存地址 equals：没有重写，同==。重写了，则是比较内容是否相同，而不是地址。 插播：如果两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？ 不对，两个对象的 hashCode()相同，equals()不一定 true。显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。 7. Java中的内部类 成员内部类 12345678910111213class Circle { double radius = 0; public Circle(double radius) { this.radius = radius; } class Draw { //内部类 public void drawSahpe() { System.out.println(&quot;drawshape&quot;); } }} 这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。 1234567891011121314class Circle { private double radius = 0; public static int count =1; public Circle(double radius) { this.radius = radius; } class Draw { //内部类 public void drawSahpe() { System.out.println(radius); //外部类的private成员 System.out.println(count); //外部类的静态成员 } }} 不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问： 12外部类.this.成员变量外部类.this.成员方法 虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问： 123456789101112131415161718class Circle { private double radius = 0; public Circle(double radius) { this.radius = radius; getDrawInstance().drawSahpe(); //必须先创建成员内部类的对象，再进行访问 } private Draw getDrawInstance() { return new Draw(); } class Draw { //内部类 public void drawSahpe() { System.out.println(radius); //外部类的private成员 } }} 成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下： 1234567891011121314151617181920212223242526272829public class Test { public static void main(String[] args) { //第一种方式： Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); //必须通过Outter对象来创建 //第二种方式： Outter.Inner inner1 = outter.getInnerInstance(); }} class Outter { private Inner inner = null; public Outter() { } public Inner getInnerInstance() { if(inner == null) inner = new Inner(); return inner; } class Inner { public Inner() { } }} 内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。 局部内部类 123456789101112131415161718class People{ public People() { }} class Man{ public Man(){ } public People getWoman(){ class Woman extends People{ //局部内部类 int age =0; } return new Woman(); }} 注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。 匿名内部类 匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听 1234567891011121314151617scan_bt.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { // TODO Auto-generated method stub } }); history_bt.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { // TODO Auto-generated method stub } }); 这里new onClickListener()就是匿名内部类 就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。 123456789101112131415161718192021private void setListener(){ scan_bt.setOnClickListener(new Listener1()); history_bt.setOnClickListener(new Listener2());} class Listener1 implements View.OnClickListener{ @Override public void onClick(View v) { // TODO Auto-generated method stub }} class Listener2 implements View.OnClickListener{ @Override public void onClick(View v) { // TODO Auto-generated method stub }} 这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。 匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。 静态内部类 静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。 1234567891011121314151617public class Test { public static void main(String[] args) { Outter.Inner inner = new Outter.Inner(); }} class Outter { public Outter() { } static class Inner { public Inner() { } }} 使用场景为什么在Java中需要内部类？总结一下主要有以下四点： 1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整， 2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。 3.方便编写事件驱动程序 4.方便编写线程代码 个人觉得第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善。 面试笔试题1.根据注释填写(1)，(2)，(3)处的代码1234567891011121314151617181920212223242526public class Test{ public static void main(String[] args){ // 初始化Bean1 (1) bean1.I++; // 初始化Bean2 (2) bean2.J++; //初始化Bean3 (3) bean3.k++; } class Bean1{ public int I = 0; } static class Bean2{ public int J = 0; }} class Bean{ class Bean3{ public int k = 0; }} 从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。 创建静态内部类对象的一般形式为： 外部类类名.内部类类名 xxx = new 外部类类名.内部类类名() 创建成员内部类对象的一般形式为： 外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名() 因此，（1），（2），（3）处的代码分别为： 12345678# 成员内部类Test test = new Test(); Test.Bean1 bean1 = test.new Bean1(); # 静态内部类Test.Bean2 b2 = new Test.Bean2();# 局部内部类Bean bean = new Bean(); Bean.Bean3 bean3 = bean.new Bean3(); xw 2.下面这段代码的输出结果是什么？123456789101112131415161718192021public class Test { public static void main(String[] args) { Outter outter = new Outter(); outter.new Inner().print(); }} class Outter{ private int a = 1; class Inner { private int a = 2; public void print() { int a = 3; System.out.println(&quot;局部变量：&quot; + a); System.out.println(&quot;内部类变量：&quot; + this.a); System.out.println(&quot;外部类变量：&quot; + Outter.this.a); } }} 123321 最后补充一点知识：关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点： 1）成员内部类的引用方式必须为 Outter.Inner. 2）构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》 1234567891011121314151617class WithInner { class Inner{ }}class InheritInner extends WithInner.Inner { // InheritInner() 是不能通过编译的，一定要加上形参 InheritInner(WithInner wi) { wi.super(); //必须有这句调用 } public static void main(String[] args) { WithInner wi = new WithInner(); InheritInner obj = new InheritInner(wi); }} 总结：成员内部类：在另一个类内部 局部内部类：方法或者一个作用域里，与成员内部类区别：访问权限只局限于方法内或作用域 匿名内部类：唯一一种没有构造器的类，用于实现接口 静态内部类：在另一个类里，与成员内部类区别：不过多了一个关键字static 8. Java有哪些修饰符？有哪些区别？Java中的修饰符有public、private、protected. 1、public：public表明该数据成员、成员函数对所有用户开放的，所有用户都可以直接进行调用2、private：private表示私有、私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用。3、protected：protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他外部class，protected就变成private。 总结： 访问级别 访问控制修饰符 同类 同包 子类(不同包) 不同包(其他类) 公共 public 允许 允许 允许 允许 受保护 protected 允许 允许 允许 不允许 默认 缺省修饰符 允许 允许 不允许 不允许 私有 private 允许 不允许 不允许 不允许 public: 全 private：只能类内 protected：不能不同包 追问：怎么获取private修饰的变量Private通过反射获取，可以设置setAccessable为true实现 下面是某博客的例子，只是一个演示用法。 123456789101112131415161718192021/** * @Description: 反射 * @author: Mr_VanGogh */public class Reflect { private String name; private int age; private Reflect(int age) { this.age = age; } private void speak(String name) { System.out.println(&quot;My name is&quot; + name); } public Reflect(String name) { this.name = name; }} 反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。 12345Class clz = Class.forName(&quot;com.chenshuyi.reflect.Apple&quot;);Method method = clz.getMethod(&quot;setPrice&quot;, int.class);Constructor constructor = clz.getConstructor();Object object = constructor.newInstance();method.invoke(object, 4); 首先，我们要了解三个反射包中的类： Constructor：代表类的单个构造方法，通过Constructor我们可执行一个类的某个构造方法（有参或者无参）来创建对象时。 Method：代表类中的单个方法，可以用于执行类的某个普通方法，有参或无参，并可以接收返回值。 Field：代表类中的单个属性，用于set或get属性 AccessibleObject：以上三个类的父类，提供了构造方法，普通方法，和属性的访问控制的能力。 使用Class类中的方法可以获得该类中的所有Constructor对象，Method对象，和Field对象。但是任然无法访问私有化的构造方法，普通方法，和私有属性，此时我们可以使用他们继承父类(AccessibleObject)中的setAccessible（）方法，来设置或取消访问检查，以达到访问私有对象的目的。 1234567891011121314151617181920public static void main(String[] args) throws Exception { Reflect reflect = new Reflect(&quot;a&quot;); Method[] methods = Reflect.class.getMethods(); Field[] fields = Reflect.class.getDeclaredFields(); for (int i = 0; i &lt; fields.length; i ++) { fields[i].setAccessible(true); System.out.println(fields[i].getName()); } for (int j = 0; j &lt; methods.length; j ++) { methods[j].setAccessible(true); System.out.println(methods[j].getName()); methods[j].invoke(reflect); System.out.println(methods[j].getName()); } } 9. Java的异常体系说一下？ Java中的异常主要分为Error和Exception Error指Java程序运行错误，如果程序在启动时出现Error，则启动失败；如果程序运行过程中出现Error，则系统将退出程序。出现Error是系统的内部错误或资源耗尽，Error不能在程序运行过程中被动态处理，一旦出现Error，系统能做的只有记录错误的原因和安全终止。 AWTError / ThreadDeath Exception指Java程序运行异常，在运行中的程序发生了程序员不期望发生的事情，可以被Java异常处理机制处理。Exception也是程序开发中异常处理的核心，可分为RuntimeException（运行时异常）和CheckedException（检查异常），如下图所示。 RuntimeException （Unchecked Exception）（运行时异常）：指在Java虚拟机正常运行期间抛出异常，RuntimeException可以被捕获并处理，如果出现情况，我们需要抛出异常或者捕获并处理异常。常见的有NullPointerExcception, ClassCastException, ArrayIndexOutOfBoundsException等 CheckedException（检查异常）：指在编译阶段Java编译器检查CheckedException异常，并强制程序捕获和处理此类异常，要求程序在可能出现异常的地方通过try catch语句块捕获异常并处理异常。常见的有由于I/O错误导致的IOException、SQLException、ClassNotFoundException等。该类异常通常由于打开错误的文件、SQL语法错误、类不存等引起。 总结：在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类: Error：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获不建议通过catch捕获 。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。 Exception：程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。 异常的处理方式？异常处理方式有抛出异常和使用try catch语句块捕获异常两种方式。（1）抛出异常：遇到异常时不进行具体的处理，直接将异常抛给调用者，让调用者自己根据情况处理。抛出异常的三种方式：throws、throw和系统自动抛出异常。其中throws作用在方法上，用于定义方法可能抛出的异常；throw作用在方法内，表示明确抛出一个异常。（2）使用try catch捕获并处理异常：使用try catch捕获异常能够针对性的处理每种可能出现的异常，并在捕获到异常后根据不同的情况做不同的处理。其使用过程比较简单，用try catch语句块可能出现异常的代码包起来即可。 10. Java中的深拷贝和浅拷贝说一下？深拷贝和浅拷贝都是对象拷贝 浅拷贝：按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。（浅拷贝仅仅复制所考虑的对象，而不是复制它所引用的对象）。 深拷贝：在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。（深拷贝把要复制的对象所引用的对象都复制了一遍。） 特点：浅拷贝特点（1）：对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个。（2）对于引用类型，比如数组或者类对象，因为引用类型是引用传递，所以浅拷贝只是把内存地址赋值给了成员变量，它们指向了同一内存空间。改变其中一个，会对另外一个也产生影响。 深拷贝特点（1）对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个（和浅拷贝一样）。（2）对于引用类型，比如数组或者类对象，深拷贝会创建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。（3）对于有多层对象的，每个对象都需要实现Cloneable并重写clone（）方法，进而实现了对象的串行层层拷贝。（4）深拷贝相比于浅拷贝速度较慢并且花销较大。 参考链接[1]: https://www.cnblogs.com/dolphin0520/p/3811445.html “Java内部类详解”[2]: https://www.nowcoder.com/discuss/916143 “Java超高频面试题汇总”[3]: https://juejin.cn/post/6844903790089338887 “你真的懂==和equals的区别吗？”[4]: “《java编程思想》” [5]: https://cloud.tencent.com/developer/article/1886994 “面试官：private修饰的方法可以通过反射访问，那么private的意义是什么？”[6]: https://javaguide.cn/java/basis/java-basic-questions-01.html# “JavaGuide” [7]: https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html “大白话说Java反射：入门、使用、原理”[8]: https://blog.csdn.net/u012723673/article/details/80613557 “Java中各类修饰符的使用总结（看完这篇就够了）”","link":"/2022/10/08/String/"},{"title":"ModularJs","text":"1、Object-LiteralClean it up into a self-encapsulated module that is easy to work with. Self - Encapsulated : 将一个对象封装起来 Efficient Dom Usage : 把需要操作的Dom元素进行缓存 - CacheDom function Render Method : 视频中是使用Mustache.render配合template进行渲染。 Bind Events : 给Dom元素一并添加点击事件，将每个事件独立地写在外面，bindEvent只负责绑定。 Delete Events : 记得写一个删除绑定，监听函数等的一个函数，避免内存泄漏。 12345678910111213141516171819202122232425262728293031323334353637383940var people = { people: ['Will', 'Steve'], init: function() { this.cacheDom(); this.bindEvents(); this.render(); }, cacheDom: function() { this.$el = $('#peopleModule'); this.$button = this.$el.find('button'); this.$input = this.$el.find('input'); this.$ul = this.$el.find('ul'); this.template = this.$el.find('#people-template').html(); }, bindEvents: function() { this.$button.on('click', this.addPerson.bind(this)); this.$ul.delegate('i.del', 'click', this.deletePerson.bind(this)); }, render: function() { var data = { people: this.people, }; this.$ul.html(Mustache.render(this.template, data)); }, addPerson: function() { this.people.push(this.$input.val()); this.render(); this.$input.val(''); }, deletePerson: function(event) { var $remove = $(event.target).closest('li'); var i = this.$ul.find('li').index($remove); this.people.splice(i, 1); this.render(); }};people.init(); 但是上面这种写法有个缺点，可以直接在浏览器控制台去调用API直接操控对象元素。我们不想用户能够调用render、cacheDom等函数，只希望他们能够调用addPerson和DeletePerson，因此我们在给上面对象封装一层，只暴露出安全的想给用户用的接口。 We write a revealing module pattern by starting with a self-executing anonymous function also known as an IIFE (immediately invoked function expression). This runs a function and sets it’s return value as our module’s value. If we return an object of methods, then those methods are what other modules have “public” access to. What’s nice about this, is we can create any variables within the function and no other modules have access to them unless we expose them via our return object. 方法：(function(){})() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var people = (function(){ var people = ['Will', 'Steve']; //cache DOM var $el = $('#peopleModule'); var $button = $el.find('button'); var $input = $el.find('input'); var $ul = $el.find('ul'); var template = $el.find('#people-template').html(); //bind events $button.on('click', addPerson); $ul.delegate('i.del', 'click', deletePerson); _render(); // 代表私有变量 function _render() { $ul.html(Mustache.render(template, {people: people})); } // Maybe String or index or other function addPerson(value) { var name = (typeof value === &quot;string&quot;) ? value : $input.val(); people.push(name); _render(); $input.val(''); } function deletePerson(event) { var i; if (typeof event === &quot;number&quot;) { i = event; } else { var $remove = $(event.target).closest('li'); i = $ul.find('li').index($remove); } people.splice(i, 1); _render(); } return { addPerson: addPerson, deletePerson: deletePerson };})();//people.addPerson(&quot;Jake&quot;);//people.deletePerson(0); 给私有方法或变量加下划线 What kind of cool is we can keep these internal methods whatever we want to call them here’s very common thing is if something is private if it’s internal you’ll see an underscore there so let me find every where render is called and give it an underscore.Unserscore usually means it is private where we’re storing this internally we’re never exposing. 2、Pub - Subwe’ll cover the pubsub design pattern (publish/subscribe), which allows us to decouple our modules. Once integrated with our pubsub module, they can emit events and not have to worry about which modules depend on them. Modules can subscribe to events and be notified when any module publishes. 事件的格式是 key:name(Listener) | value:[event1,event2,......] This loose coupling will allow the application to grow significantly larger without encountering problems. 下面是两个模块整合在一起，但是彼此互不依赖，却可以实现一个更新另一个也更新，这就是Vue双向绑定的底层原理，逻辑层与视图层实时更新。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//events (publish subscribe) patternvar events = { events: {}, on: function (eventName, fn) { this.events[eventName] = this.events[eventName] || []; this.events[eventName].push(fn); }, off: function(eventName, fn) { if (this.events[eventName]) { for (var i = 0; i &lt; this.events[eventName].length; i++) { if (this.events[eventName][i] === fn) { this.events[eventName].splice(i, 1); break; } }; } }, emit: function (eventName, data) { if (this.events[eventName]) { this.events[eventName].forEach(function(fn) { fn(data); }); } } }; // Stats module (function(){ var people = 0; //cache DOM var $stats = $('#statsModule'); var template = $('#stats-template').html(); //bind events events.on('peopleChanged', setPeople); _render(); function _render() { $stats.html(Mustache.render(template, {people: people})); } function setPeople(newPeople) { people = newPeople; _render(); } function destroy(){ $stats.remove(); events.off('peopleChanged',setPeople) } return { destroy: destroy } })(); //people module (function(){ var people = ['Will', 'Steve']; //cache DOM var $el = $('#peopleModule'); var $button = $el.find('button'); var $input = $el.find('input'); var $ul = $el.find('ul'); var template = $el.find('#people-template').html(); //bind events $button.on('click', addPerson); $ul.delegate('i.del', 'click', deletePerson); _render(); function _render() { $ul.html(Mustache.render(template, {people: people})); events.emit(&quot;peopleChanged&quot;, people.length); } function addPerson(value) { var name = (typeof value === &quot;string&quot;) ? value : $input.val(); people.push(name); _render(); $input.val(''); } function deletePerson(event) { var i; if (typeof event === &quot;number&quot;) { i = event; } else { var $remove = $(event.target).closest('li'); i = $ul.find('li').index($remove); } people.splice(i, 1); _render(); } })(); 这里插播一下平时面试常考的发布订阅模式：实现思路 创建一个 EventEmitter 类 在该类上创建一个事件中心（Map） on 方法用来把函数 fn 都加到事件中心中（订阅者注册事件到调度中心） emit 方法取到 arguments 里第一个当做 event，根据 event 值去执行对应事件中心中的函数（发布者发布事件到调度中心，调度中心处理代码） off 方法可以根据 event 值取消订阅（取消订阅） once 方法只监听一次，调用完毕后删除缓存函数（订阅一次） 注册一个 newListener 用于监听新的事件订阅 12345678910111213141516171819202122232425262728293031323334353637class EventEmitter{ constructor(){ this._events = {}; } on(eventName, callback){ if(this._events[eventName]){ if(this.eventName !== &quot;newListener&quot;){ this.emit(&quot;newListener&quot;, eventName) } } const callbacks = this._events[eventName] || []; callbacks.push(callback); this._events[eventName] = callbacks } emit(eventName, ...args){ const callbacks = this._events[eventName] || []; callbacks.forEach(cb =&gt; cb(...args)) } // 其中once部分可以进行修改，是阿里二面的时候一位哥告诉我的, 传入callback时，传入一个匿名函数，然后里面分别先执行callback再调用off进行销毁～ once(eventName, callback){ const one = (...args)=&gt;{ callback(...args) this.off(eventName, one) } one.initialCallback = callback; this.on(eventName, one) } off(eventName, callback){ const callbacks = this._events[eventName] || [] const newCallbacks = callbacks.filter(fn =&gt; fn != callback &amp;&amp; fn.initialCallback != callback /* 用于once的取消订阅 */) this._events[eventName] = newCallbacks; }} 3、Prototypal Pattern vs Classical OOP in JS两种方法都可以实现继承，但是第二种会更简洁。 3.1 Classical OOPHere’s the link to the “inherit” function I use here: https://github.com/nodejs/node-v0.x-a... Using a constructor, a prototoype, and the “new” keyword, we can create multiple copies or “instances” of a module, each with unique properties, but shared functionality. We can also implement inheritance in Javascript. If we create a new module, we can inherit the functionality of a parent module with a simple inheritance helper function. 跟Java继承一个意思撒～ 有一个点注意一下： Friend.super_.call(this, name); 这里其实和Java抽象有点像，为了使得父子的共同属性保持一致变化，所以需要把name的this从子指向父。这样父亲name的变化，子的name也会跟着变化。（把共同属性的this指向父亲） 如果子类要拓展自己的方法，用如下写法： Musician.prototype.shoutName = function() { console.log(&quot;DUDE!!!&quot;) } 删除的时候，如下，使用delete API： delete Musician.prototype.shoutName 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// /**// * Inherit the prototype methods from one constructor into another.// *// * The Function.prototype.inherits from lang.js rewritten as a standalone// * function (not on Function.prototype). NOTE: If this file is to be loaded// * during bootstrapping this function needs to be rewritten using some native// * functions as prototype setup using normal JavaScript does not work as// * expected during bootstrapping (see mirror.js in r114903).// *// * @param {function} ctor Constructor function which needs to inherit the// * prototype.// * @param {function} superCtor Constructor function to inherit prototype from.// */// exports.inherits = function(ctor, superCtor) {// ctor.super_ = superCtor;// ctor.prototype = Object.create(superCtor.prototype, {// constructor: {// value: ctor,// enumerable: false,// writable: true,// configurable: true// }// });// };// classical prototypalfunction inherites(ctor, superCtor) { ctor.super_ = superCtor; ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });};var Person = function(name) { this.name = name}Person.prototype.sayName = function() { console.log(this.name)}Person.prototype.shoutName = function() { console.log(this.name + '!')}var john = new Person();var bobby = new Person();var Friend = function(name) { // Person.call(this,name) Friend.super_.call(this, name); }inherities(Friend, Person);var julia = new Friend(&quot;julia&quot;);julia.sayName();var Musician = function(name, instrument) { Musician.super_.call(this, name); this.instrument = instrument;}Musician.prototype.shoutName = function() { console.log(&quot;DUDE!!!&quot;)}inherites(Musician, Person);Musician.prototype.getInstrument = function() { console.log(this.instrument);}var Jason = new Musician(&quot;Jason&quot;, &quot;trombone&quot;)delete Musician.prototype.shoutName/** * The delete operator in JavaScript is used to delete an object's property. * If it is used to delete an object property that already exists, * it returns true and removes the property from the object. * However, deleting an object property that doesn't exist will not affect the object, but will still return true . */ 3.2 Prototypal PatternWhile many JS devs still use classical OOP, many have switched to the prototypal pattern for Module Inheritance and Instantiation. Here’s the prototypal pattern for JS and why some devs find it simpler to use. Basically, when coding JS OOP with the prototypal pattern, everything is an object. You start with an object literal and, then, to inherit from it, you use Object.create(someModule) to create a child that inherits from it. var parent = {some: method}; var child = Object.create(parent); //now add new methods to the child child.newMethod = someMethod; So there’s really no difference between inheritance and instantiation in the prototypal method. To create multiple children, simply: var child1 = Object.create(parent); var child2 = Object.create(parent); And there you have it! Also see the source javascript code on how to include a create method so creating is a little more seamless. 123456789101112131415161718192021222324252627282930313233343536373839// classical prototypal/*** * Define : * Object.create() method is used to create a new object with the specified prototype object and prototypes. * Object.create() method returns a new object with the specified prototype object and properties. * Application : * Object.create() is used for implementing inheritance. */var human = { species: &quot;human&quot;, // Rewrite Object.create function create: function(values) { var instance = Object.create(this); Object.keys(values).forEach(function(keys) { instance[keys] = values[keys]; }); return instance; }, saySpecies: function() { console.log(this.species); }, sayName: function() { console.log(this.name); }};var musician = Object.create(human); // inherited humanmusician.playInstrument = function() { console.log(&quot;plays...&quot; + this.instrument);}var will = Object.create(musician); // inherited musician - &gt; human will.name = &quot;Will&quot;;will.instrument = &quot;Drums&quot;;var musician2 = human.create({ species: &quot;musician&quot;, playInstrument: function() { console.log(&quot;plays&quot;+this.instrument); }}) 其他[1]: https://www.youtube.com/c/learncodeacademy “Youtuber Learncode.academy”[2]: https://juejin.cn/post/6844904101331877895 “从发布订阅模式入手读懂Node.js的EventEmitter源码”[3]: https://juejin.cn/post/6985156199192723487 “手写一个基于发布订阅模式的js事件处理中心(EventEmitter)”","link":"/2022/10/10/ModularJs/"}],"tags":[{"name":"Echarts","slug":"Echarts","link":"/tags/Echarts/"},{"name":"Vue2","slug":"Vue2","link":"/tags/Vue2/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Vue3","slug":"Vue3","link":"/tags/Vue3/"},{"name":"Vite","slug":"Vite","link":"/tags/Vite/"},{"name":"Flask","slug":"Flask","link":"/tags/Flask/"},{"name":"uWsgi","slug":"uWsgi","link":"/tags/uWsgi/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Modular","slug":"Modular","link":"/tags/Modular/"}],"categories":[{"name":"Personal works","slug":"Personal-works","link":"/categories/Personal-works/"},{"name":"FrontEnd","slug":"FrontEnd","link":"/categories/FrontEnd/"},{"name":"BackEnd","slug":"BackEnd","link":"/categories/BackEnd/"},{"name":"Deploy","slug":"Deploy","link":"/categories/Deploy/"}],"pages":[{"title":"About","text":"关于 ‘ JS原型 ’ 套娃一开始，先说说为何这个知识点为什么理解起来这么乱个人感觉原因有三： JS内函数即对象。 Function对象和Object对象这两个内置对象的特殊性。（官方的神仙操作） 很多讲解图的指向一眼下去花里胡哨，看着都头疼[手动狗头]。 再说说，为何网上各位前辈的相关文章都难以参透很多前辈在讲解相关知识点的时候都是从__proto__开始讲起，但在我看来，__proto__与prototype关系之密切是无法单独提出来讲的（单独讲就意味着难以理解）；而prototype与constructor又有密切关系，这就造成一种很尴尬的处境，要先讲__proto__就必然需要同时讲解prototype和constructor属性，这个也就是为何对于小白的我们而言这些概念是那么的难以理解。（以上个人看法，仅供参考） 关于 ‘Undateable‘这是电影《弗兰西斯·哈》里主角用来形容自己的一个词语。 很喜欢电影的一段旁白撒 ～ “你和别人在一起的时候，有这样的瞬间，他们知道你爱他们，你也知道他们爱着你。你们在一个派对里，在跟不同的人说这话，都在开心的笑着，这时候你望向屋子的另一边，两个人的眼光交汇了，并不是那种占有欲的意思，也不是那种色眯眯的眼神，只是因为那就是你生命中的那个人。 未填的坑[1]: https://www.youtube.com/watch?v=fgOO9YUFlGI “Responsive Design Tutorial - Tips for making web sites look great on any device” 本网站依托于GitHub pages，采用Hexo，主题为Icarus，图床采用SM.MS。Repository","link":"/about/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"中文简历","text":"林佑光 18810018512 ｜ 1093742432@qq.com Github ｜个人博客 应届生 教育经历 香港中文大学 2021年09月-2022年11月 香港 信息工程 硕士 工程学院 GPA: 3.54/4.00 北京邮电大学 2017年09月-2021年06月 北京 物联网工程 学士 物联网工程 GPA: 3.45/4.00 实习经历 公司名称：HelloToby 2022年 05月 - 2022年 08月 实习背景：该公司为香港一家一站式服务配对公司。本人工作是维护面向后端人员使用的数据管理系统，完善支持后端管理人员对客户合同与任务的增删改查的功能。 主要工作： 1、解决开发和测试环境下的跨域问题 2、编写SendGrid模版作为公司邮件模版 3、更换组件库(Vue Material替换为Ant Design Vue) 4、使用Vue2框架维护现有组件 5、使用Git进行代码提交 公司名称：清氢捷能科技有限公司 2021年 06月 - 2021年 08月 项目介绍：此项目为清华大学车辆与运载学院新能源汽车测试组参与的国家重点研发计划科技冬奥重点专项“氢能出行”。本人的工作是负责构建信息监控大数据平台，实时展示新能源汽车的数据信息。 主要工作： 1、使用Vue2框架搭配Echarts与百度地图通过点聚合方式显示78辆氢能源汽车的数据 2、使用Flex与Grid布局 3、使用Webpack打包与部署前端应用 项目地址：https://blog.linyouguang.com/2021/09/08/New-Energy-Car/ 项目经历 项目名称：前端监控系统 2022年 07月 - 2022年 09月 技术栈：前端：Vue3 + Vite + TypeScript + Arco Design 后端： Flask + MongoDB + Nginx 项目介绍：本项目主要是实现一个前端监控系统，使用者将本项目开发的埋点代码放置在需要被监控的前端项目中，用户的行为数据会被记录，使用者可以通过一个中台页面监控项目情况。 主要工作： 1、负责用户细查及总概览页面，编写相关前后端接口、用户行为捕获sdk。 2、使用Nginx部署前后端。 3、使用Swagger自动生成文档 项目地址：www.linyouguang.com:8080/login 项目文档：https://blog.linyouguang.com/2022/09/01/Monitor-SDK/ 项目名称：购物网站 2022年 01月 - 2022年 03月 技术栈：前端：JS + CSS + HTML 后端：SqlLite + PHP 项目介绍：开发一个运作良好且安全的购物网站。 主要工作： 1、使用HTML，CSS和JS搭建购物网站并基于AJAX与JS实现购物车功能。 2、基于Amazon EC2的Linux系统配置环境(Apache,PHP和SQLite)与安全设置。 3、基于Cookie与Session实现免登录功能。设置HttpOnly防止XSS。 4、使用PHP减少Web应用程序安全威胁。比如SQL注入、XSS注入与参数篡改漏洞、CSRF。 5、为域名申请SSL证书并使用Paypal的SDK实现支付功能。 项目名称：基于图数据库HugeGraph的医学知识图谱可视化系统 2020年 05月 - 2021年 05月 技术栈：前端：Vue + Echarts + Element-UI 后端：SpringBoot + HugeGraph 项目介绍：本项目是我的本科毕设，背景是实验室与协和医院合作开发智能医疗项目，旨在提高就诊效率等。本人的工作是将存在图数据库里的医学数据通过可视化的方式呈现出来，方便病人查阅相关医学资料。主要工作： 1、利用Vue2+Echarts+Element-UI实现可视化界面 2、运用Springboot实现后端查询数据接口 3、运用拦截器和JWT实现特定请求的登录认证和鉴权； 4、利用ExceptionHandler统一处理异常，减少代码耦合度； 项目地址：https://blog.linyouguang.com/2020/09/08/Graph-Database-Visualization/ 研究经历 研究项目名称：大学生创新创业训练项目 项目名称：基于深度学习的遥感图像信息提取 项目描述：我们将自动驾驶领域的实时语义模型BiseNet复现于遥感数据集Postdam上，实现了在具有实时处理速度的情况下达到了0.88的高精度。 项目成果：国家级 论文链接：https://ieeexplore.ieee.org/document/9553336 专业技能 前端JS：熟悉JS/HTML/CSS，ES6，了解前端页面性能监控相关知识 后端Java：熟悉集合类，了解JVM，熟悉Java内存区域，垃圾回收。掌握多线程编程，java内存模型，AQS。 计算机基础：掌握操作系统，了解虚拟内存，了解TCP/IP 网络架构与HTTP协议数据库MySQL：掌握SQL语句的基本用法，熟悉MySQL基本架构，索引，锁，事务机制。 技能/证书及其他 证书：字节前端青训营结营证书、校级三等奖学金、优秀团员 语言：IELTS-6.5 Youguang Lin 18810018512 ｜ 1093742432@qq.com Github ｜Blog Education The Chinese University of Hong Kong Sep 2021 - Nov 2022 Hong Kong Information Engineering - Master - College of Engineering GPA: 3.54/4.00 Beijing University of Posts and Telecommunications Sep 2017 - Jun 2021 Beijing Internet of Things Engineering - Bachelor - International College GPA 3.45/4.00 INTERNSHIP EXPERIENCE HelloToby May 2022 - Aug 2022 Internship background: Toby is a community driven marketplace for services. My job is to maintain and develop the background data management system, which mainly includes the contract management and the task center, etc. In addition, it also includes support for management personnel to add, delete, modify and check contracts. Main tasks: Solve cross-domain problems in development and testing environments Write a SendGrid template as a company email template Replace component library (Vue Material replaced with Ant Design Vue) Maintain existing components PROJECT EXPERIENCE Project Name : Front-end Monitoring System July 2022 - Sep 2022 Technology stack: Vue3 + Vite + TypeScript + Arco Design + Flask + MongoDB + Nginx Project introduction: This project mainly implements a front-end monitoring system. The user places the buried code developed by this project in the front-end project that needs to be monitored, and the user’s behavior data will be recorded. Users can monitor the project status through a middle platform page. Main tasks Responsible for user detailed inspection and general overview page, write related front-end and back-end interfaces, user behavior capture SDK. Use Nginx to deploy the front and back ends. Project address: www.linyouguang.com:8080/login Project Name : Shopping Website Jan 2022 - Mar 2022 Technology stack :PHP, JS, CSS, HTML, SqlLite Project Introduction: The postgraduate course “Network Programming and Security. The aim is to develop a well-functioning and secure shopping site. Main tasks: Use HTML,CSS and JS to build shopping websites and implement shopping cart function based on AJAX and JS. Linux system configuration environment (Apache,PHP and SQLite) and security settings based on Amazon EC2. Implement login-free function based on Cookie and Session. Set HttpOnly to prevent XSS. Use PHP to reduce security threats to Web applications. Such as SQL injection, XSS injection and parameter tampering vulnerabilities, CSRF. Apply for SSL certificate for domain name and use Paypal SDK to realize payment function. Project Name: Medical Knowledge Atlas Visualization System Based on Graph Database HugeGraph Technology Stack :SpringBoot, HugeGraph, Vue, Echarts, Element-UI Project Description: This project is my undergraduate program. The background is the cooperation between the laboratory and Union Medical College Hospital to develop an intelligent medical project to improve the efficiency of medical treatment. My job is to present the medical data in the graph database in a visual way to facilitate patients to consult relevant medical data. Main tasks: Use Vue framework to cooperate with UI component library Element and visual library Echarts to build a front-end display platform Use the Springboot framework to independently build a back-end platform based on MVC pattern Obtain data through Restful API and Gremlin query language provided by HugeGraph officials RESEARCH EXPERIENCE Innovation and entrepreneurship training program for college students Project name: Remote sensing image information extraction based on deep learning Project description: We reproduced the real-time semantic model BiseNet in the field of autonomous driving on the remote sensing dataset Postdam, and achieved a high accuracy of 0.88 with real-time processing speed. Project achievements: National level Paper Link :https://ieeexplore.ieee.org/document/9553336 SKILLS LIST Front-end JS: Familiar with JS/HTML/CSS, ES6, and knowledge about front-end page performance monitoring Backend Java: Familiar with collection classes, familiar with JVM, familiar with Java memory area, garbage collection. Master multi-threaded programming, java memory model, AQS. Computer Basics: Master the operating system, understand the virtual memory, understand the TCP/IP network architecture and the HTTP protocolDatabase MySQL: Master the basic usage of SQL statements, familiar with the basic MySQL architecture, indexes, locks, and transaction mechanisms. AWARDS Certificate Byte Front-end Youth Training Camp Completion Certificate School-level Third-Class Scholarship Language IELTS-6.5","link":"/resume/index.html"}]}