{"posts":[{"title":"2022总结","text":"46a3af2f61b98285d792aaf9035b9662763e3a6ffeefe444695620ab9290328b29727ab022c0145ca509e13fea491b417d72cadf425dedd35e1c85358fd552d66d536803e60620985567a8464a1f4639f0772f858bbc54cfce833a8a05b6448f2cee21932a77aaddb558fb538675629735fb79f40311f0a627d5282a5ac3eb06b0f4f28c6ef13879e3e1a9af6df81ed6d15ee723d13e78d026ef9a9ed492226a0175e040fb2494fcda7f29efd2820c021432f9e90192c2ffb39d8d7a5acf79f85c9c28ea40bc8550625ad57d03302c8877ddefa55935acc902cbbb3025b88acb7d1c29854d0613f3f88292debf30f9e93c531f00487a386c68537b577e45a33b8b1baec10f3ef0a88fecd35a4edfea54497bbafd68123e685e70e462404b0a8028f8a00430702c8bc5cba46e92ba932784ddcafe280306c097000e7d2ce6c3dcfbbe82939975083f7b5e26566078080a93867c028fd1f160d44fd8f9ba0ae54ca95ed376166cf0c912e8b1dcb81d6f974d39237bca22e2ed42e84954f7a572e5d2ad879c1eac1171e69f7f0a4111ae4604eb51c6d711fffd8be730d0de4b5fe746e91197272529666bbd003b17ae4958f5b8426e6bb7fa4f9f1dd798b8656b88cf139abc69c3be97fb88a480c3eed9efab97c76468ea283d5710f0320792bf7e109858e059d1693ea79850ac56139602b5d4ed0a14326e16a3df3e1af219c7c354719720b282c0617f52b5b1ab743474444bbe79871480350ec1553c9f6b35f6257816f7fe5a26f37ee6c0b708fbfbcb75987b09931ac6c6e531a639e91885fe9c3abdffb7eee2a38d6543fa278992e34d83592274ce5b7f31f58900a091257ad68f7d59bd3a41cab7cd8bbfd3fe28ea280a9a28c18c1ca6aaa67b37cb1929fa2b052613ca4f86b28393ea7c37c96091132cdb1280e47baea8dc631a0111752d1857fa32cf5d01c3d149b626f7fa949df4e07a88c0840b6d1ef50790c5a1a5f26a462281be3817f690f33d29fd53648dfb67b134313b70d4de55e9654c274dd4b99298899e27843b97db0c9b736980135d0471bbbd5cc2aae42f1d4ed87dc73f255149d9950b0e1a0631072b1dd57018535d3bbd3f6ce388fe26240ebd3bacaf78d4b577ea15641df0dcfbfa75d363ff6a62e874e9d5fd9d0e88f2676a0ff7036a7e823fe017b697b3bace5a852e30b9335d37e788b6b4ce274faa2f752bfeb25d078f2943bfa08e28c644c2f49af83d654a821f4b6950b5bd5db3a16022e5545b52dbdcb50139102f34cd6719c4ae6dd49461a50dbf037cbd1df0cc24768fac3bb9cbc5b4fc8f5a9db506bfc0e88401a402cb997ef2a2a4130228e69847c6240afad40ef09004224c92e2df5967eda0e9effb633c74c7616be1ad9f1525fcc4878cdb786000128cbf0f358fea09b5982b7ba71f5262b8f12ce48904c3f2d6fbb8bd7732486231513c6d877c84ba4f77543e17ea33fdf919949d586916c57cbd0d07a5c86c82449f6590228a7d4562862cf6c6a7a0ccf40b5ca2c96fe6eec31bb3f186c59b70a2a619a51ab6e02c8d383576458aa940d3659d69393c4dee63334a5b58dce1923b8309fd7c1912c56684c7e5fa4b96947ac5c92ef7e9184863cee65d030cc73ad344e6d92edba2365a92e74bf6e1bb18b5e4446c74d8ad35355de4b10dddeb6bf497f0b4f2b5e0bc626c16b1febdd095ef017d4073524b193c31414d0660160af682af4545a190d678f3d1fa7ed1bbe212e85ea4f0a70e5ea7b5c502a35c184b00f92d17a4b1caff4a557b0584d1451952b54ba1f0e15cc0a897856316c1dadb149df89efc6277a6694dc22d1acf32642fdb1fda16b365487a735b7b05db3e38f9a3d6e84ddfcf749bf2f86069e5f2749472331db93b99dab60b9513a71063b5018008ce410ee531248bfd9eeb498e737f303b8799960e550b71b50633c83ec671e92eb105ceaf2b4e4416889224ed5704a2413368e1357227b14bdb91befa8703002d6814ad3d765072752b4a8a6dceae60bc2046593f36cb26bb2d7fd585d80d020baa8808cbe2f24682306a5a17ab77ba9273b1dfe802dad5d324652233198320918ab817ea1f2fa65651d118425c7fcd24f19b40f130003aabbcc4fd8e731cf5d8f53c223348f00ae7dbeb99690204d646c8b976e07b812060fc07c34a4318aeb222e657e02af6d95b6bfdaa9de397ebb397835dabc33bb96a9217f7075d4b81b74b0c9b8347e7741fa417d596850f7b2399912afffc909e9acfa9a6cafb09da79ec1eeefaa4fe559cec993c88868513f516f35b480186a8d326a64d3f0d18a5a848b28b68b175d3ec06fd7b93d2c0e696469cb5a0600a70e308960c85199d323a776d70c32c1b89040a8656530fe3ab4dafd4eff028b731b4c8c0e059094ba81eae8f7c7a12c6dbb0b9c0579e6d576ff80787a1a663416db595f2de80fcb74302b055e439e8f0f67598fa89c5ce823789c957e520d7ef3fa3d2d5f71f56bd588d07a64dfff211b30b197dc4ab8d31029ecdf55a7de028ec2a2abca61911bb3892571d5cf7e2d53b63493cbb71d8f0559871f51d8a25839d3d5d574b26f69a81752140ca1382699dd2eb1cf4b2d0c1a4c6a3700e283629fc7c5cdc0979a8a8ef423dbc9b7c8c1011244427b22008b6b74d2ef0321aa071a960ffc583006d208fd2b31dd9393e4d6b140cd24d64dcb3689c9c54e2bc1866c960f7f6fa809566b6faa8c1288f1e665c664d3db99dafebbf0325a4944d9d6973475a8c8ad65d546fd6b03b35a0bf1fe3a202d5a229fcd2720778668cde97239938daf344b9117f5624a1b2230065913efeda49b67fd8385d5608bc1286db78429b28198b0426901d5b33d3b45e24eeda1573c7aeb9749f1791d0e25a58b28f5bcedaf5ebf56bf73d695a8233ac09a45b954c79e9dae9d4d1a8b86ab1fbaad21551c24eabbb4494b579912780441f33c462700acc9ff0881bcda2e685edab8192d67484d29d565a6aa8fac9a39b608c840894b57b3b43b71bc05800ad3b07495963063bc0b57b600a42a95bd086ddc755d89c0a84800c580a409aea577bf617a9e7c62f80afd0e998a35039aca6c08bc927a3203d3f12b0c633ecc529a7ad2b71a3959d0adce21dd520f6c15e61f24141693a1a78df127a474ac93f6a9bb9072f2ccde87ecf8291359a1e1a61f442e9bcec536427593aa513610bdfe194d598bf5627016a231d4daea56cc4ef8689ac2d5bf6dbcad7ff937417bfa740e8c8619d5dd3c3486f4920ae2f86f6abdcf7a74b8ba479aa42d25934b795c7a12c23261d1aee1e99a3016cc25f5190f70e50114dfa5ef40fb210e091a8473d8d0717745b34e54f4f8c1bb7186b7955c71c9f3696a895b72efec7b037f885677497a0d58749c766b90bcfd2541b8d15859b9db79fb3a745d356dec026a7e70e73606f70c85b5266894c3b19c25f341221ce61d5dc8e0e0929a74285c04c2bfd14d5cbe2b3feac4cbb39fc72409837cde5301dd61132436ff3ecd8235e7a40f6261dce74d805c5afab26bf757ee73705ada66baee4bef02218f1dc2fde1d847719f9ef783a1d330e18c1056ff1f7f746330a25c21510ed12542fd882aa633accfd722b17230b127e3e7894d1ffb8f960cab425f02732b7befdef9dda66f97cc92fdeff3ceaa2fbd372d6e1b9d456a566d222d21720854bbc8eec071c591790f07a4e437239ad540fabd078e665fecb0b7dc34ff2fd55c1fe7278b142b861f8a3c6fada6bf584037350cb812b8b107645a24dcaad621dbf65dea33fb48b21cbd9081f5f4db2439a5745a3331fa1450efe98c722a87cc97b27f6d3cd755e3dd90b94ae4ddc8f8757a6de7354bbd5c8dbab35b963cb6f18d4de2d1f97c2849bc1ce0d9d4435b42d9b1a151e803d788482c1669e760cbf79c2161b3d52f0d1cd44fa6fbcb7e7b429257eacd82c0bf16b99ee68161f0ea3d6c19a3c85f403661d6a41d4148b4d4105f1545d8b8be962beafacf435b91e2e8c0a65f59db5ae04d7cdf544b10754f9ea7747c8e7f994578217dd329bbc5defc3dbb52757266ef088b1934583eabe5370ea1f1bad51689151e6b2512b14d9167cfd97034b2b3cf0ba4063c81624a22060044549206de8a59d24c6439ca5983f7a0dae939ac3eb85092f014fa70c9d9d0fcf455fe246b3c78ed0b4a57793e5c42c54e6ecf1df6c026c1d40f01494c5eadc4cb697d385ab728b6cd3ca291c99d86515e212e7bf97a226c15baaf6c52e827400768af2f71203507bdd909625b3913253e4ba711887b098e97d59e9110abb4f5b737d5341f9fff862abb5c563104d13c692a50d672399b861d84084dac550408ae46b1ca31e3b65eff928fd73f81a81338ffb84952b3900b33413957830d2c4d4b763ddcdc86812f747d0e9076a0213be350dc4f126b3532a5f16db51a15d29c10e046173531671887d0509603570a1de4c23afda005eb5f4d56df2c6af56298f5d2644b9597de1849c037d4a759ad708a1aae75a978cee56074f7108bba335f294bdc16803276cf777f0461f99918b00f053e9166529383cc64c7d0f63e2bc99d20882b23647e80682542249c9a750faf83ea44360a0000422af159b1427daed6d64a40871b585e6f370a6573917a1a40f5a99d74384616600cbbaabd21196250422fd21aa5fa2644c22731ab5bfae9e7ca1623c54442b8dd49c8c5e6c69b3a04aac2db911d94c0f70992dc72dd3efbeeff1bd0fa070f7f322da45fc1d6e9138693df9ac99d3362f34479cc1a499798e169790ab5ccb9d9aeec82cc40d0d01cb685c368a35c10af6d83536cbb44f9253c6cc35d23b47f54b747b15a4a6d8e00ad44af368afde06a521207304d022364a0ffaf9d33e06eefd3fe82727647a8dca5f291b271abb8781c11fb74fa3374b75fc203528ca8210914a52587955a962a86a4be119d0b9b741b8bdcd3144d4d57cdad6d1942864f89b97be951b26a2ca382259614cd53288365876caffa2c3564625c1a0aa45a9c9991f8863a1a87f401c8fef9f8aa1cf13217923a9816628369577c624811406bcf1c0cc3b524d7dce7e9a94e6056a959fea9207d54bbd0b65ec028f80143a916f7124fc3aed6a4fbc396b10feabebbf65ea9627371e19d8c8dd1899c2a611d9060980e93739e0999591d9c9d1e755275f32d3ff1958eed9bc534f31ebb26ccf4fcaa3aef0373ba613818b8da853fda3ebabe4095d630b0f93ddc86cfda84cfc8a468d2ce6aa9c451ab4f329531413540139118e746bed7bc11cc38e65ec5f9dbea6a3fe5ff77edb078e7592380aa6f8205382a0660c16e64a2bff003b45e2a5a91f7132471b0e6f011794160532bdd925b9be60a528f9874fd6377ce4b642b89eae4d16426653df70ebd09bccdcf1b32a2a43d4c2a2e1df774e7e5953848615d7dd9af0038639ce927df55759191c35fe7f8200f00675ea95cc78fa83d5b0f9b5d18b0a33c96bf050c4db22ceed46f3a15fa56ae83738a9fc10cb6832d38523c09e1892d5fe2d097aa7fb8b0b336df7c23ab5da917c6f8ff0d112f7317d5b8b43e22bc99c682c6cfc2e88c2e4deb5e362e81b90f32a916753c075b03574d0b06bdd4be9a41e8bf05207bd84941b538e37727f534b0ce62b857c1bc2d91290a673ceb90bb15aea7a244708a1b52d4da0520948b2cccc20af6b877dc6ae2de3bcb161d74373cdbe148628f5a38ff977c3bc29a2d002382555c8d31d3b7fc6e009fcb3cfa22e21417a0a309bd81c2a4040fdb84d6999e6adc8ef944ed483b27a835a96287da00fd67050573d0e3cdf7298ead0ab90322e3f56b11b68e2573a1194caf7ad3ca1e2e5f75e38db2a30060a0406f7b8129f09046a449d90e973e57352af2d18ecc5c2f36d017e5925c297afc7d6ab88667ca237a815e6b0ffaff388468d9f86918d0f0a67e98c7782209303e86e1643a7e11f5e54f6e069cfa9e8bd7a4585709ddb90ee554c3f803daefe518e6d272ab957b9b38a9462915e1aff301d31eeaf111d032d7fe0f449d267f0780702bac42d6261f361ad0514e28969baf098cd44e241059c93396456a328ddf0d8d2005e0523c3ba3067a921f7164b57643dd86ed90ab20f40ccf0882ceea8c5802689468ea076e2238afc2089c9208e4cb24750bff0be79e0a7a4cab21e728ec998c62e789e536566d756a84250f0a342e6d5eca548bd4e8ae22d33cb614a139f3bb494adaf1fc9324a5245f28bf4e3617561c1bc0e2b07df2af9c9b302fe6df8dfa4aa3c08c438451f781e4fe76f1e29bf2ececa907dd0c5407944b2c60cc87a5ee00d5d1c68f13004549eaecff46938bddf06f57deebc0300df1f8a38c187bfe63121d64eca277107e6594d32e87eaed792e9a822dffcdd21d2bbc5349292b6873965556844037af007be55e0cc0159ba0a08f771caa011a375f11a67e855dfbc9bd2a03361724f37b854aa6e823e909edd9cd5635a0fe0a9f9bf0aa8f81a8499d3b5a8c5f92e1eaf88f0a73031a9814334cf2e0a79dba52d441c7c7e485e706ab32ef515bcaa2c4b39e00a2cea4702a5076ff5016b2252c697ea98067022cd193610072030fcf373a2cf91e31a587130ffd887f484d7f11a27b19a029eba3e6f1082f3c3fcaa4ef081bafa19a90ce2fa66ce2337bc61128f9aef3f13bc3a199b964bee1c05708aa66cc2af65575518b1b4976ac75128ee81269c8094146c4db032919f67e170242054ad16388083c2024756ee6492983c1dd0e54bdea57ced28568be888c1b4a4ec41ffd894ce4c88187a4ee58583e2988c77f150cfc67ef661fbe8b5ea717bcec72590e61b2c925c5e1e5d44d233c376cbd9222f3ab1b5e75fc7efc63b4a2662041d4d2536840732d6253e2eae3c9e59616d5eb65f5c493a2b9f4576237bcfaeafbcd8de24eac90547cc8fb41293053f79279fbe130932f3f0ba261c992d5b85744f69996fff246c73f923b2a061a855209dbf8a1cfd05ae9a0370f0e6f4a8ba4e9403c3860d7a80e3eba7a3d6f8f6d2e9e39e99ea09eda6e82e4f57228174884627209cb908faa090f5ead0faca1f422febe952f8377fcad0e382d6cd329f64178f165fa585433dd6843f2d34b19a19ff18eaae35a7249216ea75834e1afc1d484abdfbddbd0ce220ce657d7b16343e176ebed4d482301fbefbfacf48a410b1dc0450be071e6f699ecbeec20314c4ac53260320deb1116e302e1291f737b7ffd636c984264186e133ad3e0569916aa4a57ff12af54ab197e62c90fa4e8414f76cc0d31ef5994fc344fee85e9dd7192e3830f2758c94346da94f193aac76f4502a22c8075125b1d8e300efb32e7a3aec07bc5db2574f8f98980931342b97045f00deb973d77acf3df5e1af1dbfaeba86d3ecd98d86510da3aaf9f2053a60acc317991c19bd8762614c52d716c4212368249c6683023360c0fdbacdbb81ba9a41f633a100e171524badb638be75ca5119081009880d3a9aed2d87e26ee8535b912b93c750d805c49cfbaee6b13a493f627de997e27a8f4d463164cda2ab4fb90f2526e079bd6108719fd05f014a97ee875126ad07b132ce7832ab5169c0edf009b1b446b4af4c935fb18e4ff70a56eb5058af327cbfba6a2993dd4414904cb9496fe638a348f03362f0332dc40239afd940ab3aeeef1df7393752109852b2c38ac5aaee96f8c3058d73dd54d684a6d40994362b499cbead4082f749a5ebb1e8f53fb7b18d3a3f2e4be512f20b897d1a29d58c85e1946b0b7ed710a7055f9a85f9d4c224362fc0fd343191d783f46f3274a91165a1996f50a970e173e9595b91974e9ffc770fef7865176891468a808d1f5c727357f55b545e2cd687af39e3b447be50e39c6779a077f20da83e654b703e6c3a7fd3e03ea02d51d898758f877e5a31c67b9d8b87df1461bf36d8e90d5212db57468de21a2b0e8a23b209c4d51886f876cb1766df34e4f7f87a49f04f7e4af4e3dd00d080281c6acdc16c5a65d10daa884189b0c1f25dbf56400019dab4740248e0a1283cc93c54df62409bbb9d4803d2368801ae394859458ed2c28578922a8564cd23a9fe0def591033ffa5fec10d1ddebfadbc7b079a0b6c1c83cf70553143345e610b0b44cee1972c939b3384ad1ad04431ec39158436a11d3774b73e4a8850f756e31b5a58a65d7a476430ffba49b65679e1c2e68f7816a2c93cd1049e71b9c0fcb5ae3f6a5864817e22aef239fd3fb3380a71e301ced2729b908439024efaed16d1839837fd70306710943e57e48790360ee5d0a06aef725f28f581f9c01e0aa65413ccd082155a1e70040c55585b6fd72eac6cda418f8eb96fe8c14754125c9acc70004351c12e9b60b0ad4e57e040d85174e119af6dacb91f074f3c40f2a9de581037bd0377c26947026627b69b0f6f4f1e2eb6e770c6e4c39749cfc715f19ea9208cb284bbe367c5d1db43b4e2dbf5720725349ffd48c1cada2600c75b9ad8f69472adfe71403b33f8f44285a0ef6d1d54af736620cea1384d8921352fef2d66e93694e518785cd7bfdd48280937648df2700b45074c66479c89307c328eee71ebd26fb6f985df077d26f18425199ae6a59cd078dcfb5118724be1f8e2e4bf88029112f0433db695ce28f435710aad5d6c41dca240be04062df311ddc0f47817510308a30d6c97366f55c85c57b1ed02d620d36e9243248e1cc50eca483438ae2fa7952b5ca50487549d4f6826070c52937747109b17f01c2c9213635455f394f315621638683faba1c603ee9feb2323a3cb5775a7c42a69d8b5e82777d5caa3342dca9f8992d7b49e4dc460e08951876aa9644fc0f4fb648b28ee77b9fcb34b483719954f2fcedc4f5d8afe0917ff209544ed70fad2c3a37d0c4d4438129947626257e970479f9e9bb5ee33fb53151f2288534a6a5160f9038dc31800da1ffb53e541138fcc74119b5c14b4c6a4cf5f5fc6a7651975f9e53178481443a39f7b2d56c91d8f62dcfdf6b36fb9163dcb3e80a2979eb9ee245bde471115b3f2a947b42b0fa0b05b0a468db231e4f6f2d7e05ae82071319e2347de85670630767a661a7e9ff0ae397b3c049b228b83dab82a1984ae5564ced671a915be5695f65aefa9dc15a06df2a91aeff66beaf77adf8a4fa9a3b018b4ea9e3f7d127e7fd2481009149b20cefd9416ae8ca623595d2c75ba561e5936ee951e741390690dacdec8d8bd92ee01b735c3a7b64ea8c64ce0eb33746111acf0022556dbdcb16a8a29cb05479ec017fd22992eede49776207ea9861e38dc80512888468c0e34c7a25475745318a6e3c9716dbbb833dba32dcd92aa9976e71ba262786a201cabdcd3be01b9f6d7c49aa4c01924749fb1072505e62c262037d279e762093b999235edcf344a284b2c153f479e7a7352cc5133523aac82403f440130b8fdc27dc66a3476a4a63a247fa022cbc05af28d20d8344df9812dcef67c31e5a0449df6469f1b4b0449f3bd1c0dc967a5b146c92d6defb3209dce431b9ea8afdd19914c67cd549291df4522ed8eff73068385d2d80aa7d474cf8c5dd03f21375c47b7f88a5abe373f2999530f0e98633cdd07db5b2e58549c9580fe34052c388c0e32ed9fef02fc74197fa9fc3e35f09129faec41612a0f6e9cd8c21471b68911c66c324836291815ef5c50d2c274d85e7ec98dbd2dd410f28aef6fa59a30f7d9a5133cddc3077e9a4bda60b46c07156e0841447ed7525a0dd94633ec495e48246963bdc4e5873895ae67bc068e002c58ca11a66c1667f203065bbe29ddad1ad3d3685e265964af9f71df17819e2172b62ddbd0bf504bb0ad696f851ff6d4915ce9561fb08ead58802c0c775a136e30ac3a29089f99e8c744c9b2ac7902f80e14539c87175771b0e408536f078af2e4ff85c91cfde94e50b05739fcc70e2d8cd1be62eeb75b1680172cc483f3a56f465eef6ef46da07d92cb8511a0a24910d0023c3e689937bd693efccd887feae656f007faf819462517700c7e91ed32f3dbcd6e2c030c6fcbf11d34eb505e93b834a6e9609ffe9bbb6dcb050ebd3d7377d5ea939d Hey, password is required here.","link":"/2023/01/01/2022-summary/"},{"title":"D2终端技术大会 - 观后记录1","text":"听不懂，浪费我100米 = = Web Compass - 端内Web App解决方案揭秘 Web Compass - 端内Web App解决方案揭秘时间：2022.12.17 上午 9:15 - 9:55 背景：随着移动端App中Web业务的复杂化，多数场景也不再仅仅满足于单页级体验，如何能让这些Web业务的整体体验，能”批量级“提升到接近App级的体验水位？本次分享主要介绍如何基于传统Web技术进行体系化的体验增强，结合前端、客户端、Web容器、Web渲染引擎等多个角度进行核心技术方案的介绍，在了解整个Web App技术方案的的同时，也能让Web开发者了解到，基于传统Web也能以接近0成本的投入，打造出Web App级的体验。 议题亮点：1、了解Web技术及社区的现状和发展趋势。 2、了解如何借助客户端、容器、渲染引擎的能力，为Web所打造出通用技术方案。 3、了解U4内核所提供的一些创新技术。 4、了解传统Web业务如何基于该方案，就能低成本或者0改造就达到Android和iOS平台下一致的高性能体验。 5、了解该Web App技术方案的下一步规划，如何能更进一步演进。 议题QA 1、端内的Web App方案，需要依赖客户端的能力支持，如果要投放到不支持的客户端上，是不是就需要额外的适配？ 回答这个问题之前，先讲讲我们方案的整体思路：希望是在不对传统Web造成大影响的前提下，能够通过一些渐进增强的能力或者方案，来提升Web的整体体验，有增强能力则使用，无则忽略即可。 回到这个问题上，其实就是以前端的视角来看，我是不是需要实现多套方案，来兼容不同客户端。这个目前是不需要的，增强部分是额外的，支持则体验更好，不支持也不影响原页面的功能逻辑，并不需要做兜底方案的适配和兼容。 2、多页转场效果，纯前端方案也能实现不错的效果，为什么要选择Native混合的App模式？ 确实前端也能实现很不错的转场动画效果，而且社区也一直在探索更好的纯Web转场方案，但这里可能会有两个问题，目前纯Web方案是不太好解决的： （1）跨场景多团队的场景：对于Web App来说，不仅仅只有一个页面，而这些页面并不一定全是由一个团队来负责，因此纯Web实现的多页方案，并不能很好支持多团队或者多场景的整合。 （2）平台能力的不一致：移动端Android和iOS两个平台的WebView实际上还是有不少功能差异的，要实现一样的效果会有一定的成本，而App模式就能很好解决这个问题，而且也能更切合对应平台的App原生的动画效果。 3、这些是一套SDK，还是实现方案？ 目前我们内部是通过一套SDK进行多个客户端端复用的，未来会提供一个一站式的开发框架，让Web App的开发能更切合前端开发模式，但今天的分享更多的是整个方案和实现，对于我们做Web App，需要解决哪些体验问题，通过什么样的方案，才能让Web能有App级的体验，这个大家也可以参考这些思路去进行优化。 4、iOS是否也有字节码的能力，如果没有，使用上怎么做到双端一致？ 目前JS上的一些性能优化，仅限于U4内核提供，虽然iOS上是不支持的，但对开发者来说基本无感，因为无需关注是否支持，只管使用即可，由SDK来磨平这些功能差异，支持就会允许，不支持就会忽略。 5、预渲染对业务埋点数据的影响是怎么处理的？ 预渲染场景，现在增加了上屏事件及标准事件的管控机制，到真正用户消费该预渲染结果时，再进行通知，如果业务存在埋点数据问题，可以使用这些被管控的时机。 6、对比pwa或类小程序方案，具体从业务视角的体验数据指标对比有吗？ 目前并没有完全一致的，使用了这几套方案开发出来的同一个业务，那么，这样直接对比就不是非常客观了，毕竟不同的业务的复杂度不一样。 单纯从体验的角度来衡量的话，我们用得比较多的是首屏性能、滚动流畅度、帧率等等，比如首屏性能，从开始访问页面，到首屏内容完全展现完成，现在使用Web Compass方案，基本可以很容易做到1秒内，部分场景借助一些更激进的手段，比如预渲染，500毫秒内并不是问题。 这里想表达的是，纯Web也能做到非常好的体验（500毫秒的时间就已经达到闪开的效果了，基本看不到闪白的情况），成本也不高，而对于使用什么样的方案，更加多的应该是关注自己的业务诉求，什么样的方案适合自己的场景，而不是因为体验或者成本问题而进行妥协。 7、和前端的Hippy框架有什么具体的区别吗？ Hippy：更多是像Weex的方案，使用Native渲染来实现Web子集能力，前端使用的是Web子集能力。 Web Compass方案：使用Web渲染引擎，前端能使用全集的Web能力，而在这个基础上，通过融合客户端的一些能力，来对Web体验进行全方位的增强优化，这样相比传统的Web，开发不受限制，体验也达到更高水平。 8、这套东西是只能在夸克浏览器里面使用吗？ 目前在我们事业群的移动端应用里使用，比如夸克，UC等，后续成熟后会考虑对外开放。 9、资源预取是原生的还是内核的网络库实现的？ 使用我们自己优化的一套独立的网络库uNet，另外，我们也花了大力气去统一了不同技术栈的下的网络库能力，比如U4内核（Web）、Hummer（Flutter）都能进行网络的接管，统一接入到uNet当中，且性能没有损耗或者更优。 10、U4和普通Webview的区别是什么，为什么要做u4 U4内核是我们团队基于Chromium不断进行优化和创新的Web渲染引擎，从功能、稳定性、内存占用、性能、兼容性等各方面都比普通WebView更好。我们相信Web未来会是移动互联网最重要的技术之一，同时Web领域也需要探索者和突破者，我们团队也会在U4内核这个方向上，持续演进，为Web场景提供更多的优化和创新。 11、离线资源只有到了加载页面的时候才请求，首次性能是不是会比较差？ 这里可以分主文档请求和子资源（包含数据请求）来看： （1）对于主文档而言，开始访问时，到渲染引擎处理，再到发起真正的网络请求，实际耗时并不短，提前发起的预取，虽然可能并不能完全提前加载回来，但也能加载回来一部分并使用，或者能减少这段耗时，能尽可能并发起来； （2）对于子资源来说，提前发起的预取，实际大部分情况都能提前加载完成，毕竟需要等待主文档加载、解析、排版等操作。 因此，整体来看，首次性能只会有正向作用，不会更差，而且效果还是会比较好的那种。 观后感 随着移动互联网的不断发展，虽然Web网页级体验越来越好，但是业界不满足于此，逐渐往Web App方向发力，业界涌现很多优秀方案，如PWA。而面对优化成本高，能力差异多，体验有上限等各种挑战，有没有更好的方向和思路呢？ 今天D2终端技术大会，来自阿里巴巴高级无线开发专家赵鸿彬（齐誉）老师，带来了主题《Web Compass - 端内Web App解决方案揭秘》的分享，赵鸿彬大佬为我们展示了整个Web App解决方案的选择和探索，在统一的Web容器、资源服务、JS性能优化、高可用方向等Web Compass方案各个方面都讲解的非常广非常细，特别是中间JS性能优化覆盖非常全面。真正让我们全方位了解到，Web App在现在外部环境变好，技术加持的现状下，对未来Web App的优秀体验越来越有信心。 问题： WebView是啥？ Native混合是啥？ 预渲染是啥？ 上屏事件？ 原生应用，混合应用，Web应用举个例子？ （1）以手机App为例： 原生应用，酷狗音乐、美图秀秀，此类APP可称之为原生； web应用，通过UC浏览器打开抢票助手、充值易，这类就是web应用； 混合应用，天猫、携程、58同城这类APP，大多数是在原生的壳基础上包装了web页面，比如58同城的帖子、天猫的活动页面、携程的订单详情页面，都是内嵌网页的实现。 （2）以PC端为例： 原生应用，如QQ、迅雷网页应用，如曾经火极一时的页游混合应用，如360手机助手 原生应用？ 原生应用是采用特定操作系统的语言针对该操作系统开发的应用。 原生应用可以通过相关操作系统的专门平台（如苹果的App Store或安卓的Google Play Store）下载到智能手机或平板电脑上。 原生应用区别于网络应用和混合应用，通常被认为比后者更实用，对用户更友好。 混合应用？ Hybrid App（混合模式移动应用）是指介于web-app、native-app这两者之间的app，兼具“Native App良好用户交互体验的优势”和“Web App跨平台开发的优势”。混合应用程序最大程度地还原移动设备的用户体验，并且需要通过应用商店下载。因此，它们依然消耗存储空间。以标记语言，样式表，以及脚本语言制作的互动网页元素没有使用封闭的系统，例如Flash。一部分运行在移动浏览器的混合型应用没有URL，但支持丰富的用户界面，也允许使用一些操作系统层级的能力。 pwa是啥？ 渐进式网络应用程序（Progressive Web Apps，简称：PWA）是一种普通网页或网站架构起来的网络应用程序，但它可以以传统应用程序或原生移动应用程序形式展示给用户。这种应用程序形态视图将目前最为现代化的浏览器提供的功能与移动设备的体验优势相结合。 渐进式：用户无需担心使用哪个浏览器，也可以正常使用PWA。 响应式：PWA适应包括电脑，手机，平板等其他常用设备在内的多种浏览环境。 通过查询 Google 官方文档，PWA 应用是这样介绍的： [渐进式 Web](https://www.zhihu.com/search?q=渐进式 Web&amp;search_source=Entity&amp;hybrid_search_source=Entity&amp;hybrid_search_extra={“sourceType”%3A”answer”%2C”sourceId”%3A794173184}) 应用会在桌面和移动设备上提供可安装的、仿应用的体验，可直接通过 Web 进行构建和交付。它们是快速、可靠的 Web 应用。最重要的是，它们是适用于任何浏览器的 Web 应用。 反而在 Mozilla Web 开发网站（Firefox 浏览器的开发商）关于 PWA 的解释更简单明了： PWA（Progressive web apps，渐进式 Web 应用）运用现代的 Web API 以及传统的渐进式增强策略来创建跨平台 Web 应用程序。这些应用无处不在、功能丰富，使其具有与原生应用相同的用户体验优势。 PWA 和国内的小程序有什么不同 对于用户来说，PWA 应用最大的变化在于，改变了以往需要下载安装包、等待安装的过程，这类应用很好地体现了「用完即走」的理念，与传统安装应用相比，PWA 应用具备的优势是：无需安装、更轻量、不占用大量空间，只需要一款支持 PWA 应用的浏览器，就可以轻松添加 PWA 应用，具备了跨平台使用的特性。 而微信小程序这类应用，需要安装好微信本身这款应用的前提下，才能正常使用小程序，并且有些小程序会强制让用户关联微信帐号后方可使用应用。与其相比，PWA 应用在一定程度上展示更开放的一面，目前市面上大部分浏览器已经较好地支持 PWA 应用的标准，所以说在手机端或电脑端安装了浏览器，就能够轻松添加 PWA 应用。 Web 应用 VS 本地应用 首先，Web 应用缺少离线使用能力，在离线或者在弱网环境下基本上是无法使用的。而用户需要的是沉浸式的体验，在离线或者弱网环境下能够流畅地使用是用户对一个应用的基本要求。 其次，Web 应用还缺少了消息推送的能力，因为作为一个 App 厂商，需要有将消息送达到应用的能力。 最后，Web 应用缺少一级入口，也就是将 Web 应用安装到桌面，在需要的时候直接从桌面打开 Web 应用，而不是每次都需要通过浏览器来打开。 针对以上 Web 缺陷，PWA 提出了两种解决方案：通过引入 Service Worker 来试着解决离线存储和消息推送的问题，通过引入 manifest.json 来解决一级入口的问题。下面我们就来详细分析下 Service Worker 是如何工作的。 现在我们知道 Service Worker 的主要功能就是拦截请求和缓存资源，接下来我们就从 Web 应用的需求角度来看看 Service Worker 的设计思路。 1. 架构 我们知道 JavaScript 和页面渲染流水线的任务都是在页面主线程上执行的，如果一段 JavaScript 执行时间过久，那么就会阻塞主线程，使得渲染一帧的时间变长，从而让用户产生卡顿的感觉，这对用户来说体验是非常不好的。 为了避免 JavaScript 过多占用页面主线程时长的情况，浏览器实现了 Web Worker 的功能。Web Worker 的目的是让 JavaScript 能够运行在页面主线程之外，不过由于 Web Worker 中是没有当前页面的 DOM 环境的，所以在 Web Worker 中只能执行一些和 DOM 无关的 JavaScript 脚本，并通过 postMessage 方法将执行的结果返回给主线程。所以说在 Chrome 中， Web Worker 其实就是在渲染进程中开启的一个新线程，它的生命周期是和页面关联的。 “让其运行在主线程之外”就是 Service Worker 来自 Web Worker 的一个核心思想。不过 Web Worker 是临时的，每次 JavaScript 脚本执行完成之后都会退出，执行结果也不能保存下来，如果下次还有同样的操作，就还得重新来一遍。所以 Service Worker 需要在 Web Worker 的基础之上加上储存功能。 另外，由于 Service Worker 还需要会为多个页面提供服务，所以还不能把 Service Worker 和单个页面绑定起来。在目前的 Chrome 架构中，Service Worker 是运行在浏览器进程中的，因为浏览器进程生命周期是最长的，所以在浏览器的生命周期内，能够为所有的页面提供服务。 2. 消息推送 消息推送也是基于 Service Worker 来实现的。因为消息推送时，浏览器页面也许并没有启动，这时就需要 Service Worker 来接收服务器推送的消息，并将消息通过一定方式展示给用户。关于消息推送的细节就不详述了，感兴趣的话可以自行搜索相关资料去学习。 另外，PWA 还提供了 manifest.json 配置文件，可以让开发者自定义桌面的图标、显示名称、启动方式等信息，还可以设置启动画面、页面主题颜色等信息。关于 manifest.json 的配置还是比较简单的，详细使用教程网上有很多，这里就不做介绍了。 Hippy是啥？ Weex是啥？ Native渲染是啥？ U4是啥？ Chromium是啥？ DSL是啥？ 异常情况自动恢复？ 脑图 内容 好像就是在传统Web上开发一些SDK来实现能够使用传统Web技术去开发客户端。 整体架构 Web容器：双平台一致的增强能力 通用缓存架构 通用预取 性能优化 Ahead of Time 方案，就是加了个字节码缓存，以及提前生成语法树啥的 优化Bridge，省去UI线程 Web统一调试能力 Web App方案 2.0架构","link":"/2022/12/18/D2/"},{"title":"Graph-Database-Visualization","text":"技术栈：前端：Vue + Echarts + Element-UI 后端：SpringBoot + HugeGraph 项目介绍：本项目是我的本科毕设，背景是实验室与协和医院合作开发智能医疗项目，旨在提高就诊效率等。本人的工作是将存在图数据库里的医学数据通过可视化的方式呈现出来，方便病人查阅相关医学资料。主要工作： 1、利用Vue2+Echarts+Element-UI实现可视化界面 2、运用Springboot实现后端查询数据接口 3、运用拦截器和JWT实现特定请求的登录认证和鉴权； 4、利用ExceptionHandler统一处理异常，减少代码耦合度； 作品展示： 视频展示-1： 视频展示-2: 代码地址： https://github.com/Liny777/Visualization-vue-sample","link":"/2020/09/08/Graph-Database-Visualization/"},{"title":"Java Collection","text":"Java集合高频问题 😲😲😲 Java中的集合框架有哪些？ ArrayList和LinkedList的底层实现和区别？ 追问 说说ArrayList的扩容机制？ HashMap的底层实现？扩容？是否线程安全？ 追问 HashMap扩容的时候为什么是2的n次幂？ 追问 HashMap的put方法说一下。 追问 HashMap源码中在计算hash值的时候为什么要右移16位？ Java中线程安全的集合有哪些？ 追问 说一下ConcurrentHashMap的底层实现，它为什么是线程安全的？ HashMap和Hashtable的区别 HashMap和TreeMap的区别？ 1. Java中的集合框架有哪些？Java集合框架主要包括两种类型，一种是集合（Collection），存储一个元素集合，另一种是图（Map），存储键/值对映射。 Collection接口有3种子类型，List，Set和Queue，再下面是一些抽象类，最后是具体实现类。常用ArrayList，LinkedList，HashSet、LinkedHashSet、HashMap、TreeMap、LinkedHashMap等等。 2、ArrayList和LinkedList的底层实现和区别？ArrayList底层使用的是Object数组；LinkedList底层使用的是双向链表数据结构。 ArrayList：增删慢、查询快、线程不安全，对元素必须连续存储。 LinkedList：增删快，查询慢，线程不安全。 追问：说说ArrayList的扩容机制？通过阅读ArrayList的源码我们可以发现当以无参数构造方法创建ArrayList时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。当插入的元素个数大于当前容量时，就需要进行扩容了，ArrayList每次扩容之后容量都会变为原来的1.5倍左右。 追问：ArrayList有缩容吗？ArrayList没有缩容。无论是remove方法还是clear方法，它们都不会改变现有数组elementData的长度。但是它们都会把相应位置的元素设置为null，以便垃圾收集器回收掉不使用的元素，节省内存。 3、HashMap的底层实现？扩容？是否线程安全？jdk1.7之前，HashMap是基于数组和链表实现的，而且采用头插法。 jdk1.8之后，解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）（将链表转换成红黑树会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。采用尾插法。 HashMap默认的初始化大小为16。当HashMap中的元素个数之和大于负载因子*当前容量的时候就要进行扩充，容量变为原来的2倍。（这里注意不是数组的个数，而且数组中和链/树中的所有元素个数之和！） 注意：我们还可以在预知存储数据量的情况下，提前设置初始容量（初始容量 = 预知数据量 / 加载因子）。这样做的好处是可以减少resize（）操作，提高HashMap的效率。 HashMap是线程不安全的，其主要体现： 1、在jdk1.7中，在多线程环境下，扩容时会造成环形链或数据丢失。 2、在jdk1.8中，在多线程环境下，会发生数据覆盖的情况。 追问：HashMap扩容的时候为什么是2的n次幂？回答：数组下标的计算方法是 (n-1) &amp; hash ，取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与 (&amp;) 操作(也就是说hash%length==hash&amp;(length-1)的前提是length是2的n次方；)。并且采用二进制操作&amp;，相对于%能够提高运算效率，这就解释了HashMap的长度为什么是2的幂次方。 追问：HashMap的put方法说一下。通过阅读源码，可以从jdk1.7和1.8两个方面来回答 1、根据key通过哈希算法与运算得出数组下标 2、如果数组下标元素为空，则将key和value封装为Entry对象（JDK1.7是Entry对象，JDK1.8是Node对象）并放入该位置。 3、如果数组下标位置元素不为空，则要分情况。 （i）如果是在JDK1.7，则首先会判断是否需要扩容，如果要扩容就进行扩容，如果不需要扩容就生成Entry对象，并使用头插法添加到当前链表中。 （ii）如果是在JDK1.8中，则会先判断当前位置上的TreeNode类型，看是红黑树还是链表Node （a) 如果是红黑树TreeNode，则将key和value封装为一个红黑树节点并添加到红黑树中去，在这个过程中会判断红黑树中是否存在当前key，如果存在则更新value。 （b）如果此位置上的Node对象是链表节点，则将key和value封装为一个Node并通过尾插法插入到链表的最后位置去，因为是尾插法，所以需要遍历链表中，插入到链表后，会看当前链表的节点个数，如果大于8，则会将链表转为红黑树。 （c）将key和value封装为Node插入到链表或红黑树后，在判断是否需要扩容，如果需要扩容，就结束put方法。 追问：HashMap源码中在计算hash值的时候为什么要右移动16位？回答：我的理解是让元素在HashMap中更加均匀的分布，具体的可以看下图，下图是 某链的节点数x &lt; 8的时候，是链表形式 某链的节点数x &gt; 8的时候，如果数组长度小于64，那就扩容数组（初始是16，每次扩容*2）然后rehash 某链的节点数x &gt; 8的时候，如果数组长度大于64，就转变成红黑树。","link":"/2022/10/31/Java-Collection/"},{"title":"ModularJs","text":"Modular Javascript - Javascript Tutorial on the Object Literal PatternModular Javascript Cover how to build a basic module in javascript. 1、Object-LiteralThe simplest pattern for modular javascript is the object literal pattern - it adds all values and methods on a single object, thus encapsulating all of the module’s function into one object. The downside of this pattern, is it leaves all of the module’s data accessible. Clean it up into a self-encapsulated module that is easy to work with. Self - Encapsulated : 将一个对象封装起来 Efficient Dom Usage : 把需要操作的Dom元素进行缓存 - CacheDom function Render Method : 视频中是使用Mustache.render配合template进行渲染。 Bind Events : 给Dom元素一并添加点击事件，将每个事件独立地写在外面，bindEvent只负责绑定。 Delete Events : 记得写一个删除绑定，监听函数等的一个函数，避免内存泄漏。 12345678910111213141516171819202122232425262728293031323334353637383940var people = { people: ['Will', 'Steve'], init: function() { this.cacheDom(); this.bindEvents(); this.render(); }, cacheDom: function() { this.$el = $('#peopleModule'); this.$button = this.$el.find('button'); this.$input = this.$el.find('input'); this.$ul = this.$el.find('ul'); this.template = this.$el.find('#people-template').html(); }, bindEvents: function() { this.$button.on('click', this.addPerson.bind(this)); this.$ul.delegate('i.del', 'click', this.deletePerson.bind(this)); }, render: function() { var data = { people: this.people, }; this.$ul.html(Mustache.render(this.template, data)); }, addPerson: function() { this.people.push(this.$input.val()); this.render(); this.$input.val(''); }, deletePerson: function(event) { var $remove = $(event.target).closest('li'); var i = this.$ul.find('li').index($remove); this.people.splice(i, 1); this.render(); }};people.init(); 但是上面这种写法有个缺点，可以直接在浏览器控制台去调用API直接操控对象元素。我们不想用户能够调用render、cacheDom等函数，只希望他们能够调用addPerson和DeletePerson，因此我们在给上面对象封装一层，只暴露出安全的想给用户用的接口。 We write a revealing module pattern by starting with a self-executing anonymous function also known as an IIFE (immediately invoked function expression). This runs a function and sets it’s return value as our module’s value. If we return an object of methods, then those methods are what other modules have “public” access to. What’s nice about this, is we can create any variables within the function and no other modules have access to them unless we expose them via our return object. 方法：(function(){})() 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950var people = (function(){ var people = ['Will', 'Steve']; //cache DOM var $el = $('#peopleModule'); var $button = $el.find('button'); var $input = $el.find('input'); var $ul = $el.find('ul'); var template = $el.find('#people-template').html(); //bind events $button.on('click', addPerson); $ul.delegate('i.del', 'click', deletePerson); _render(); // 代表私有变量 function _render() { $ul.html(Mustache.render(template, {people: people})); } // Maybe String or index or other function addPerson(value) { var name = (typeof value === &quot;string&quot;) ? value : $input.val(); people.push(name); _render(); $input.val(''); } function deletePerson(event) { var i; if (typeof event === &quot;number&quot;) { i = event; } else { var $remove = $(event.target).closest('li'); i = $ul.find('li').index($remove); } people.splice(i, 1); _render(); } return { addPerson: addPerson, deletePerson: deletePerson };})();//people.addPerson(&quot;Jake&quot;);//people.deletePerson(0); 给私有方法或变量加下划线 What kind of cool is we can keep these internal methods whatever we want to call them here’s very common thing is if something is private if it’s internal you’ll see an underscore there so let me find every where render is called and give it an underscore.Unserscore usually means it is private where we’re storing this internally we’re never exposing. 2、Pub - Subwe’ll cover the pubsub design pattern (publish/subscribe), which allows us to decouple our modules. Once integrated with our pubsub module, they can emit events and not have to worry about which modules depend on them. Modules can subscribe to events and be notified when any module publishes. 事件的格式是 key:name(Listener) | value:[event1,event2,......] This loose coupling will allow the application to grow significantly larger without encountering problems. 下面是两个模块整合在一起，但是彼此互不依赖，却可以实现一个更新另一个也更新，这就是Vue双向绑定的底层原理，逻辑层与视图层实时更新。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899//events (publish subscribe) patternvar events = { events: {}, on: function (eventName, fn) { this.events[eventName] = this.events[eventName] || []; this.events[eventName].push(fn); }, off: function(eventName, fn) { if (this.events[eventName]) { for (var i = 0; i &lt; this.events[eventName].length; i++) { if (this.events[eventName][i] === fn) { this.events[eventName].splice(i, 1); break; } }; } }, emit: function (eventName, data) { if (this.events[eventName]) { this.events[eventName].forEach(function(fn) { fn(data); }); } } }; // Stats module (function(){ var people = 0; //cache DOM var $stats = $('#statsModule'); var template = $('#stats-template').html(); //bind events events.on('peopleChanged', setPeople); _render(); function _render() { $stats.html(Mustache.render(template, {people: people})); } function setPeople(newPeople) { people = newPeople; _render(); } function destroy(){ $stats.remove(); events.off('peopleChanged',setPeople) } return { destroy: destroy } })(); //people module (function(){ var people = ['Will', 'Steve']; //cache DOM var $el = $('#peopleModule'); var $button = $el.find('button'); var $input = $el.find('input'); var $ul = $el.find('ul'); var template = $el.find('#people-template').html(); //bind events $button.on('click', addPerson); $ul.delegate('i.del', 'click', deletePerson); _render(); function _render() { $ul.html(Mustache.render(template, {people: people})); events.emit(&quot;peopleChanged&quot;, people.length); } function addPerson(value) { var name = (typeof value === &quot;string&quot;) ? value : $input.val(); people.push(name); _render(); $input.val(''); } function deletePerson(event) { var i; if (typeof event === &quot;number&quot;) { i = event; } else { var $remove = $(event.target).closest('li'); i = $ul.find('li').index($remove); } people.splice(i, 1); _render(); } })(); 这里插播一下平时面试常考的发布订阅模式：实现思路 创建一个 EventEmitter 类 在该类上创建一个事件中心（Map） on 方法用来把函数 fn 都加到事件中心中（订阅者注册事件到调度中心） emit 方法取到 arguments 里第一个当做 event，根据 event 值去执行对应事件中心中的函数（发布者发布事件到调度中心，调度中心处理代码） off 方法可以根据 event 值取消订阅（取消订阅） once 方法只监听一次，调用完毕后删除缓存函数（订阅一次） 注册一个 newListener 用于监听新的事件订阅 12345678910111213141516171819202122232425262728293031323334353637class EventEmitter{ constructor(){ this._events = {}; } on(eventName, callback){ if(this._events[eventName]){ if(this.eventName !== &quot;newListener&quot;){ this.emit(&quot;newListener&quot;, eventName) } } const callbacks = this._events[eventName] || []; callbacks.push(callback); this._events[eventName] = callbacks } emit(eventName, ...args){ const callbacks = this._events[eventName] || []; callbacks.forEach(cb =&gt; cb(...args)) } // 其中once部分可以进行修改，是阿里二面的时候一位哥告诉我的, 传入callback时，传入一个匿名函数，然后里面分别先执行callback再调用off进行销毁～ once(eventName, callback){ const one = (...args)=&gt;{ callback(...args) this.off(eventName, one) } one.initialCallback = callback; this.on(eventName, one) } off(eventName, callback){ const callbacks = this._events[eventName] || [] const newCallbacks = callbacks.filter(fn =&gt; fn != callback &amp;&amp; fn.initialCallback != callback /* 用于once的取消订阅 */) this._events[eventName] = newCallbacks; }} 3、Prototypal Pattern vs Classical OOP in JS两种方法都可以实现继承，但是第二种会更简洁。 3.1 Classical OOPHere’s the link to the “inherit” function I use here: https://github.com/nodejs/node-v0.x-a... Using a constructor, a prototoype, and the “new” keyword, we can create multiple copies or “instances” of a module, each with unique properties, but shared functionality. We can also implement inheritance in Javascript. If we create a new module, we can inherit the functionality of a parent module with a simple inheritance helper function. 跟Java继承一个意思撒～ 有一个点注意一下： Friend.super_.call(this, name); 这里其实和Java抽象有点像，为了使得父子的共同属性保持一致变化，所以需要把name的this从子指向父。这样父亲name的变化，子的name也会跟着变化。（把共同属性的this指向父亲） 如果子类要拓展自己的方法，用如下写法： Musician.prototype.shoutName = function() { console.log(&quot;DUDE!!!&quot;) } 删除的时候，如下，使用delete API： delete Musician.prototype.shoutName 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586// /**// * Inherit the prototype methods from one constructor into another.// *// * The Function.prototype.inherits from lang.js rewritten as a standalone// * function (not on Function.prototype). NOTE: If this file is to be loaded// * during bootstrapping this function needs to be rewritten using some native// * functions as prototype setup using normal JavaScript does not work as// * expected during bootstrapping (see mirror.js in r114903).// *// * @param {function} ctor Constructor function which needs to inherit the// * prototype.// * @param {function} superCtor Constructor function to inherit prototype from.// */// exports.inherits = function(ctor, superCtor) {// ctor.super_ = superCtor;// ctor.prototype = Object.create(superCtor.prototype, {// constructor: {// value: ctor,// enumerable: false,// writable: true,// configurable: true// }// });// };// classical prototypalfunction inherites(ctor, superCtor) { ctor.super_ = superCtor; ctor.prototype = Object.create(superCtor.prototype, { constructor: { value: ctor, enumerable: false, writable: true, configurable: true } });};var Person = function(name) { this.name = name}Person.prototype.sayName = function() { console.log(this.name)}Person.prototype.shoutName = function() { console.log(this.name + '!')}var john = new Person();var bobby = new Person();var Friend = function(name) { // Person.call(this,name) Friend.super_.call(this, name); }inherities(Friend, Person);var julia = new Friend(&quot;julia&quot;);julia.sayName();var Musician = function(name, instrument) { Musician.super_.call(this, name); this.instrument = instrument;}Musician.prototype.shoutName = function() { console.log(&quot;DUDE!!!&quot;)}inherites(Musician, Person);Musician.prototype.getInstrument = function() { console.log(this.instrument);}var Jason = new Musician(&quot;Jason&quot;, &quot;trombone&quot;)delete Musician.prototype.shoutName/** * The delete operator in JavaScript is used to delete an object's property. * If it is used to delete an object property that already exists, * it returns true and removes the property from the object. * However, deleting an object property that doesn't exist will not affect the object, but will still return true . */ 3.2 Prototypal PatternWhile many JS devs still use classical OOP, many have switched to the prototypal pattern for Module Inheritance and Instantiation. Here’s the prototypal pattern for JS and why some devs find it simpler to use. Basically, when coding JS OOP with the prototypal pattern, everything is an object. You start with an object literal and, then, to inherit from it, you use Object.create(someModule) to create a child that inherits from it. var parent = {some: method}; var child = Object.create(parent); //now add new methods to the child child.newMethod = someMethod; So there’s really no difference between inheritance and instantiation in the prototypal method. To create multiple children, simply: var child1 = Object.create(parent); var child2 = Object.create(parent); And there you have it! Also see the source javascript code on how to include a create method so creating is a little more seamless. 123456789101112131415161718192021222324252627282930313233343536373839// classical prototypal/*** * Define : * Object.create() method is used to create a new object with the specified prototype object and prototypes. * Object.create() method returns a new object with the specified prototype object and properties. * Application : * Object.create() is used for implementing inheritance. */var human = { species: &quot;human&quot;, // Rewrite Object.create function create: function(values) { var instance = Object.create(this); Object.keys(values).forEach(function(keys) { instance[keys] = values[keys]; }); return instance; }, saySpecies: function() { console.log(this.species); }, sayName: function() { console.log(this.name); }};var musician = Object.create(human); // inherited humanmusician.playInstrument = function() { console.log(&quot;plays...&quot; + this.instrument);}var will = Object.create(musician); // inherited musician - &gt; human will.name = &quot;Will&quot;;will.instrument = &quot;Drums&quot;;var musician2 = human.create({ species: &quot;musician&quot;, playInstrument: function() { console.log(&quot;plays&quot;+this.instrument); }}) 其他[1]: https://www.youtube.com/c/learncodeacademy “Youtuber Learncode.academy”[2]: https://juejin.cn/post/6844904101331877895 “从发布订阅模式入手读懂Node.js的EventEmitter源码”[3]: https://juejin.cn/post/6985156199192723487 “手写一个基于发布订阅模式的js事件处理中心(EventEmitter)” [4]: https://www.youtube.com/playlist?list=PLoYCgNOIyGABs-wDaaxChu82q_xQgUb4f “Modular Javascript”","link":"/2022/10/10/ModularJs/"},{"title":"Monitor-SDK","text":"本项目主要是实现一个前端监控系统，使用者将本项目开发的埋点代码放置在需要被监控的前端项目中，用户的行为数据会被记录，使用者可以通过一个中台页面监控项目情况。 一、项目介绍Root：一个轻量、快速的全栈前端监控系统。 项目地址 1 项目地址 2 Github 地址： 前端 后端 埋点 测试应用 二、项目分工 团队成员 主要贡献 郑琬仪 异常概览、总概览和其他页面和接口、页面异常捕获sdk、项目进度与其他事项 林佑光 用户细查及总概览页面、相关前后端接口、用户行为捕获sdk 田雨沛 用户详情页面、相关前后端接口、Flask后端框架搭建、项目自动化构建部署、辅助组员完成代码 熊恺杰 异常详情页面、相关前后端接口、MongoDB数据库搭建、sdk打包、辅助组员完成代码 熊康伟 性能页面、相关前后端接口、页面性能sdk 龚恒 异常详情页面、相关前后端接口、HTTP请求监控sdk及打包 三、项目实现3.1 技术选型与相关开发文档 可以补充场景分析环节，明确要解决的问题和前提假设，比如按当前选型和架构总体预计需要xxx存储空间，xxx台服务器……。 本项目主要是实现一个前端监控系统，使用者将本项目开发的埋点代码放置在需要被监控的前端项目中，用户的行为数据会被记录，使用者可以通过一个中台页面监控项目情况。 3.1.1 前端技术选型：Vue3 + Vite + TypeScript + Arco Design 3.1.2 后端Flask + MongoDB 3.1.3 监控SDKWebpack 3.1.4 其他 为提升代码的可读性和可维护性，我们在前端监控系统仓库中使用 TS + ESLint 来规范成员的代码风格；为方便统计成员每次提交的内容，使用 commitlint 来规范仓库的提交信息。 网站监控系统项目中，使用 flask+mongodb 搭建数据服务器并模拟数据；在监控SDK项目中，通过设置 webpack 的请求中间件来实现虚拟服务器。 3.2 架构设计 可以补充场景分析环节，明确要解决的问题和前提假设，比如预计0.5%的用户属于大V，粉丝很多，也会经常上传视频，当前架构的解决方案是xxx。 为了使多人协同的项目进行部署时快捷高效，我们加入了自动化部署脚本 为了在有限的时间内快速开发具有良好交互特性和较美观的 UI 的网页，我们选择了字节的Arco Design组件库 为了良好的项目和组件结构，我们根据不同需求建立文件夹（概览、异常、用户、性能）内有index.vue 以及组件文件夹以存储组件，前端架构耦合度较低，便于查找和管理 3.2.1 数据库设计 3.3 项目代码介绍 前端监控系统： 123456789101112131415161718192021222324252627282930313233343536web-monitor-dashboard├─.husky├─config└─src ├─api // api接口 ├─assets // 静态资源 ├─components // 通用组件 ├─config // 项目配置 ├─directive // 自定义指令库 ├─hooks // 前端工具 ├─layout // 基础布局 ├─locale // 中英文编码 ├─mock // 数据mock ├─router // 路由文件 │ ├─appMenus │ ├─guard │ └─routes │ └─modules // 各个页面的router ├─store // 数据存储 ├─types // 数据类型定义 ├─utils // 数据类工具 └─views ├─error // 错误页面 │ ├─issue-details // 错误详情页面 │ └─issues // 错误概览页面 ├─login // 登入页面 ├─not-found // not-found 页面 ├─overview // 概览页面 │ ├─components │ └─locale ├─performance // 性能页面 │ ├─api // api性能及详情页面 │ └─page // 页面性能及详情页面 ├─user // 用户详情页面 ├─useraction // 用户细查页面 └─userinfo 后端： 123456789101112131415161718web-monitor-backend│ requirements.txt└─api │ __init__.py ├─mock │ data_generator.py │ mock_data_forger.py ├─model // 数据表定义 │ models.py ├─route │ api.py // 其他相关接口 │ errors.py // 错误相关后端接口 │ performance.py // 性能相关后端接口 │ user.py // 用户相关后端接口 │ mock_api.py └─util data_process.py utils.py 监控系统SDK： 12345678monitorSDK └─lib blankError.js // 白屏异常 jsError.js // 脚本异常 promiseError.js // Promise 脚本异常 resource.js // 资源加载异常 stayTime.js // 监控用户行为 xhr.js // 监控request 四、测试结果 建议从功能测试和性能测试两部分分析，其中功能测试补充测试用例，性能测试补充性能分析报告、可优化点等内容。 功能测试： 用户登录、路由切换 概览页面：流量数据、用户量统计、访客量趋势、页面浏览量趋势、用户平均停留时长、异常数据总览加载 用户细查页面：用户列表显示、根据用户编号查询功能 用户详情页面：用户相关信息显示 错误概览页面：异常数据图标显示、异常数据列表及根据异常类型即网页查询功能 页面性能页面：FP、FCP、DOM Ready、DNS渲染和页面列表 接口性能页面：平均请求概览、总请求量、接口列表 自适应测试 五、Demo 演示视频 六、项目总结与反思 目前仍存在的问题 数据加载速度较慢 由于对 typescript 使用上的不熟悉，类型声明考虑不周；因人力和时间关系，已完成的通用可配置组件较少 缺少强制代码评审，再加上不同成员对代码熟练程度和风格不一致，导致页面的代码结构差异较大，代码质量可以改善。 已识别出的优化项 针对服务器性能较弱的问题，应该定时整理日志的统计信息，在请求时直接返回，而不是每次都遍历全部日志进行统计。 项目的前端页面结构和功能不够完善，其中包括：缺乏切换监控不同项目、图表中可以选择更多不同的时间维度 数据结构设计存在改进空间，性能页面需要从多个表中获取不同的数据 架构演进的可能性 项目过程中的反思与总结 大部分同学对ts、python、github操作不是很熟悉 直接使用Arco Design Pro的代码为框架，但由于对代码的框架不是很熟悉导致出现问题 后期没有实时跟踪成员的进度，导致不能在成员出现代码困难第一时间发现 总结：经过这次项目，对前端监控的认识加深了很多，同时也进一步需要根据不同组员的能力进行良好和清晰的分工的重要性，尽管我们在很早就开始大项目，但是由于并没有很好组织代码提交进度，也面对了很多问题。无论如何，在大家的共同努力下依然完成了这次的大项目，辛苦大家了！ 没有进行批量上传 传输加密 sourceMap上传 sendBean上传请求 页面关闭的pv uv统计问题 七、其他补充资料（选填）我的部分：用户行为PV：用户浏览量 UV：独立访客数 用户停留时长：用户在页面的停留时长 获取方法： 通过监听事件，获取用户跳转页面的行为，然后将跳转页面，用户停留时间等参数发给后端，这个时候已经获取到页面停留时间，同时可以获取pv，因为我们这里简化一下，浏览量只包括浏览页面的话，那每跳转一个页面就是一个浏览量，pv就+1，然后uv就只要对当天的统计的pv采集到的userid进行去重就可以拿到，或者直接到数据库里进行获取就好。 监听页面跳转方法：主要分为两种情况，单页面与多页面应用 单页面SPA：分为Hash模式，History模式 Hash：基于浏览器的hashchange事件，地址变化时，通过window.location.hash 获取地址上的hash值；并通过构造Router类，配置routes对象设置hash值与对应的组件内容。 History：基于HTML5新增的pushState()和replaceState()两个api，以及浏览器的popstate事件，地址变化时，通过window.location.pathname找到对应的组件。并通过构造Router类，配置routes对象设置pathname值与对应的组件内容 多页面MPA： 主要基于**onpageshow(页面显示的时候)和onpagehide(页面隐藏的时候)这两个API获取用户停留的时长。只要在onpageshow初始时间值，在onpagehide**的时间求出差值，然后上传到后台就行。但是目前没有考虑用户直接关闭浏览器的情况。 登录获取用户信息： 在安装SDK时，会先判断**localStorage里是否有用户ID，如果没有，会将请求页面发送给后端，然后后端获取用户的操作系统，设备信息以及IP信息后创建一个新用户并将新用户的ID返回给前端，前端获取到用户ID后将其存放于localStorage中。如果一开始就有用户ID，就直接从localStorage** 中获取。 需求自动收集、上报、存储页面关键数据，并提供监控数据可视化查询界面，要求覆盖Web页面关键运行数据，包括： 异常监控，包括：JS异常、接口异常、白屏异常、资源异常等 关键性能数据监控，如：FP、FCP、DOM Ready、DNS等 用户行为数据，如：PV、UV、页面停留时间等 HTTP请求监控、包括：请求链路、成功率、返回信息等 视图要求 PV/UV 趋势图 各性能数据走势图 异常数据&amp;归因分析展示 参考 https://help.aliyun.com/document_detail/58652.html https://sentry.io/welcome/ https://github.com/getsentry/sentry http://www.webfunny.cn/demo/home.html https://github.com/a597873885/webfunny_monitor.git","link":"/2022/09/01/Monitor-SDK/"},{"title":"New-Energy-Car","text":"作品展示： 项目介绍：此项目为清华大学车辆与运载学院新能源汽车测试组参与的国家重点研发计划科技冬奥重点专项“氢能出行”。本人的工作是负责构建信息监控大数据平台，实时展示新能源汽车的数据信息。 主要工作： 1、使用Vue2框架搭配Echarts与百度地图通过点聚合方式显示78辆氢能源汽车的数据 2、使用Flex与Grid布局 3、使用Webpack打包与部署前端应用","link":"/2021/09/08/New-Energy-Car/"},{"title":"Npm详解","text":"待写","link":"/2022/12/08/Npm/"},{"title":"JS 对象、类与面向对象编程","text":"","link":"/2022/12/09/PrototypeAndClass/"},{"title":"React学习","text":"入门教程: 认识 React，（还没完成） 为什么不可变性在React中非常中重要一般来说，有两种改变数据的方式。第一种方式是直接修改变量的值，第二种方式是使用新的一份数据替换旧数据。一般都采用第二种方式。不直接修改（或改变底层数据）这种方式和前一种方式的结果是一样的，但这种方式优点有以下几种：1、时间旅行功能：方便实现撤销和恢复功能的开发。2、跟踪数据的变化3、确定在React中何时重新渲染 1234567891011handleClick(i) { const squares = this.state.squares.slice(); // 调用slice函数对squares数组进行拷贝，而非直接修改现有的数组 squares[i] = 'X' this.setState({squares: squares}); } 注意 在Javascript class中，每次你定义其子类的构造函数时，都需要调用super方法。因此，在所有构造函数的React组件中，构造函数必须以super（props）开头 123constructor(props) { super(props);} 函数组件如果你想写的组件只包含一个render方法，并且不包含state，那么使用函数组件就会更简单。我们不需要定义一个继承于React.Component的类，我们可以定义一个函数，这个函数接受props作为参数，然后返回需要渲染的元素。函数组件写起来并不像class组件那么繁琐，很多组件都可以使用函数组件来写。 注意 concat（）方法与push（）不一样，不会改变原数组，所以推荐使用concat（） 选择一个key 当我们需要渲染一个列表的时候，React会存储这个列表每一项的相关信息。当我们要更新这个列表时，React需要确定哪些项发生了改变。我们有可能增加，删除，重新排序或者更新列表项。强烈推荐，每次只要你构建动态列表的时候，都要指定一个合适的key。 函数组件传参 1、函数传参：当我们把Square修改成函数组件时，我们同时也得把onClick={() =&gt; this.props.onClick()}改成了更短的onClick={proprs.onClick}（注意两侧都没有括号） 2、类传参：此处使用了onClick = {() =&gt; console.log(‘click’)}的方式向onClick这个prop传入一个函数。React将在单击时调用此函数。但很多人经常忘记编写() =&gt;, 而写成了onClick={console.log(‘click’)}, 这种常见的错误会导致每次这个组件渲染的时候都会触发控制台输出。 状态提升 当你遇到需要同时获取多个子组件数据，或者两个组件之间需要相互通讯的情况时，需要把子组件的state数据提升至其共同的父组件当中保存。之后父组件可以通过props将状态数据传递到子组件当中。这样应用当中所有组件的状态数据就能够方便地同步共享了。","link":"/2022/12/24/React-demo/"},{"title":"Reading-English","text":"文章主要包括细节题，推断题，主旨题，态度题，词义猜测题。 细节题题型概述 第一类 窄 仅涉及原文中一个或几个句子。对于此类题，根据关键词或信息在原文精确定位，将定位内容与原文信息未做曲解的同义表述即为正确答案。找1对4。 第二类 广 对文章某一段或数段甚至全文进行提问。常见考法，四个选一个正确/错误，或同意以下任意一项。这类题一般每个选项均有各自关键词，根据关键词在原文进行定位，寻找相关信息，对比选项和原文，排除干扰项。相当于 找4对4。 细节题常用提问方式：Which of the following is NOT true ? Which of the following is NOT mentioned ? The main reason for … is … According to the author … 解题思路 （1）定位。两种方法。 一是关键词定位，可以从专有名词（人名，地名）、时间、数字、修饰词，如果没有关键词，可以按照名词、动词、形容词的顺序选定关键词。 ​ 二是顺序法。大部分题目的题目顺序与文章顺序基本一致。（2）对比文章和选项。 ​ 即根据题干，找到与原文信息对应的正确选项。 正确项和干扰项的特征正确项是原文的同义转述或改写，即对原文的重新加工，用不同的词语或句型表达相同的意思。 干扰项具有以下特征： （1）偷换概念：提到原文内容，还包含与原文不相符的。（一半一半） （2）答非所问：虽是原文信息，但不符合题目要求。（马嘴不对牛头） （3）以偏概全：扩大适用范围，即将原文中只适用于部分的情况变成适用于全部。（局部代替整体） （4）无中生有：选项中出现了原文没有提到或推导不出的信息。（压根就没这东西） （5）正反混淆：选项与原文相反。（颠倒是非） （6）过于绝对：选项中出现了表现绝对意义的词语，only,never,all,everything,nobody等。 （7）逻辑颠倒：看似原文推断出来的结论，实际上与原文不符，例如选项中涉及的因果关系与原文所说的因果关系正好相反。 推断题题型概述 占比重较大 考察考生推测作者字里行间言外之意。要求对文章深层推理和理解。 推断题常用的提问方式：What is implied by the guidelines ? What can be inferred from the information ? What can be inferred from the information ? What will probably happen when … 解题思路 （1）以原文为基础，但不拘泥于文章字面意思，要根据已知信息推导未知信息。 （2）弄清上下文逻辑，从文意和逻辑推理。 （3）注意间接表达的句子，这些句子常采用比喻、反语方式，其背后通常蕴藏着需要探索的意义。 （4）注意结构复杂或语义深刻的句子，这些句子需要谨慎对待，读出弦外之意。 正确项和干扰项的特征 正确项 （1）大多含义深刻，更具综合性和概括性。 （2）有时会与通过常识得出结论相反。 （3）正确项一般不会使用绝对词语，而是非绝对，比如often,usually,sometimes,some,may,might,can,could,possibly,probably等。 干扰项 （1）只是原文简单复述，而非推断的结论。 （2）虽然符合常识，但不是基于原文。（同正确的2） （3）推理过度，概括过度。 （4）看似由原文推断，实际与原文不符。 （5）过于绝对。（同正确3) （6）由文中信息杂糅而成，非原文真实意思的表达。 主旨题题型概述考查考生综合、概括、归纳和分析能力。题干标志词main idea, subject, the best title, topic, purpose, summay等。该题型可细分为段落主旨题和全文主旨题。在银行招聘考试中，常考的为全文主旨题。 针对某一段或几段的主题进行提问。常用的提问方式有： 段落主旨题 全文主旨题 In the first paragraph/Paragraph X, the author discusses …We learn from Paragraph X that …Which of the following is true according to Paragraph X ? What would be the best title for this passage ?What is the passage mainly about ?What is the main idea of the article ?The main purpose of the passage is to …Which of the following is this passage mainly about ?Which of the statements can best reflect the main idea of this passage ? 解题技巧对于主旨题，考生在阅读文章时要特别留意以下几处： （1）文章的首段和尾段，通常为文章主旨出现最频繁之处。（2）每段的首句和尾句，通常是段落主旨出现的地方。 （3）文章或段落中出现转折的地方，转折所在句往往揭示了作者真实的写作目的或基本观点，即文章的中心思想所在。 （4）作者有意识地反反复复的观点通常是文章主旨。反复提到的词，一般是体现中心思想的核心词。 （5）如果文章中没有明确的主旨句，考生可通过归纳各段的主要内容，进而确定文章主题。 正确项和干扰项的特征 正确项 干扰项 （1）较全面、有针对性地表达文章或段落的中心思想。（2）若文章或段落含有明确的中心句，则与之意思相近的为正确项。（3）常包含文中反复出现的主题词、关键词或抽象意义的词语。 （1）以偏概全，只涉及文章某一细节，非文章或段落中心意思。（2）当问及全文主旨时，选项只是某一段落的大意。（3）概括范围太过宽泛，超出了文章阐述的范围，或者与文章内容无关。 态度题题型概述考查作者或文章中所涉及人物对于文章的主题或涉及的某一现、问题所表现出来的态度。态度题干中通常会出现attitude、opinion、tone等标志词 常见的提问方式有以下几种： What is the author’s attitude towards … ? How would you describe … attitude towards … ? What is the tone(mood) of the passage ? The author’s attitude towards … seems to be … Which of the following best describes the author’s attitude towards … 解题策略 （1）不要将自己的态度掺杂其中，同时还要注意区分作者本人态度和作者引用观点的态度。 （2）作者态度一般与文章主旨相关联，支持某一事物与否应视其与主旨的一致程度而定。作者态度基本不会是漠不关心，所以indifferent, uninterested, impassive, unconcerned等词一般不是正确选项. （3）当作者的态度没有明确显露时，考生要学会根据作者语言的褒贬去判断作者的态度，通过阅读全文来把握文章的主旨和感情基调 （等于没说～） （4）表示“客观“的词多为正确选项，如objective, impartial, unbiased，unprejudiced等。在阅读中，明白作者的语气，观点，态度，立场以及其他人物观点之间的关系，可以帮助考生准确理解文章的主旨。这些观点、态度有的很直白地表现出来，有的则隐藏在字里行间，需要通过阅读全文，把握主旨来判断。 正确项和干扰项的特征干扰项： （1）望文生义，拘泥于表面意思，非原文真实意图的表达。 （2）将其他人物态度错置于作者身上。 （3）无中生有，编造事实或曲解原文。 积极 informative : 有教益的 promising ：有希望的 persuasive：有说服力的 消极 Adverse : 不利的 subjective : 主观的 ironic：讽刺的 客观 disinterested : 公正的，无私的 中立，不关心 impassive 冷漠 uninterested 冷淡 词义猜测题题型概述考查考生根据上下文推断单词或短语意思的能力。所考查词汇一般有两种情况：一是超纲词；二是熟词生义。 解题技巧 对于完全陌生单词 （1）通过语境猜。通过上下文和文章主题的逻辑关系。从对两种事物或现象对比描述中，推断出词义。 （2）根据定义猜测词义。定义：用一个句子或者段落给生词定义；使用破折号、冒号后面的内容或者引号、括号中的内容对生词加以解释或者定义。（前提得有给） （3）通过经验及生活常识猜测词义。在阅读文章的基础上利用自己对日常生活的理解和判断对单词含义进行猜测。 对于熟悉单词 （1）代入检验法：如果选项中的单词都认识，可以分别代入原文，检查一下是否符合逻辑。 （2）词汇关系法：查看是否有特定的搭配或者逻辑关系。 （3）句子关系：根据语法结构和句子逻辑关系判断文章中句子关系是顺接还是逆接，话题和感情色彩是相同还是相反。 注意语法，句子结构，标点符号，文字描述等。 错题反思注意高频词，主旨题选项，出现的高频词如果与文中的不一样，比如IQ Scores，选项是IQ Test就可以先排除，。 细节题有一些选项是要推测的，并且答案可能在后面，不要用近义词代替，比如文中是healthier eating，选项是nutrition, 所以不能选，不能把营养和健康饮食等同起来 = =","link":"/2020/10/11/Reading-English/"},{"title":"Reminder","text":"f4cc23558ba95030556638b09840cfb7c89f80cc2d775127ff51e6f9d8b812afe4c13d30b45aace59541ae61c00c9b6ba99f4b4aef900d5f518413938e220fd047229287db204c4ece61bb1e411f53d10e34a3a427b5831d4cb659dec9fb2327368e7f1535383abaefea0c2c6e1015c2716439fa247a9d94ebe7fd28a308d919f4703da2c89eb14a99352430028ff2e264447b5b42f5394e481c984ba8ed079d0b585f264e3e61a39fed3ba6d32187a2c0266c7c5923296e91bc0b3b622729eb07547b67d54138444703bc12b423a24b707182d9c1ce7acc8a0985522d59cc4aab1f01e1c8a71b198d64169446ec132b957ddf8c8895dceb18b9cec6f320e458ce10167846c522acff4abdac33927d17b08c0ed0f9af014a40a70353c32d0633e1297846052f44fb219f142f8fdc509a3e7f06d601da4147253be5fd240ac1d7eeeb6759fd53e29e81a1c38066ca33bf1100acae9ab071a0c9683d39d045638784fffcef8a8bf8d0e7d20f630be4ae133791357ae1ab1e4b3d274d76c0fce14c8751156272dd93126827edb5086dc640f01fad70907f994e175bc66ea4527cd369318cb28fa14a933c2998fff79da7b7 密码输入框上描述性内容","link":"/2020/10/11/Reminder/"},{"title":"Java Basics","text":"Java基础知识高频问题 😲😲😲 Java语言的三大特性是什么？ 重载与重写的区别? 接口和抽象类的区别是什么？ Java中的内部类说一下? 说一下final关键字的作用? 说一下String，StringBuilder和StringBuffer的区别? 说一下Java中的==与eaquels的区别? Java访问修饰符有哪些？都有什么区别？ 追问 怎么获取private修饰的变量 .Java中的异常体系说一下？ 追问 异常的处理方式？ .Java中的深拷贝和浅拷贝说一下？ 追问 浅拷贝与深拷贝的特点是什么？ 1. 面向对象三大特征 封装封装是指将对象的属性私有化，提供一些可以访问属性的方法，我们可以通过访问这些方法得到对象的属性。 继承继承是指某新类继承已经存在的类，该新类拥有被继承的类的所有属性和方法，并且新类可以根据自己的情况拓展属性或方法。其中新类被称为子类，原存在的类被称为父类。1、子类拥有父亲类对象所有的属性和方法（包括私有属性和私有方法），但是父类中私有属性和方法子类是无法访问，只是拥有。2、子类可以拥有自己属性和方法，即子类可以对父类进行拓展。3、子类可以用自己的方式实现父类的方法。 子类不能直接访问父类的私有属性，子类只能在父类中写一个public的getXXX的方法来获取父类中的private属性，子类就调用父类的getXXX来获取private属性 在子类的构造方法中通过super()方法调用父类的构造方法来继承到父类的私有域。 构造子类的同时，为子类构造出跟父类相同的域。如此就在子类的对象中，也拥有了父类声明的域了 多态多态是同一个行为具有多个不同表现形式或形态的能力。多态就是同一个接口，使用不同的实例而执行不同操作。 多态是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。【摘自JavaGuide】 在 Java 中有两种形式可以实现多态：继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。 总结封装：封装起来，只提供访问接口 继承：新继承已有的，然后根据自己情况拓展 多态：同一个行为不同表现形式（比如飞，各种飞行姿势等）- 接口 和 继承来实现 2. 重载和重写 重载：重载是发生在同一个类中，具有相同的方法名，但是有不同的参数，参数的个数不一样、参数的位置不一样、这叫做重载，常见的就比如构造方法，有参构造和无参构造。 重写：发生在当子类继承父类时，对父类中的一些方法根据自己的需求进行重写操作。 父类方法被默认修饰时，只能在同一包中，被其子类被重写，如果不在同一包则不能重写。 父类的方法被protoeted时，不仅在同一包中，被其子类被重写，还可以不同包的子类重写。 重写方法的规则：1）、参数列表必须完全与被重写的方法相同，否则不能称其为重写而是重载。 2）、返回的类型必须一直与被重写的方法的返回类型相同，否则不能称其为重写而是重载。 3）、访问修饰符的限制一定要大于被重写方法的访问修饰符（public&gt;protected&gt;default&gt;private） 4）、重写方法一定不能抛出新的检查异常或者比被重写方法申明更加宽泛的检查型异常。例如：父类的一个方法申明了一个检查异常IOException，在重写这个方法是就不能抛出Exception,只能抛出IOException的子类异常，可以抛出非检查异常。 重载的规则：1）、必须具有不同的参数列表； 2）、可以有不同的返回类型，只要参数列表不同就可以了； 3）、可以有不同的访问修饰符； 4）、可以抛出不同的异常； 总结：重写：只有内容和权限可以不一样，其他必须一样 重载：函数名字一样，其他都可以不一样 3. 抽象类和接口的区别 接口（Interface）和抽象类（Abstract class）是支持抽象类定义的两种机制。抽象是对类的抽象。 接口是公开的，不能有私有的方法或变量，接口中的所有方法都没有方法体，通过关键字interface实现。接口是对行为的抽象。抽象类是一种模版，接口是一种行为规范。 抽象类是可以有私有方法或私有变量的，通过把类或者类中的方法声明为abstract来表示一个类是抽象类，被声明为抽象的方法不能包含方法体。子类实现方法必须含有相同的或者更低的访问级别（public-&gt;protected-&gt;private)。抽象类的子类为父类中所有抽象方法的具体实现，否则也是抽象类。特点： 被abstract修饰，没有方法体的方法称为抽象方法； 抽象方法必须存在于抽象类中，不能存在于非抽象类； 抽象方法必须在其子类中实现，除非子类也是抽象类； 如果一个类中含有抽象方法，该类一定是抽象类，该类必须被abstract修饰； 如果一个类是抽象类，该类可以含有抽象方法和非抽象方法 如果一个类为抽象类，则该类不能被实例化，必须通过该类的非抽象子类进行实例化 相同点：（1）：都不能被实例化（2）：接口的实现类或抽象类的子类都只有实现了接口或抽象类中的方法后才能实例化。 不同点： （1）：接口只有定义，不能有方法的实现，但java1.8中可以定义default方法体，而抽象类可以有定义与实现，方法可在抽象类中实现。（2）：实现接口的关键字为implements，继承抽象类的关键字为extends。一个类可以实现多个接口，但一个类只能继承一个抽象类。所以，使用接口可以间接地实现多重继承。（3）：接口强调特定功能的实现，而抽象类强调所属关系。（4）：接口方法默认修饰符是public，抽象方法可以有public、protected和default这些修饰符（抽象方法就是为了被重写所以不能使用private关键字修饰！）（5）：接口被用于常用的功能，便于日后维护和添加删除，而抽象类更倾向于充当公共类的角色，不适用于日后重新对立面的代码修改。从设计层面来说，抽象是对类的抽象，是一种设计模版，而接口是对行为的抽象，是一种行为的规范。 总结：接口：行为约束，只约束行为类别，不约束行为内容，implements，没有构造方法，一个类实现多个接口 抽象：代码复用，extends，有构造方法，一个类继承一个抽象 同：都不能实例化，不能private 4. Final修饰类、方法、字段分别起到的作用？ 总结：类：不能被继承，成员方法被隐式地指定为final方法。方法：不能被重写 字段 常量：不能修改 变量/引用型：不能指向其他人 5. String VS StringBuffer VS StringBuilder 总结String：不可变，原理final，private final char value[]，操作少量 StringBuffer：可变，继承自AbstractStringBuilder，加了同步锁，唯一一个线程安全，多线程选择他 StringBuilder：可变，继承自AbstractStringBuilder，单线程， 6. 说一下Java中的==与eaquels的区别 ==对于基本类型和引用类型 == 的作用效果是不同的，如下所示： 基本类型：比较的是值是否相同； 引用类型：比较的是引用是否相同； 1、比较的是操作符两端的操作数是否是同一个对象。 2、两边的操作数必须是同一类型的（可以是父子类之间）才能编译通过。 3、比较的是地址，如果是具体的阿拉伯数字的比较，值相等则为true，如： int a=10 与 long b=10L 与 double c=10.0都是相同的（为true），因为他们都指向地址为10的堆。 1234567String x = &quot;string&quot;;String y = &quot;string&quot;;String z = new String(&quot;string&quot;);System.out.println(x==y); // trueSystem.out.println(x==z); // falseSystem.out.println(x.equals(y)); // trueSystem.out.println(x.equals(z)); // true equalsequals 本质上就是 ==，只不过 String 和 Integer 等重写了 equals 方法，把它变成了值比较。 首先来看默认情况下 equals 比较一个有相同值的对象，代码如下： 12345678910111213141516171819class Cat { public Cat(String name) { this.name = name; } private String name; public String getName() { return name; } public void setName(String name) { this.name = name; }}Cat c1 = new Cat(&quot;王磊&quot;);Cat c2 = new Cat(&quot;王磊&quot;);System.out.println(c1.equals(c2)); // false 输出结果出乎我们的意料，竟然是 false？这是怎么回事，看了 equals 源码就知道了，源码如下： 123public boolean equals(Object obj) { return (this == obj);} 原来 equals 本质上就是 ==。 同样的，当我们进入 String 的 equals 方法，找到了答案，代码如下： value哪来的？？？ – String底层是数组，value可以拿到String的char数组。 123456789101112131415161718192021public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) { char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) { if (v1[i] != v2[i]) return false; i++; } return true; } } return false;} 源码里String的代码： 123456789101112public boolean equals(Object anObject) { if (this == anObject) { return true; } if (anObject instanceof String) { String = aString = (String)anObject; if(coder() == aString.coder()) { return isLatin1() ? StringLatin1.equals(value, aString.value) : StringUTF16.equals(value, aString.value); } } return false;} 原来是 String 重写了 Object 的 equals 方法，把引用比较改成了值比较。 equals用来比较的是两个对象的内容是否相等，由于所有的类都是继承自java.lang.Object类的，所以适用于所有对象，如果没有对该方法进行覆盖的话，调用的仍然是Object类中的方法，而Object中的equals方法返回的却是==的判断。 String s=”abce”是一种非常特殊的形式,和new 有本质的区别。它是java中唯一不需要new 就可以产生对象的途径。 以String s=”abce”;形式赋值在java中叫直接量,它是在常量池中而不是象new一样放在压缩堆中。这种形式的字符串，在JVM内部发生字符串拘留，即当声明这样的一个字符串后，JVM会在常量池中先查找有有没有一个值为”abcd”的对象。 如果有，就会把它赋给当前引用.即原来那个引用和现在这个引用指点向了同一对象，如果没有，则在常量池中新创建一个“abcd””，下一次如果有Strings1=”abcd”；又会将s1指向“abcd”这个对象，即以这形式声明的字符串，只要值相等，任何多个引用都指向同一对象。 而String s=new String（”abcd”）；和其它任何对象一样.每调用一次就产生一个对象，只要它们调用。 也可以这么理解：String str=”hello”；先在内存中找是不是有“hello”这个对象，如果有，就让str指向那个“hello”。 如果内存里没有”hello”，就创建一个新的对象保存”hello”.String str=new String（“hello”）就是不管内存里是不是已经有”hello”这个对象，都新建一个对象保存”hello”。 总结==：对象地址，基本数据类型 == 比较的是值，引用数据类型==比较的是内存地址 equals：没有重写，同==。重写了，则是比较内容是否相同，而不是地址。 插播：如果两个对象的 hashCode()相同，则 equals()也一定为 true，对吗？ 不对，两个对象的 hashCode()相同，equals()不一定 true。显然“通话”和“重地”的 hashCode() 相同，然而 equals() 则为 false，因为在散列表中，hashCode()相等即两个键值对的哈希值相等，然而哈希值相等，并不一定能得出键值对相等。 7. Java中的内部类 成员内部类 12345678910111213class Circle { double radius = 0; public Circle(double radius) { this.radius = radius; } class Draw { //内部类 public void drawSahpe() { System.out.println(&quot;drawshape&quot;); } }} 这样看起来，类Draw像是类Circle的一个成员，Circle称为外部类。成员内部类可以无条件访问外部类的所有成员属性和成员方法（包括private成员和静态成员）。 1234567891011121314class Circle { private double radius = 0; public static int count =1; public Circle(double radius) { this.radius = radius; } class Draw { //内部类 public void drawSahpe() { System.out.println(radius); //外部类的private成员 System.out.println(count); //外部类的静态成员 } }} 不过要注意的是，当成员内部类拥有和外部类同名的成员变量或者方法时，会发生隐藏现象，即默认情况下访问的是成员内部类的成员。如果要访问外部类的同名成员，需要以下面的形式进行访问： 12外部类.this.成员变量外部类.this.成员方法 虽然成员内部类可以无条件地访问外部类的成员，而外部类想访问成员内部类的成员却不是这么随心所欲了。在外部类中如果要访问成员内部类的成员，必须先创建一个成员内部类的对象，再通过指向这个对象的引用来访问： 123456789101112131415161718class Circle { private double radius = 0; public Circle(double radius) { this.radius = radius; getDrawInstance().drawSahpe(); //必须先创建成员内部类的对象，再进行访问 } private Draw getDrawInstance() { return new Draw(); } class Draw { //内部类 public void drawSahpe() { System.out.println(radius); //外部类的private成员 } }} 成员内部类是依附外部类而存在的，也就是说，如果要创建成员内部类的对象，前提是必须存在一个外部类的对象。创建成员内部类对象的一般方式如下： 1234567891011121314151617181920212223242526272829public class Test { public static void main(String[] args) { //第一种方式： Outter outter = new Outter(); Outter.Inner inner = outter.new Inner(); //必须通过Outter对象来创建 //第二种方式： Outter.Inner inner1 = outter.getInnerInstance(); }} class Outter { private Inner inner = null; public Outter() { } public Inner getInnerInstance() { if(inner == null) inner = new Inner(); return inner; } class Inner { public Inner() { } }} 内部类可以拥有private访问权限、protected访问权限、public访问权限及包访问权限。比如上面的例子，如果成员内部类Inner用private修饰，则只能在外部类的内部访问，如果用public修饰，则任何地方都能访问；如果用protected修饰，则只能在同一个包下或者继承外部类的情况下访问；如果是默认访问权限，则只能在同一个包下访问。这一点和外部类有一点不一样，外部类只能被public和包访问两种权限修饰。我个人是这么理解的，由于成员内部类看起来像是外部类的一个成员，所以可以像类的成员一样拥有多种权限修饰。 局部内部类 123456789101112131415161718class People{ public People() { }} class Man{ public Man(){ } public People getWoman(){ class Woman extends People{ //局部内部类 int age =0; } return new Woman(); }} 注意，局部内部类就像是方法里面的一个局部变量一样，是不能有public、protected、private以及static修饰符的。 匿名内部类 匿名内部类应该是平时我们编写代码时用得最多的，在编写事件监听的代码时使用匿名内部类不但方便，而且使代码更加容易维护。下面这段代码是一段Android事件监听 1234567891011121314151617scan_bt.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { // TODO Auto-generated method stub } }); history_bt.setOnClickListener(new OnClickListener() { @Override public void onClick(View v) { // TODO Auto-generated method stub } }); 这里new onClickListener()就是匿名内部类 就是匿名内部类的使用。代码中需要给按钮设置监听器对象，使用匿名内部类能够在实现父类或者接口中的方法情况下同时产生一个相应的对象，但是前提是这个父类或者接口必须先存在才能这样使用。当然像下面这种写法也是可以的，跟上面使用匿名内部类达到效果相同。 123456789101112131415161718192021private void setListener(){ scan_bt.setOnClickListener(new Listener1()); history_bt.setOnClickListener(new Listener2());} class Listener1 implements View.OnClickListener{ @Override public void onClick(View v) { // TODO Auto-generated method stub }} class Listener2 implements View.OnClickListener{ @Override public void onClick(View v) { // TODO Auto-generated method stub }} 这种写法虽然能达到一样的效果，但是既冗长又难以维护，所以一般使用匿名内部类的方法来编写事件监听代码。同样的，匿名内部类也是不能有访问修饰符和static修饰符的。 匿名内部类是唯一一种没有构造器的类。正因为其没有构造器，所以匿名内部类的使用范围非常有限，大部分匿名内部类用于接口回调。匿名内部类在编译的时候由系统自动起名为Outter$1.class。一般来说，匿名内部类用于继承其他类或是实现接口，并不需要增加额外的方法，只是对继承方法的实现或是重写。 静态内部类 静态内部类也是定义在另一个类里面的类，只不过在类的前面多了一个关键字static。静态内部类是不需要依赖于外部类的，这点和类的静态成员属性有点类似，并且它不能使用外部类的非static成员变量或者方法，这点很好理解，因为在没有外部类的对象的情况下，可以创建静态内部类的对象，如果允许访问外部类的非static成员就会产生矛盾，因为外部类的非static成员必须依附于具体的对象。 1234567891011121314151617public class Test { public static void main(String[] args) { Outter.Inner inner = new Outter.Inner(); }} class Outter { public Outter() { } static class Inner { public Inner() { } }} 使用场景为什么在Java中需要内部类？总结一下主要有以下四点： 1.每个内部类都能独立的继承一个接口的实现，所以无论外部类是否已经继承了某个(接口的)实现，对于内部类都没有影响。内部类使得多继承的解决方案变得完整， 2.方便将存在一定逻辑关系的类组织在一起，又可以对外界隐藏。 3.方便编写事件驱动程序 4.方便编写线程代码 个人觉得第一点是最重要的原因之一，内部类的存在使得Java的多继承机制变得更加完善。 面试笔试题1.根据注释填写(1)，(2)，(3)处的代码1234567891011121314151617181920212223242526public class Test{ public static void main(String[] args){ // 初始化Bean1 (1) bean1.I++; // 初始化Bean2 (2) bean2.J++; //初始化Bean3 (3) bean3.k++; } class Bean1{ public int I = 0; } static class Bean2{ public int J = 0; }} class Bean{ class Bean3{ public int k = 0; }} 从前面可知，对于成员内部类，必须先产生外部类的实例化对象，才能产生内部类的实例化对象。而静态内部类不用产生外部类的实例化对象即可产生内部类的实例化对象。 创建静态内部类对象的一般形式为： 外部类类名.内部类类名 xxx = new 外部类类名.内部类类名() 创建成员内部类对象的一般形式为： 外部类类名.内部类类名 xxx = 外部类对象名.new 内部类类名() 因此，（1），（2），（3）处的代码分别为： 12345678# 成员内部类Test test = new Test(); Test.Bean1 bean1 = test.new Bean1(); # 静态内部类Test.Bean2 b2 = new Test.Bean2();# 局部内部类Bean bean = new Bean(); Bean.Bean3 bean3 = bean.new Bean3(); xw 2.下面这段代码的输出结果是什么？123456789101112131415161718192021public class Test { public static void main(String[] args) { Outter outter = new Outter(); outter.new Inner().print(); }} class Outter{ private int a = 1; class Inner { private int a = 2; public void print() { int a = 3; System.out.println(&quot;局部变量：&quot; + a); System.out.println(&quot;内部类变量：&quot; + this.a); System.out.println(&quot;外部类变量：&quot; + Outter.this.a); } }} 123321 最后补充一点知识：关于成员内部类的继承问题。一般来说，内部类是很少用来作为继承用的。但是当用来继承的话，要注意两点： 1）成员内部类的引用方式必须为 Outter.Inner. 2）构造器中必须有指向外部类对象的引用，并通过这个引用调用super()。这段代码摘自《Java编程思想》 1234567891011121314151617class WithInner { class Inner{ }}class InheritInner extends WithInner.Inner { // InheritInner() 是不能通过编译的，一定要加上形参 InheritInner(WithInner wi) { wi.super(); //必须有这句调用 } public static void main(String[] args) { WithInner wi = new WithInner(); InheritInner obj = new InheritInner(wi); }} 总结：成员内部类：在另一个类内部 局部内部类：方法或者一个作用域里，与成员内部类区别：访问权限只局限于方法内或作用域 匿名内部类：唯一一种没有构造器的类，用于实现接口 静态内部类：在另一个类里，与成员内部类区别：不过多了一个关键字static 8. Java有哪些修饰符？有哪些区别？Java中的修饰符有public、private、protected. 1、public：public表明该数据成员、成员函数对所有用户开放的，所有用户都可以直接进行调用2、private：private表示私有、私有的意思就是除了class自己之外，任何人都不可以直接使用，私有财产神圣不可侵犯嘛，即便是子女，朋友，都不可以使用。3、protected：protected对于子女、朋友来说，就是public的，可以自由使用，没有任何限制，而对于其他外部class，protected就变成private。 总结： 访问级别 访问控制修饰符 同类 同包 子类(不同包) 不同包(其他类) 公共 public 允许 允许 允许 允许 受保护 protected 允许 允许 允许 不允许 默认 缺省修饰符 允许 允许 不允许 不允许 私有 private 允许 不允许 不允许 不允许 public: 全 private：只能类内 protected：不能不同包 追问：怎么获取private修饰的变量Private通过反射获取，可以设置setAccessable为true实现 下面是某博客的例子，只是一个演示用法。 123456789101112131415161718192021/** * @Description: 反射 * @author: Mr_VanGogh */public class Reflect { private String name; private int age; private Reflect(int age) { this.age = age; } private void speak(String name) { System.out.println(&quot;My name is&quot; + name); } public Reflect(String name) { this.name = name; }} 反射就是在运行时才知道要操作的类是什么，并且可以在运行时获取类的完整构造，并调用对应的方法。 12345Class clz = Class.forName(&quot;com.chenshuyi.reflect.Apple&quot;);Method method = clz.getMethod(&quot;setPrice&quot;, int.class);Constructor constructor = clz.getConstructor();Object object = constructor.newInstance();method.invoke(object, 4); 首先，我们要了解三个反射包中的类： Constructor：代表类的单个构造方法，通过Constructor我们可执行一个类的某个构造方法（有参或者无参）来创建对象时。 Method：代表类中的单个方法，可以用于执行类的某个普通方法，有参或无参，并可以接收返回值。 Field：代表类中的单个属性，用于set或get属性 AccessibleObject：以上三个类的父类，提供了构造方法，普通方法，和属性的访问控制的能力。 使用Class类中的方法可以获得该类中的所有Constructor对象，Method对象，和Field对象。但是任然无法访问私有化的构造方法，普通方法，和私有属性，此时我们可以使用他们继承父类(AccessibleObject)中的setAccessible（）方法，来设置或取消访问检查，以达到访问私有对象的目的。 1234567891011121314151617181920public static void main(String[] args) throws Exception { Reflect reflect = new Reflect(&quot;a&quot;); Method[] methods = Reflect.class.getMethods(); Field[] fields = Reflect.class.getDeclaredFields(); for (int i = 0; i &lt; fields.length; i ++) { fields[i].setAccessible(true); System.out.println(fields[i].getName()); } for (int j = 0; j &lt; methods.length; j ++) { methods[j].setAccessible(true); System.out.println(methods[j].getName()); methods[j].invoke(reflect); System.out.println(methods[j].getName()); } } 9. Java的异常体系说一下？ Java中的异常主要分为Error和Exception Error指Java程序运行错误，如果程序在启动时出现Error，则启动失败；如果程序运行过程中出现Error，则系统将退出程序。出现Error是系统的内部错误或资源耗尽，Error不能在程序运行过程中被动态处理，一旦出现Error，系统能做的只有记录错误的原因和安全终止。 AWTError / ThreadDeath Exception指Java程序运行异常，在运行中的程序发生了程序员不期望发生的事情，可以被Java异常处理机制处理。Exception也是程序开发中异常处理的核心，可分为RuntimeException（运行时异常）和CheckedException（检查异常），如下图所示。 RuntimeException （Unchecked Exception）（运行时异常）：指在Java虚拟机正常运行期间抛出异常，RuntimeException可以被捕获并处理，如果出现情况，我们需要抛出异常或者捕获并处理异常。常见的有NullPointerExcception, ClassCastException, ArrayIndexOutOfBoundsException等 CheckedException（检查异常）：指在编译阶段Java编译器检查CheckedException异常，并强制程序捕获和处理此类异常，要求程序在可能出现异常的地方通过try catch语句块捕获异常并处理异常。常见的有由于I/O错误导致的IOException、SQLException、ClassNotFoundException等。该类异常通常由于打开错误的文件、SQL语法错误、类不存等引起。 总结：在 Java 中，所有的异常都有一个共同的祖先 java.lang 包中的 Throwable 类。Throwable 类有两个重要的子类: Error：Error 属于程序无法处理的错误 ，我们没办法通过 catch 来进行捕获不建议通过catch捕获 。例如 Java 虚拟机运行错误（Virtual MachineError）、虚拟机内存不够错误(OutOfMemoryError)、类定义错误（NoClassDefFoundError）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。 Exception：程序本身可以处理的异常，可以通过 catch 来进行捕获。Exception 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。 异常的处理方式？异常处理方式有抛出异常和使用try catch语句块捕获异常两种方式。（1）抛出异常：遇到异常时不进行具体的处理，直接将异常抛给调用者，让调用者自己根据情况处理。抛出异常的三种方式：throws、throw和系统自动抛出异常。其中throws作用在方法上，用于定义方法可能抛出的异常；throw作用在方法内，表示明确抛出一个异常。（2）使用try catch捕获并处理异常：使用try catch捕获异常能够针对性的处理每种可能出现的异常，并在捕获到异常后根据不同的情况做不同的处理。其使用过程比较简单，用try catch语句块可能出现异常的代码包起来即可。 10. Java中的深拷贝和浅拷贝说一下？深拷贝和浅拷贝都是对象拷贝 浅拷贝：按位拷贝对象，它会创建一个新对象，这个对象有着原始对象属性的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值；如果属性是内存地址（引用类型），拷贝的就是内存地址，因此如果其中一个对象改变了这个地址，就会影响到另一个对象。（浅拷贝仅仅复制所考虑的对象，而不是复制它所引用的对象）。 深拷贝：在拷贝引用类型成员变量时，为引用类型的数据成员另辟了一个独立的内存空间，实现真正内容上的拷贝。（深拷贝把要复制的对象所引用的对象都复制了一遍。） 特点：浅拷贝特点（1）：对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个。（2）对于引用类型，比如数组或者类对象，因为引用类型是引用传递，所以浅拷贝只是把内存地址赋值给了成员变量，它们指向了同一内存空间。改变其中一个，会对另外一个也产生影响。 深拷贝特点（1）对于基本数据类型的成员对象，因为基础数据类型是值传递的，所以是直接将属性值赋值给新的对象。基础类型的拷贝，其中一个对象修改该值，不会影响另外一个（和浅拷贝一样）。（2）对于引用类型，比如数组或者类对象，深拷贝会创建一个对象空间，然后拷贝里面的内容，所以它们指向了不同的内存空间。改变其中一个，不会对另外一个也产生影响。（3）对于有多层对象的，每个对象都需要实现Cloneable并重写clone（）方法，进而实现了对象的串行层层拷贝。（4）深拷贝相比于浅拷贝速度较慢并且花销较大。 参考链接[1]: https://www.cnblogs.com/dolphin0520/p/3811445.html “Java内部类详解”[2]: https://www.nowcoder.com/discuss/916143 “Java超高频面试题汇总”[3]: https://juejin.cn/post/6844903790089338887 “你真的懂==和equals的区别吗？”[4]: “《java编程思想》” [5]: https://cloud.tencent.com/developer/article/1886994 “面试官：private修饰的方法可以通过反射访问，那么private的意义是什么？”[6]: https://javaguide.cn/java/basis/java-basic-questions-01.html# “JavaGuide” [7]: https://www.cnblogs.com/chanshuyi/p/head_first_of_reflection.html “大白话说Java反射：入门、使用、原理”[8]: https://blog.csdn.net/u012723673/article/details/80613557 “Java中各类修饰符的使用总结（看完这篇就够了）”","link":"/2022/10/08/String/"},{"title":"Vue Feature","text":"本文主要讲一下Vue的双向绑定，单向数据流以及响应式原理。不要搞混了三者的概念～ 本文暂时也是对其他博客的一个整理以及自己一点总结～ Vue 单向绑定 + V-model = 双向绑定 V-model = View 层 + 监听事件 单向数据流 = 父组建流向子组件 响应式原理（单向绑定原理） = 数据劫持只是解决了属性变更后，触发通知的问题。通知谁是由Dep来做，数据劫持触发Dep，Dep进一步触发Watcher，Watcher收到属性变化通知后，执行render，生成新的 virutal-dom 结构，再交由 Vue 做diff，更新视图。 单向绑定 VS 双向绑定 单向绑定 VS 双向绑定 绑定：视图层与逻辑层之间的互相通知 （View 与 Modal 层之间的映射关系） 单向数绑定的优缺点： 优点：所有状态变化都可以被记录、跟踪，状态变化通过手动调用触发，源头易追溯。 缺点：会有很多类似的样板代码，代码量会相应的上升。 双向数据绑定的优缺点： 优点：在操作表单时使用v-model方便简单，可以省略繁琐或重复的onChange事件去处理每个表单数据的变化（减少代码量）。 缺点：属于暗箱操作，无法很好的追踪双向绑定的数据的变化。 单向绑定 双向绑定 Vue 插值形式{{data}}，v-bind也是单向绑定 表单的v-model，用户对View层的更改会直接同步到Model层 React 当View层发生更改时，用户通过发出Actions进行处理，Actions中通过setState对State进行更新，State更新后触发View更新。可以看出，View层不能直接修改State，必须要通过Actions来进行操作，这样更加清晰可在 React 中，View 层是不能直接修改 State，必须通过相应的 Actions 来进行操作。 Angular 使用[x]属性绑定、(x)事件绑定或插值形式{{data}}。 使用[(x)]语法，用户对View的更改会直接同步到Model。 Angular JS 使用ng-bind指令或插值形式{{data}}。 使用ng-model指令，用户对View的更改会直接同步到Model。 Vue &amp; React 实际上v-model只是v-bind:value 和 v-on:input的语法糖，我们也可以采取类似react的单向绑定。两者各有利弊，单向绑定清晰可控，但是模板代码过多，双向绑定可以简化开发，但是也会导致数据变化不透明，优缺点共存，大家可以根据情况使用。1 Vue &amp; Angular 除了语法上有所不同，Angular 双向数据绑定与 Vue 类似，也是语法糖，[(x)] 语法结合了属性绑定[x] 和事件绑定 (x)。 Vue &amp; Angular JS AngularJS 的双向数据绑定实现原理与 Angular 完全不同，其实现原理可以参考这篇文章。**(留坑)** 单向数据流 VS 双向数据流 单向数据流 VS 双向数据流 所谓数据流，就是指的是组件之间的数据流动。（父子组件） React、Vue 以及 Angular 都只是单向数据流 虽然 Vue 和 Angular 有双向数据绑定，但 Vue 和 Angualr 父子组件之间数据传递，仍然遵循单向数据流，即父组件可以向子组件传递props，但是子组件不能修改父组件传递来的props，子组件只能通过事件通知父组件进行数据更改。如下图所示： 优点：由于组件数据传递只有唯一的入口和出口，使得程序更直观、更容易理解，有利于程序的可维护性。 AngularJS 支持双向数据流 所谓双向数据流，就是指在子组件中可以直接更新父组件的数据。 缺点：由于组件数据变化的来源入口变得可能不止一个，如果缺乏相应的“管理”手段，容易将数据流转方向弄得紊乱。同时也会增加了出错时 debug 的难度。 数据流与数据绑定 严格来说，数据流和数据绑定是两个概念，并不是同一个东西。单向数据流也可以支持双向数据绑定，双向数据流也可以支持单向数据绑定。 简单总结一下前端三大框架的数据流与数据绑定的区别：5 数据劫持 数据劫持 双向绑定的原理就是数据劫持与发布订阅模式的结合。 Vue2: 针对 Object 类型，采用 Object.defineProperty() 方法劫持属性的读取和设置方法； 针对 Array 类型，采用原型相关的知识劫持常用的函数，从而知晓当前数组发生变化。 详解： 对象 Object.defineProperty() 方法设置属性的 setter 与 getter 方法，从而达到劫持 student 对象中的 name 属性的读取和设置操作的目的。该方法每次只能设置一个属性，那么就需要遍历对象来完成其属性的配置： 1Object.keys(student).forEach(key =&gt; defineReactive(student, key)) 另外还必须是一个具体的属性，这也非常的致命。 假如后续需要扩展该对象，那么就必须手动为新属性设置 setter 和 getter 方法，**这就是为什么不在 data 中声明的属性无法自动拥有双向绑定效果的原因 **。（这时需要调用 Vue.set() 手动设置） 数组 数组是一种特殊的对象，其下标实际上就是对象的属性，所以理论上是可以采用 Object.defineProperty() 方法处理数组对象。数组对象的 length 属性的描述符天生独特：这就意味着无法通过 Object.defineProperty() 方法劫持 length 属性的读取和设置方法。相比较对象的属性，数组下标变化地相对频繁，并且改变数组长度的方法也比较灵活，一旦数组的长度发生变化，那么在无法自动感知的情况下，开发者只能手动更新新增的数组下标，这可是一个很繁琐的工作。数组主要的操作场景还是遍历，而对于每一个元素都挂载一个 get 和 set 方法，恐怕也是不小的性能负担。最终 Vue 选择劫持一些常用的数组操作方法，从而知晓数组的变化情况： 123456789const methods = [ 'push', 'pop', 'shift', 'unshift', 'sort', 'reverse', 'splice'] 数组方法的劫持涉及到原型相关的知识，首先数组实例大部分方法都是来源于 Array.prototype 对象。 但是这里不能直接篡改 Array.prototype 对象，这样会影响所有的数组实例，为了避免这种情况，需要采用原型继承得到一个新的原型对象： 12const arrayProto = Array.prototypeconst injackingPrototype = Object.create(arrayProto) 拿到新的原型对象之后，再重写这些常用的操作方法： 12345678910111213141516171819202122methods.forEach(method =&gt; { const originArrayMethod = arrayProto[method] injackingPrototype[method] = function (...args) { const result = originArrayMethod.apply(this, args) let inserted switch (method) { case 'push': case 'unshift': inserted = args break case 'splice': inserted = args.slice(2) break } if (inserted) { // 对于新增的元素，继续劫持 // ob.observeArray(inserted) } // 通知变化 return result }}) 最后，更新劫持数组实例的原型，在 ES6 之前，可以通过浏览器私有属性 proto 指定原型，之后，便可以采用如下方法： 1Object.setPrototypeOf(arr, injackingPrototype) 顺便提一下，采用 Vue.set() 方法设置数组元素时，Vue 内部实际上是调用劫持后的 splice() 方法来触发更新。 Object.defineProperty()的缺点1).不能监听数组的变化数组的以下几个方法不会触发 set： push、pop、shift、unshift、splice、sort、reverse Vue 把这些方法定义为变异方法 (mutation method)，指的是会修改原来数组的方法。与之对应则是非变异方法 (non-mutating method)，例如 filter, concat, slice 等，它们都不会修改原始数组，而会返回一个新的数组。 2).必须遍历对象的每个属性使用 Object.defineProperty() 多数要配合 Object.keys() 和遍历，于是多了一层嵌套。如： 12345Object.keys(obj).forEach(key =&gt; { Object.defineProperty(obj, key, { // ... })}) 给出完整版的数据劫持代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960const arrayProto = Array.prototype;// 得到原型上的方法const proto = Object.create(arrayProto) // 复制一份原型上的方法 ;['push', 'shift', 'pop', 'splice'].forEach(method =&gt; { // console.log(method) // 重写'push','shift','pop','splice',当然也可以多加几个方法，想加什么就加什么 proto[method] = function (...args) { // console.log(this) // [ 1, 2, 3, { age: [Getter/Setter] } ] updateView(); arrayProto[method].call(this, ...args) } })function updateView() { console.log(&quot;更新视图成功了...&quot;)}function observer(obj) { if (typeof obj !== &quot;object&quot; || obj == null) { return obj } if (Array.isArray(obj)) { // 如果是一个数组要重写数组上原型上的方法 Object.setPrototypeOf(obj, proto) for (let i = 0; i &lt; obj.length; i++) { let item = obj[i]; observer(item) } } else { for (let key in obj) { definedReactive(obj, key, obj[key]) } }}function definedReactive(obj, key, value) { observer(value) Object.defineProperty(obj, key, { get() { console.log(&quot;获取数据成功了...&quot;) return value; }, set(newValue) { if (value !== newValue) { observer(newValue) value = newValue; updateView(); } } })}let data = { name: [1, 2, 3, { age: 888 }] }observer(data)// 数据改变了// data.name[3].age = 666; // push shift unshift pop 也能改变数组中的数组data.name.push({ address: &quot;xxx&quot; }) // 目的是：更新视图// 思路：重写Push方法 这些方法在Array的原型上// 不要把Array原型上的方法直接重写了// 先把原型上的方法copy一份，去重写（加上视图更新的操作）// 再去调用最原始的push方法 Vue3: Proxy数据代理在数据劫持这个问题上，Proxy 可以被认为是 Object.defineProperty() 的升级版。外界对某个对象的访问，都必须经过这层拦截。因此它是针对 整个对象，而不是 对象的某个属性。 proxy即代理的意思。个人理解，建立一个proxy代理对象（Proxy的实例），接受你要监听的对象和监听它的handle两个参数。当你要监听的对象发生任何改变，都会被proxy代理拦截来满足需求。 12345678910111213141516var arr = [1,2,3]var handle = { //target目标对象 key属性名 receiver实际接受的对象 get(target,key,receiver) { console.log(`get ${key}`) // Reflect相当于映射到目标对象上 return Reflect.get(target,key,receiver) }, set(target,key,value,receiver) { console.log(`set ${key}`) return Reflect.set(target,key,value,receiver) }}//arr要拦截的对象，handle定义拦截行为var proxy = new Proxy(arr,handle)proxy.push(4) //可以翻到控制台测试一下会打印出什么 优点： 1.使用proxy可以解决defineProperty不能监听数组的问题，避免重写数组方法； 2.不需要再遍历key。 3.Proxy handle的拦截处理器除了get、set外还支持多种拦截方式。 4.嵌套查询。实际上proxy get()也是不支持嵌套查询的。解决方法： 123456789let handler = { get (target, key, receiver) { // 递归创建并返回 if (typeof target[key] === 'object' &amp;&amp; target[key] !== null) { return new Proxy(target[key], handler) } return Reflect.get(target, key, receiver) }} 依赖管理方案Object.defineProperty 只是解决了状态变更后，如何触发通知的问题，那要通知谁呢？谁会关心那些属性发生了变化呢？在 Vue 中，使用 Dep 解耦了依赖者与被依赖者之间关系的确定过程。简单来说： 第一步，通过 Observer 提供的接口，遍历状态对象，给对象的每个属性、子属性都绑定了一个专用的 Dep 对象。这里的状态对象主要指组件当中的data属性。 第二步，创建三中类型的watcher： 1.调用 initComputed 将 computed 属性转化为 watcher 实例 2.调用 initWatch 方法，将 watch 配置转化为 watcher 实例 3.调用 mountComponent 方法，为 render 函数绑定 watcher 实例 第三步，状态变更后，触发 dep.notify() 函数，该函数再进一步触发 Watcher 对象 update 函数，执行watcher的重新计算。 我们已经知道实现数据的双向绑定，首先要对数据进行劫持监听，所以我们需要设置一个监听器Observer，用来监听所有属性。如果属性发上变化了，就需要告诉订阅者Watcher看是否需要更新。因为订阅者是有很多个，所以我们需要有一个消息订阅器Dep来专门收集这些订阅者，然后在监听器Observer和订阅者Watcher之间进行统一管理的。接着，我们还需要有一个指令解析器Compile，对每个节点元素进行扫描和解析，将相关指令对应初始化成一个订阅者Watcher，并替换模板数据或者绑定相应的函数，此时当订阅者Watcher接收到相应属性的变化，就会执行对应的更新函数，从而更新视图。因此接下去我们执行以下3个步骤，实现数据的双向绑定：1.实现一个监听器Observer，用来劫持并监听所有属性，如果有变动的，就通知订阅者。2.实现一个订阅者Watcher，可以收到属性的变化通知并执行相应的函数，从而更新视图。3.实现一个解析器Compile，可以扫描和解析每个节点的相关指令，并根据初始化模板数据以及初始化相应的订阅器。 总结： 数据劫持只是解决了属性变更后，触发通知的问题。通知谁是由Dep来做，数据劫持触发Dep，Dep进一步触发Watcher，Watcher收到属性变化通知后，执行render，生成新的 virutal-dom 结构，再交由 Vue 做diff，更新视图。 v-model是语法糖 为什么v-model是语法糖 前面说到，React之所以是单向绑定，是因为视图层的更改无法带动Model层的更改，而v-model本质就是对视图层添加监听事件，然后监听到后去修改Model层。 V-model底层实现，最后有2句关键代码： 12addProp(el, 'value', `(${value})`)addHandler(el, event, code, null, true) 这实际上就是 input 实现 v-model 的精髓，通过修改 AST 元素，给 el 添加一个 prop，相当于我们在 input 上动态绑定了 value，又给 el 添加了事件处理，相当于在 input 上绑定了 input 事件，其实转换成模板如下： 123&lt;input v-bind:value=&quot;message&quot; v-on:input=&quot;message=$event.target.value&quot;&gt; 其实就是动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message 设置为目标值，这样实际上就完成了数据双向绑定了，所以说 v-model 实际上就是语法糖。 其他补充 其他补充 v-bind指令用于设置HTML属性：v-bind:href 缩写为 :href 1&lt;a :href=&quot;{{url}}&quot;&gt;aa&lt;/a&gt; v-on 指令用于绑定HTML事件 ：v-on:click 缩写为 @click 1&lt;a @click=&quot;get()&quot;&gt;aa&lt;/a&gt; 引用与参考 [1]: https://juejin.cn/post/7085139499767840782 “Vue的双向绑定和单向数据流冲突吗?”[2]: https://ustbhuangyi.github.io/vue-analysis/v2/extend/v-model.html#%E8%A1%A8%E5%8D%95%E5%85%83%E7%B4%A0 “Vue.js 技术揭秘”[3]: https://juejin.cn/post/6844903913217327111 “Vue 数据劫持”[4]: https://juejin.cn/post/7135290464319733768 “聊聊 Vue3 是如何工作的” [5]: https://juejin.cn/post/6854573208646090765 “前端三大框架：数据绑定与数据流”[6]: https://cloud.tencent.com/developer/article/1020807 “前端三大框架vue，angular，react大杂烩”[7]: https://juejin.cn/post/6844903828593049613#heading-5 “深入浅出 Vue 系列 – 数据劫持实现原理”[8]: https://juejin.cn/post/6844903463285948423 “Vue 核心之数据劫持”","link":"/2022/10/12/Vue-Relation/"},{"title":"Webpack详解","text":"[1]: https://www.youtube.com/watch?v=Gc9-7PBqOC8 “实时创建一个简单打包工具”[2]: https://github.com/ronami/minipack “一个简单打包工具的详细说明”[3]: https://www.youtube.com/watch?v=UNMkLHzofQI “手动打包一个应用程序”[4]: https://webpack.docschina.org/concepts/ “Webpack官方文档” 入口（Entry）默认值是 ./src/index.js，但你可以通过在 webpack configuration 中配置 entry 属性，来指定一个（或多个）不同的入口起点。 webpack.config.js 123module.exports = { entry: './path/to/my/entry/file.js',}; 输出（Output）output 属性告诉 webpack 在哪里输出它所创建的 bundle，以及如何命名这些文件。主要输出文件的默认值是 ./dist/main.js，其他生成文件默认放置在 ./dist 文件夹中。 123456789const path = require('path');module.exports = { entry: './path/to/my/entry/file.js', output: { path: path.resolve(__dirname, 'dist'), filename: 'my-first-webpack.bundle.js', },}; 在上面的示例中，我们通过 output.filename 和 output.path 属性，来告诉 webpack bundle 的名称，以及我们想要 bundle 生成(emit)到哪里。可能你想要了解在代码最上面导入的 path 模块是什么，它是一个 Node.js 核心模块，用于操作文件路径。 Loaderwebpack 只能理解 JavaScript 和 JSON 文件，这是 webpack 开箱可用的自带能力。loader 让 webpack 能够去处理其他类型的文件，并将它们转换为有效 模块，以供应用程序使用，以及被添加到依赖图中。 在更高层面，在 webpack 的配置中，loader 有两个属性： test 属性，识别出哪些文件会被转换。 use 属性，定义出在进行转换时，应该使用哪个 loader。 12345678910const path = require('path');module.exports = { output: { filename: 'my-first-webpack.bundle.js', }, module: { rules: [{ test: /\\.txt$/, use: 'raw-loader' }], },}; 以上配置中，对一个单独的 module 对象定义了 rules 属性，里面包含两个必须属性：test 和 use。这告诉 webpack 编译器(compiler) 如下信息： “嘿，webpack 编译器，当你碰到「在 require()/import 语句中被解析为 ‘.txt’ 的路径」时，在你对它打包之前，先 use(使用) raw-loader 转换一下。” 插件（Plugin）loader 用于转换某些类型的模块，而插件则可以用于执行范围更广的任务。包括：打包优化，资源管理，注入环境变量。 想要使用一个插件，你只需要 require() 它，然后把它添加到 plugins 数组中。多数插件可以通过选项(option)自定义。你也可以在一个配置文件中因为不同目的而多次使用同一个插件，这时需要通过使用 new 操作符来创建一个插件实例。 123456789const HtmlWebpackPlugin = require('html-webpack-plugin');const webpack = require('webpack'); // 用于访问内置插件module.exports = { module: { rules: [{ test: /\\.txt$/, use: 'raw-loader' }], }, plugins: [new HtmlWebpackPlugin({ template: './src/index.html' })],}; 在上面的示例中，html-webpack-plugin 为应用程序生成一个 HTML 文件，并自动将生成的所有 bundle 注入到此文件中。 模式（Mode）通过选择 development, production 或 none 之中的一个，来设置 mode 参数，你可以启用 webpack 内置在相应环境下的优化。其默认值为 production。 123module.exports = { mode: 'production',}; 详解： 在模块化编程中，开发者将程序分解为功能离散的 chunk，并称之为 模块。 热更新怎么实现的？","link":"/2022/12/08/Webpack/"},{"title":"The Perfect Advanced React&#x2F;TypeScript Project - Markdown Supported Note Taking With Categories","text":"Highlight: https://app.highlight.run/?promo=WEBD... Coupon Code: WEBDEVSIMPLIFIED (This should be automatically filled in as you go through the signup process) Todo lists are boring and pretty limited so in this video I am going to show you how to build a more advanced project that covers all the features of a todo list while also adding tons of additional features like categories, markdown support, filter, etc. This is a great intermediate to advanced project. 📚 Materials/References: GitHub Code: https://github.com/WebDevSimplified/r... React Router Video: https://youtu.be/Ul3y1LXxzdU React Router Article: https://blog.webdevsimplified.com/202... React Multiselect Video: https://youtu.be/bAJlYgeovlg 🌎 Find Me Here: My Blog: https://blog.webdevsimplified.com My Courses: https://courses.webdevsimplified.com Patreon: https://www.patreon.com/WebDevSimplified Twitter: https://twitter.com/DevSimplified Discord: https://discord.gg/7StTjnR GitHub: https://github.com/WebDevSimplified CodePen: https://codepen.io/WebDevSimplified 一、项目介绍实现一个高级笔记应用程序，具有过滤，分类的markdown，并且支持路由，删除，修改，更新。 二、项目实现1、前端技术类型：React、Typescript、Vite（npm create vite）、使用的库：npm ireact-select :react-bootstrapreact-router-dombootstrapuuid / –save-dev @types/uuidreact-markdown 三、遇到的问题Q ： –save -dev是啥意思？A ： 将模块安装到项目目录下，并在package文件的devDependencies节点写入依赖。devDependencies 节点下的模块是我们在开发时需要用的，比如项目中使用的 gulp ，压缩 css、js 的模块。这些模块在我们的项目部署后是不需要的，所以我们可以使用 –save-dev 的形式安装。像 express 这些模块是项目运行必备的，应该安装在 dependencies 节点下，所以我们应该使用 –save 的形式安装。 Q ： NPM中，dependencies 跟 devDependencies 差在哪裡?A ： dependencies：你用了什麼套件 | devDependencies：你只有在開發或測試的時候需要的套件 Q ： NPM中，有无–save的区别？A ： 不同点：无-save的话：不会将模块依赖写入devDependencies 或 dependencies 节点，并且运行 npm install 初始化项目时不会下载模块。| 有-save模块的话：会将模块依赖写入 dependencies 节点。运行 npm install 初始化项目时，会将模块下载到项目目录下。相同点：安装模块到项目 node_modules 目录下。 Q ： npm install -g moduleName 命令A ： 安装模块到全局，不会在项目 node_modules 目录中保存模块包。 Q ：@types ?A ：所以这里的建议是：查看内置类型，看看是否有与您正在寻找的类似的东西。查看节点模块本身，看看它是否已经在其中输入了类型：这会越来越普遍。如果既没有在模块内部也没有在编译器中找到类型，那么看看@types那里是否有一些好的类型。 （https://blog.angular-university.io/typescript-2-type-system-how-do-type-definitions-work-in-npm-when-to-use-types-and-why-what-are-compiler-opt-in-types/） 四、文档结构第一层组件main.tsx 第二层组件App.tsx 第三层组件路由 : “/“ | 组件 : NoteList | 功能：首页，可以通过Title或者Tag对文章进行搜索，可以创建文章。路由 : “new” | 组件 : NewNote路由 : “/:id” | 组件 : NoteLayout -&gt; Note 子路由 : “edit” | 组件 : EditNote路由 : “*” | 组件 : Navigate to “/“","link":"/2023/01/02/advanced-ReactTs-project/"},{"title":"Vue中nextTick详解","text":"this.message=’changed’就是更新DOM，更新DOM也是框架内部使用vm.nextTick来注册到微任务，所以先写this.message,再写this.nextTick来注册自己的回调函数，就会使得自己的回调函数在更新DOM之后执行。 123456789101112methods:{example:function(){ //修改数据 this.message='changed'//此时dom还没有跟新，不能获取新的数据 this.$nextTick(function(){ //dom现在跟新了 //可以获取新的dom数据，执行操作 this.doSomeThing() }) }} Vue里的异步事件队列用法：Vue.nextTick([callback,context])； 参数说明： ```arduino{Function} [callback]：回调函数，不传时提供promise调用；复制代码1232. ```css {Object} [context]：回调函数执行的上下文环境，不传默认是自动绑定到调用它的实例上； 注意：isNative检查value是否是一个原生函数。 场景：当我们使用vue操作更新dom后，需要对新的dom做一些操作时，但是这个时候，我们往往会获取不到更新后的DOM，因为这个时候，dom还没有重新渲染，所以我们就要使用vm.$nextTick方法。 用法：nextTick接受一个回调函数作为参数，它的作用将回调延迟到下次DOM跟新周期之后执行。 123456789101112methods:{example:function(){ //修改数据 this.message='changed'//此时dom还没有跟新，不能获取新的数据 this.$nextTick(function(){ //dom现在跟新了 //可以获取新的dom数据，执行操作 this.doSomeThing() }) }} DOM更新周期：在Vue当中，当视图状态发生变化时，watcher会得到通知，然后触发虚拟DOM的渲染流程，渲染这个操作不是同步的，是异步的。Vue中有一个队列，每当渲染时，会将watcher推送这个队列，在下一次事件循环中，让watcher触发渲染流程。 使用异步队列的目的：提升效率。Vue2.0使用虚拟DOM来进行渲染，变化侦测的通知只发送到组件上，组件上的任意一个变化都会通知到一个watcher上，然后虚拟DOM会对整个组件进行对比（Diff算法），然后更新DOM。如果在同一轮事件循环中有两个数据发生变化，那么组件watcher会收到两次通知，从而进行两次渲染（同步更新也是两次渲染），事实上不需要渲染那么多次，只需要等所有状态都修改完毕后，一次性将整个组件的DOM渲染到最新即可。 如何做到一次事件循环更新所有组件多次状态改变：将收到的watcher实例加入队列里缓存起来，并且再添加队列之前检查这个队列是否已存在相同watcher。不存在时，才能将watcher实例添加到队列中。然后再下一次事件循环中，Vue会让这个队列中的watcher触发渲染并清空队列。这样就保证一次事件循环组件多次状态改变只需要一次渲染更新。 什么是事件循环：一门单线程非阻塞的脚本语言，执行js代码，只有一个主线程来处理所有任务。非阻塞是指当代代码需要处理异步任务时，主线程会挂起（pending），当异步任务处理完毕，主线程根据一定的规则去执行回调。事实上，当任务执行完毕，js会将这事件加入一个队列（事件队列）。被放入队列中的事件不会立刻执行其回调，而是当前执行栈中所有任务执行完毕后，主线程会去查找事件队列中是否有任务。异步任务有两种类型，微任务和宏任务。不同类型的任务会被分配到不同的任务队列中。执行栈中所有任务执行完毕后，主线程会去查找事件队列中是否有任务，如果存在，依次执行所有队列中的回调，直到为空，然后再去宏任务队列取出一个事件，把对应的回调加入当前执行栈，当前执行栈中所有任务都执行完毕，检查微任务队列是否有事件。无限循环，叫做事件循环。 ⚠️注意：在事件循环中，必须当微任务队列中的事件都执行完之后，才会从宏任务队列中取出一个事件执行下一轮，所以添加到微任务队列中的任务的执行时间优先于宏任务队列中添加的任务。 具体实现由于vm.$nextTick会将回调 添加到任务队列中延迟执行，所以在回调执行前，如果反复调用vm.$nextTick，Vue.js并不会反复将回调添加到任务队列中，只会向任务队列中添加一个任务。此外，Vue.js内部有一个列表用来存储vm.$nextTick参数中提供的回调。在一轮事件循环中，vm.$nextTick只会向任务队列中添加一个任务，多次使用vm.$nextTick只会将回调添加到回调列表中缓存起来。当任务触发时，依次执行列表中的所有回调并清空列表。其代码如下： 123456789101112131415161718192021222324252627282930313233const callbacks = []let pending = falsefunction flushCallbacks () { pending = false const copies = callbacks.slice(0) callbacks.length = 0 for (let i = 0; i &lt; copies.length; i++) { copies[i]() }}let microTimerFuncconst p = Promise.resolve()microTimerFunc = () =&gt; { p.then(flushCallbacks)}export function nextTick(cb, ctx) { callback.push(() =&gt; { if(cb) { cb.call(ctx) } }) if(!pending) { pending = true microTimerFunc() }}// 测试一下nextTick(function() { console.log(this.name) // Berwin}, {name: 'Berwin'}) ​ 在上面代码中，我们通过数组callbacks来存储用户注册的回调，声明了变量pending来标记是否已经向任务队列中添加了一个任务。每当向任务队列中插入任务时，将pending设置为true，每当任务被执行时将pending设置为false，这样就可以通过pending的值来判断是否需要向任务队列中添加任务。 ​ 上面我们还声明了flushCallbacks，它就是我们所说的被注册的那个任务。当这个函数被触发时，会将callbacks中的所有函数依次执行，然后清空callbacks，并将pending设置为false。也就是说，一轮事件循环中flushCallbacks只会执行一次。 ​ 上面我们还声明了microTimerFunc函数，它的作用是使用Promise.then将flushCallbacks添加到微任务队列中。 ​ 上面的准备工作完成后，当我们执行nextTick函数注册回调时，首先将回调函数添加到callbacks中，然后使用pending判断是否需要向任务队列中新增任务。 ​ 下面我们从执行的角度回顾nextTick的流程。首先，当nextTick被调用时，会将回调函数添加到callbacks中。如果此时是本轮事件循环第一次使用nextTick，那么需要向任务队列中添加任务。因此，我们使用microTimerFunc函数封装promise.then的作用就是将任务添加到微任务队列中。如果不是本轮事件循环中第一次调用nextTick，也就是说，此时任务队列中已经添加了一个执行回调列表的任务，那么我们就不需要执行microTimerFunc向任务队列中添加重复的任务，因为被添加到任务队列中的任务只需要执行一次，就可以将本轮事件循环中使用nextTick方法注册的回调都依次执行一遍。 ​ 下面是nextTick的内部注册流程和执行流程。 ​ nextTick -&gt; 将回调添加到callbacks中 -&gt; 本轮事件循环中是否第一次使用nextTick？ ​ 是 -》 向任务队列中添加任务 〉结束 ​ 否 -》结束 ​ 任务被执行 -〉依次执行callbacks中的所有回调 -》 清空callbacks 在Vue.js 2.4版本之前，nextTick方法在任何地方都使用微任务，但是微任务的优先级太高，在某些场景下可能会出现问题。所以Vue.js提供了在特殊场合下可以强制使用宏任务的方法。具体实现如下： 考虑某些场景，将回调函数设置为宏任务12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849const callbacks = []let pending = falsefunction flushCallbacks () { pending = false const copies = callbacks.slice(0) callbacks.length = 0 for(let i = 0; i &lt; copies.length; i++) { copies[i]() }}let microTimerFunclet macroTimerFunc = function() {...}// 新增代码let useMacroTask = falseconst p = Promise.resolve()microTimerFunc = () =&gt; { p.then(flushCallbacks)}// 新增代码export function withMacroTask(fn) { return fn._withTask || (fn._withTask = function() { useMacroTask = true const res = fn.apply(null, arguments) useMacroTask = false return res })}export function nextTick (cb, ctx) { callbacks.push(() =&gt; { if (cb) { cb.call(ctx) } }) if (!pending) { pending = true // 修改代码 if(useMacroTask) { macroTimerFunc() } else { microTimerFunc() } }} ​ 在上述代码中，新增了withMacroTask函数，它的作用是给回调函数做一层包装，保证在整个回调函数执行过程中，如果修改了状态（数据），那么更新DOM的操作会被推倒宏任务队列中。也就是说，更新DOM的执行时间会晚于回调函数的执行时间。 ​ 下面用点击事件举例。假设点击事件的回调使用了withMacroTask进行包装，那么在点击事件被触发时，如果回调中修改了数据，那么这个修改数据的操作所触发的更新DOM的操作会被添加到宏任务队列中。因为我们在nextTick中新增了判断语句，当useMacroTask为true时，则使用macroTimerFunc注册事件。 ​ 简单来说，被withMacroTask包裹的函数所使用的所有vm.nextTick方法都会将回调添加到宏任务队列中，其中包括状态被修改后触发的更新DOM的回调和用户自己使用vm.nextTick注册的回调等。 ​ 接下来，介绍macroTimerFunc时如何将回调函数添加到宏任务队列中的。 ​ 前面我们介绍过几种属于宏任务的事件，Vue.js优先使用setImmediate，但是它存在兼容性问题，只能在IE中使用，所以使用MessageChannel作为备选方案。如果浏览器也不支持MessageChannel，那么最后会使用setTimeout来将回调添加到宏任务队列中。 设置宏任务的方法12345678910111213141516if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) { macroTImerFunc = () =&gt; { setImmediate(flushCallbacks) }} else if (typeof MessageChannel !== 'undefined' &amp;&amp; (isNative(MessageChannel) || MessageChannel.toString() === '[object MessageChannelConstructor]')) { const channel = new MessageChannel() const port = channel.port2 channel port1.onmessage = flushCallbacks macroTimerFunc = () =&gt; { port.postMessage(1) }} else { macroTimerFunc = () =&gt; { setTimeout(flushCallbacks, 0) }} 可以看到，macroTimerFunc被执行时，会将flushCallbacks添加到宏任务队列中。 前面提到microTimerFunc的实现原理是使用Promise.then, 但并不是所有浏览器都支持Promise，当不支持时，会降级成macroTimerFunc。其实实现方式如下： 12345678if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) { const p = Promise.resolve() microTimerFunc = () =&gt; { p.then(flushCallbacks) }} else { microTimerFunc = macroTimerFunc} 首先判断浏览器是否支持Promise，然后进行相应的处理即可。 官方文档中有这样一句话：如果没有提供回调且在支持Promise的环境中，则返回一个Promise。也就是说，可以这样使用vm.$nextTick: 123this.$nextTick(),then(function(){ // DOM 更新了}) 要实现这个功能，我们只需要在nextTick中进行判断，如果没有提供回调且当前环境支持Promise，那么返回Promise，并且在callbacks中添加一个函数，当这个函数执行时，执行Promise的resolve即可，代码如下： 针对不支持Promise浏览器和支持Promise浏览器做的兼容处理12345678910111213141516171819202122232425export function nextTick (cb, ctx) { // 新增代码 let _resolve callbacks.push(() =&gt; { if (cb) { cb.call(ctx) } else if (_resolve) { // 新增代码 _resolve(ctx) } }) if (!pending) { pending = true if (useMacroTask) { macroTimerFunc() } else { microTimerFunc() } } // 新增代码 if (!cb &amp;&amp; typeof Promise !== 'undefined') { return new Promise (resolve =&gt; { _resolve = resolve }) }} ​ 在上面的代码中，先在函数作用域中声明了_resolve，然后进行相应的处理。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879const callbacks = [] // 存储用户注册的回调let pending = false // 声明了pending来标记是否已经向任务队列中添加了一个任务function flushCallbacks () { pending = false // 每当任务被执行时将pending设置为false const copies = callbacks.slice(0) callbacks.length = 0 for(let i = 0; i &lt; copies.length; i++) { copies[i]() }}let microTimerFunclet macroTimerFunc let useMacroTask = false// 宏任务的处理if (typeof setImmediate !== 'undefined' &amp;&amp; isNative(setImmediate)) { macroTImerFunc = () =&gt; { setImmediate(flushCallbacks) }} else if (typeof MessageChannel !== 'undefined' &amp;&amp; (isNative(MessageChannel) || MessageChannel.toString() === '[object MessageChannelConstructor]')) { const channel = new MessageChannel() const port = channel.port2 channel port1.onmessage = flushCallbacks macroTimerFunc = () =&gt; { port.postMessage(1) }} else { macroTimerFunc = () =&gt; { setTimeout(flushCallbacks, 0) }}// Promise有效时if (typeof Promise !== 'undefined' &amp;&amp; isNative(Promise)) { const p = Promise.resolve() microTimerFunc = () =&gt; { p.then(flushCallbacks) }} else { microTimerFunc = macroTimerFunc}// export function withMacroTask(fn) { return fn._withTask || (fn._withTask = function() { useMacroTask = true const res = fn.apply(null, arguments) useMacroTask = false return res })}export function nextTick (cb, ctx) { // 新增代码 let _resolve callbacks.push(() =&gt; { // 调用nextTick，就会将cb回调函数添加到callbacks中 if (cb) { cb.call(ctx) } else if (_resolve) { // 新增代码 _resolve(ctx) } }) if (!pending) { // 如果是本轮事件第一次使用nextTick，就需要向任务队列添加任务 pending = true // 每当向任务队列插入任务时，将pending设置为true if (useMacroTask) { macroTimerFunc() } else { microTimerFunc() // 将flushCallbacks任务添加到微任务队列中 } } // 新增代码 if (!cb &amp;&amp; typeof Promise !== 'undefined') { return new Promise (resolve =&gt; { _resolve = resolve }) }}","link":"/2022/12/13/nextTick-vue/"},{"title":"前端常问八股","text":"根据我简历而常问的八股 MVPMVVM把View和Model的同步逻辑自动化了。MVP是手动去同步View和Model，MVVM则将数据绑定功能交给了框架。 MVC -&gt; MVP -&gt; MVVM MVVMMVVM是Model-ViewModel-View。Model是数据层，View是视图层，把Model和View关联起来就是ViewModel。ViewModel负责把Model的数据同步到View显示出来，还负责把View的修改同步回Model。 MVVM框架就是让我们不用关系Dom结构，只关心数据如何存储，而是通过修改数据就能直接修改Dom里的数据，从而实现修改Model层可以直接对视图层进行更新。 一般在Model层把数据通过对象来存储，然后在dom层通过【对象.属性】的方式来展示。 Flex布局任何一个容器都可以指定为Flex布局 123.box{ display: flex;} 注意，设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效。 123456flex-direction 决定主轴方向 row | row-reverse | column | column-reverse;flex-wrap 决定是否换行 nowrap不换行 | wrap换行;flex-flow 以上两个属性的合体 &lt;flex-direction&gt; || &lt;flex-wrap&gt;;justify-content 主轴上的对齐方式 flex-start | center | flex-end | space-between两端对齐，项目之间的间隔都相等align-items 属性定义项目在交叉轴上如何对齐。flex-start | flex-end | center | baseline | stretch;align-content ： 属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。 六个项目属性 Order : 属性定义项目的排列顺序。数值越小，排列越靠前，默认为0. 123.item { order : &lt;integer&gt;;} Flex-grow : 属性定义项目的方法比例，默认为0，即如果存在剩余空间，也不放大。定义每个模块所占总面积的比例是多少。 123.item { flex-grow: &lt;number&gt;; /*default 0*/} Flex-shrink :属性定义了项目的缩小比例，这里是比例越小，面积越大，上面的属性是比例越大，面积越大。 123.item { flex-shrink: &lt;number&gt;; /* default 1 */} Flex-basis ：属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否多余空间。它的默认值为auto，即项目的本来大小。 它可以设为跟width或height属性一样的值（比如350px）。则项目将占据固定空间。 123.item { flex-basis: &lt;length&gt; | auto;} Flex : 是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。 123.item { flex : none;} 该属性有两个快捷值：auto (1 1 auto) 和 none (0 0 auto)。 建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。 Flex布局设置水平居中12345.box { display: flex; justify-content: center; 水平对齐 align-items: center; 垂直居中} 闭包闭包 (closure) 是一个函数以及其捆绑的周边环境状态 (lexical environment, 词法环境)的引用的组合。换而言之，闭包让开发者可以从内部函数访问外部函数的作用域。在JavaScript中，闭包会随着函数的创建而被同时创建。 闭包的作用闭包很有用，因为它允许将函数与其所操作的某些数据（环境）关联起来。 比如 12345678910body { font-family : Helvetica, Arial, sans-serif; font-size : 12px;}h1 { font-size : 1.5em;}h2 { font-size : 1.2em;} 12345678function makeSizer(size) { return function() { document.body.style.fontSize = size + 'px'; };}var size12 = makeSizer(12);var size14 = makeSizer(14);var size16 = makeSizer(16); 123document.getElementById('size-12').onclick = size12;document.getElementById('size-14').onclick = size14;document.getElementById('size-16').onclick = size16; 用闭包模拟私有方法（这种方式使用闭包，提供了许多与面向对象编程相关的好处 —— 特别是数据隐藏和封装。） Java支持将方法声明为私有的，即她们只能被同一个类中的其他方法所调用。 而JavaScript没有这种支持，我们可以使用闭包来模拟私有方法。私有方法不仅仅有利于限制对代码的访问：还提供了管理全局命名空间的强大能力，避免非核心的方法弄乱了代码的公共接口部分。 使用闭包来定义公共函数，并令其可以访问私有函数和变量。这个方式也称为模块模式（Module Pattern） 模块模式：用一个对象的不同属性来保存相关的方法，然后把这个对象返回。 123456789101112131415161718192021222324var Counter = (function(){ var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment : function() { changeBy(1); }, decrement: function() { changeBy(-1); } value : function() { return privateCounter; } }})(); // 立即执行函数console.log(Counter.value()); /* logs 0 */Counter.increment();Counter.increment();console.log(Counter.value()); /* logs 2 */Counter.decrement();console.log(Counter.value()); /* logs 1 */ 三个共享函数 ： Counter.increment, Counter.decrement 和 Counter.value。 一个立即执行函数，两个私有项 : privateCounter 和 changeBy 的函数。这两项无法在这个匿名函数外部直接访问。 备注： 你应该注意到我们定义了一个匿名函数，用于创建一个计数器。我们立即执行了这个匿名函数，并将他的值赋给了变量Counter。我们可以把这个函数储存在另外一个变量makeCounter中，并用他来创建多个计数器。 12345678910111213141516171819202122232425var makeCounter = (function(){ var privateCounter = 0; function changeBy(val) { privateCounter += val; } return { increment: function() { changeBy(1); }, decrement: function() { changeBy(-1); }, value : function() { return privateCounter; } }}) // 不立即执行了，等创建的时候再执行。var Counter1 = makeCounter();var Counter2 = makeCounter();console.log(Counter1.value());Counter1.increment();Counter1.increment();console.log(Counter1.value());console.log(Counter2.value()); 两个计数器Counter1和Counter2是如何维护它们各自的独立性。每个闭包都是引用自己词法作用域内的变量privateCounter。 在一个闭包内对变量的修改，不会影响到另外一个闭包中的变量。 在循环中创建闭包：一个常见错误在 ECMAScript 2015 引入 let 关键字 之前，在循环中有一个常见的闭包创建问题。 1234&lt;p id=&quot;help&quot;&gt;Helpful notes will appear here&lt;/p&gt;&lt;p&gt;E-mail: &lt;input type=&quot;text&quot; id=&quot;email&quot; name=&quot;email&quot;&gt;&lt;/p&gt;&lt;p&gt;Name: &lt;input type=&quot;text&quot; id=&quot;name&quot; name=&quot;name&quot;&gt;&lt;/p&gt;&lt;p&gt;Age: &lt;input type=&quot;text&quot; id=&quot;age&quot; name=&quot;age&quot;&gt;&lt;/p&gt; 1234567891011121314151617181920function showHelp(help) { document.getElementById('help').innerHTML = help;}function setupHelp() { var helpText = [ {'id': 'email', 'help': 'Your e-mail address'}, {'id': 'name', 'help': 'Your full name'}, {'id': 'age', 'help': 'Your age (you must be over 16)'} ]; for (var i = 0; i &lt; helpText.length; i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); } }}setupHelp(); 运行这段代码后，您会发现它没有达到想要的效果。无论焦点在哪个 input 上，显示的都是关于年龄的信息。 原因是赋值给 onfocus 的是闭包。这些闭包是由他们的函数定义和在 setupHelp 作用域中捕获的环境所组成的。这三个闭包在循环中被创建，但他们共享了同一个词法作用域，在这个作用域中存在一个变量 item。这是因为变量 item 使用 var 进行声明，由于变量提升，所以具有函数作用域。当 onfocus 的回调执行时，item.help 的值被决定。由于循环在事件触发之前早已执行完毕，变量对象 item（被三个闭包所共享）已经指向了 helpText 的最后一项。 解决方案：解决这个问题的一种方案是使用更多的闭包：特别是使用前面所述的函数工厂： 123456789101112131415161718192021function showHelp(help) { document.getElementById('help').innerHTML = help;}function makeHelpCallback(help) { return function() { showHelp(help); };}function setupHelp() { var helpText = [ {'id': 'email', 'help': 'Your e-mail address'}, {'id': 'name', 'help': 'Your full name'}, {'id': 'age', 'help': 'Your age (you must be over 16)'} ]; for (var i = 0; i &lt; helpText.length;i++) { var item = helpText[i]; document.getElementById(item.id).onfocus = makeHelpCallback(item.help); }}setupHelp(); 这段代码可以如我们所期望的那样工作。所有的回调不再共享同一个环境，makeHelpCallback函数为每一个回调创建一个新的词法环境。在这些环境中，help指向helpText数组中对应的字符串。 另一种方法使用了匿名闭包： 12345678910111213141516171819function showHelp(help) { document.getElementById('help').innerHTML = help;}function setupHelp() { var helpText = [ {'id': 'email', 'help': 'Your e-mail address'}, {'id': 'name', 'help': 'Your full name'}, {'id': 'age', 'help': 'Your age (you must be over 16)'} ]; for (var i = 0; i &lt; helpText.length; i++) { (function(){ var item = helpText[i]; document.getElementById(item.id).onfocus = function() { showHelp(item.help); } })(); // 马上把当前循环项的 item与事件回调相关联起来 }} 如果不想使用过多的闭包，你可以用 ES2015 引入的 let 或 const 关键词： 1234567891011121314151617181920function showHelp(help) { document.getElementById('help').textContent = help;}function setupHelp() { const helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' }, ]; for (let i = 0; i &lt; helpText.length; i++) { const item = helpText[i]; document.getElementById(item.id).onfocus = () =&gt; { showHelp(item.help); }; }}setupHelp(); 这个例子使用 const 而不是 var，因此每个闭包都绑定了块作用域的变量，这意味着不再需要额外的闭包。 另一个可选方案是使用 forEach() 来遍历 helpText 数组并给每一个 `` 添加一个监听器，如下所示： 12345678910111213141516171819function showHelp(help) { document.getElementById('help').textContent = help;}function setupHelp() { var helpText = [ { id: 'email', help: 'Your e-mail address' }, { id: 'name', help: 'Your full name' }, { id: 'age', help: 'Your age (you must be over 16)' }, ]; helpText.forEach(function (text) { document.getElementById(text.id).onfocus = function () { showHelp(text.help); }; });}setupHelp(); 性能考量如果不是某些特定任务需要使用闭包，在其它函数中创建函数是不明智的，因为闭包在处理速度和内存消耗方面对脚本性能具有负面影响。 例如，在创建新的对象或者类时，方法通常应该关联于对象的原型，而不是定义到对象的构造器中。原因是这将导致每次构造器被调用时，方法都会被重新赋值一次（也就是说，对于每个对象的创建，方法都会被重新赋值）。 1234567891011function MyObject(name, message) { this.name = name.toString(); this.message = message.toString(); this.getName = function() { return this.name; }; this.getMessage = function() { return this.message; };} 在上面的代码中，我们并没有利用到闭包的好处，因此可以避免使用闭包。修改成如下： 123456789101112function MyObject(name, message) { this.name = name.toString(); this.message = message.toString();}MyObject.prototype = { getName() { return this.name; }, getMessage() { return this.message; }}; 但我们不建议重新定义原型。可改成如下例子： 12345678910function MyObject(name, message) { this.name = name.toString(); this.message = message.toString();} MyObject.prototype.name = function() { return this.name; }; MyObject.prototype.message = function() { return this.message; } 在前面的两个示例中，继承的原型可以为所有对象共享，不必在每一次创建对象时定义方法。 一般，我们将所有对象都需要的方法放到原型中，把对象实例自身特有的属性和方法放到实例对象中。 变量提升（Hoisting）变量和函数声明在代码里的位置不会动，而是在编译阶段被放入内存中。 优点：在执行任何代码段之前，将函数声明放入内存中的优点之一是，你可以声明一个函数之前使用该函数。 函数会比变量更加优先。 只有声明被提升JavaScript只会提升声明，不会提升其初始化。如果一个变量先被使用再被声明和赋值的话，使用时的值是undefined。 12345678910111213141516// Example 1 - only y is hoistedvar x = 1; // 声明 + 初始化 xconsole.log(x + &quot; &quot; + y); // '1 undefined'var y = 2; // 声明 + 初始化 y// Example 2 - Hoistsvar num1 = 3; // Declare and initialize num1num2 = 4; // Initialize num2console.log(num1 + &quot; &quot; + num2); //'3 4'var num2; // Declare num2 for hoisting// Example 3 - Hoistsa = 'Cran'; // Initialize ab = 'berry'; // Initialize bconsole.log(a + &quot;&quot; + b); // 'Cranberry'var a, b; // Declare both a &amp; b for hoisting [1]: https://developer.mozilla.org/zh-CN/docs/Glossary/Hoisting “Hoisting（变量提升）” 暂时性死区（TDZ）TDZ ： Temporal Dead Zone ： 对于某些遇到在区块作用域绑定早于声明语句时的状况时，所使用的专用术语。 let/const 是使用区块作用域；var 是使用函数作用域 在let/const 声明之前就访问对应的变量与常量，会抛出ReferenceError错误；但在var声明之前就访问对应的变量，则会得到undefined。 在使用let声明之前，都属于暂时性死区。 let只能声明一次，并且不具有变量提升。 for循环里的var和let123for(var i = 0; i &lt; 5; i++) { setTimeout(()=&gt;console.log(i),0) // 5 5 5 5 5 } setTimeout是一个异步，所以它拿到的是循环结束后的i值，因为上面我们说的var是全局变量会被覆盖掉，所以最后的i值是5。 因为let有自己的作用域块，所以在for循环表达式中使用let其实就等价于在代码块中使用let，也就是说 for( let i = 0; i&lt; 5; i++) 这句话的圆括号之间，有一个隐藏的作用域 for( let i = 0; i&lt; 5; i++) { 循环体 } 在每次执行循环体之前，JS 引擎会把 i 在循环体的上下文中重新声明及初始化一次。 vue生命周期常见的微任务 Promise.then Object.observe MutationObserver Process.nextTick 常见的宏任务 setTimeout setInterval setImmediate UI交互事件 requestAnimationFrame MessageChannel 请求数据放在哪created：在实例创建完成后被立即调用，此时已完成以下的配置：数据观测 (data observer)，property 和方法的运算，watch/event 事件回调。然而，挂载阶段还没开始，$el property 目前尚不可用，也就是可以使用数据，更改数据，在这里更改数据不会触发updated函数。 可以做什么： data 和 methods 都已经被初始化好了，如果要调用 methods 中的方法，或者操作 data 中的数据，最早可以在这个阶段中操作。 无法与Dom进行交互，如果非要想，可以通过vm.$nextTick来访问Dom。 异步数据的请求适合在 created 的钩子中使用，例如数据初始化。 mounted：在挂载完成后发生，此时真实的Dom挂载完毕，数据完成双向绑定，可以访问到Dom节点，使用$refs属性对Dom进行操作。「注意」：mounted 不会保证所有的子组件也都一起被挂载。如果你希望等到整个视图都渲染完毕，可以在 mounted 内部使用 vm.$nextTick。 结论：数据多放mount，数据少放create nextTick接受一个回调函数作为参数，它的作用将回调延迟到下次DOM跟新周期之后执行。 如何监听异常Vue2和Vue3的区别CSS3有哪些从输入url发生什么基本数据类型Position","link":"/2022/11/23/Little-Eight-Pigu/"},{"title":"前端优化 - 记录","text":"前端一些优化技巧。 React优化 - 代码拆分原理：代码拆分仅在需要时下载所需的代码来最小化应用程序的包大小，不然所有文件都在第一次全部下载下来，而是点到对应页面时才去下载，减轻第一次下载的压力。 方法：react里的lazy, 然后使用Suspense和useTransition来做加载过度。还有就是把需要的函数写成外部js文件，然后在引入。 引用 [1]: https://www.bilibili.com/video/BV1ie411P7vA/?spm_id_from=333.1007.top_right_bar_window_dynamic.content.click&amp;vd_source=fbd4f8d461608ccdb48848636dfd3b77 “通过代码拆分加速你的 React 应用程序”[2]: https://www.youtube.com/watch?v=JU6sl_yyZqs “Speed Up Your React Apps With Code Splitting” CSS优化 - 合理使用CSS选择器原理：CSS选择器的匹配是从右向左进行的，这一策略导致了不同的选择器之间的性能也存在差异。 样例：相比于.content-title-span，使用.content .title span时，浏览器计算样式所要花费的时间更多。使用后面一种规则，浏览器必须遍历页面上所有 span 元素，先过滤掉祖先元素不是.title的，再过滤掉.title的祖先不是.content的。嵌套的层级更多，匹配所要花费的时间代价自然更高。 方法： 1、避免使用通配符，只对需要用到的元素进行选择。 2、关注可以通过继承实现的属性，避免重复匹配重复定义。 3、减少嵌套。后代选择器的开销是最高的，因此我们应该尽量将选择器的深度降到最低（最好不要超过三层），可以使用BEM风格的class来关联元素。 4、减少使用标签选择器和属性选择器。 5、不要使用class选择器和id选择器修饰元素标签，如h3.title,这样多此一举，还会降低效率，直接使用.title现代浏览器在这一方面做了很多优化，不同选择器的性能差别不是特别明显，不过知道总比不知道强。 DOM操作 - 减少原理：JS引擎和渲染引擎是两个独立的线程。当我们用JS去操作DOM时，本质上是JS引擎和渲染引擎之间进行了“跨界交流”，交流依赖了桥接接口作为“桥梁”。我们每操作一次DOM（不管是为了修改还是仅仅为了访问其值），都要过一次桥，每次过桥都有一定开销。因此，过桥的次数一多，就会产生比较明显的性能问题。 方法： 1、缓存访问过的元素。 12345// 只获取一次container，并缓存let container = document.getElementById('container')for(let count=0;count&lt;10000;count++){ container.innerHTML += '&lt;span&gt;我是一个小测试&lt;/span&gt;'} 2、避免频繁修改DOM，尽量一次更新。上面虽然缓存了访问元素，但在每一次循环里都修改了DOM。对DOM的修改会引发渲染树的改变，进而导致回流。我们可以将对DOM的修改累计起来，然后一次性地应用到DOM上。对于页面中多个元素节点的修改，可以借助DocumentFragment完成，具体参考 [1]: https://developer.mozilla.org/zh-CN/docs/Web/API/DocumentFragment “DocumentFragment” 123456789// 只获取一次containerlet container = document.getElementById('container')let content = ''for(let count=0;count&lt;10000;count++){ // 累计对DOM的修改操作 content += '&lt;span&gt;我是一个小测试&lt;/span&gt;'} // 将累计的修改操作一次性地应用到 DOMcontainer.innerHTML = content 3、前端框架，Vue，React等，是通过虚拟节点（Virtual DOM）来搜索更新，然后一次性更新DOM。 4、事件委托 假如有一个很长的列表，点击每个列表项的时候需要响应事件； 12345&lt;ul class=&quot;parent&quot;&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; ...&lt;/ul&gt; 如果给每个列表项一一绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能； 比较好的方法就是用事件委托，把这个点击事件绑定到他的父层，也就是ul上，然后在执行事件的时候再去匹配判断目标元素； 12345678// 给父层元素绑定事件document.querySelector('.parent').addEventListener('click', (event) =&gt; { var target = event.target // 判断是否匹配目标元素 if (target.nodeName.toLocaleLowerCase === 'li') { console.log(target.innerHTML + ' clicked'); }}); 事件委托的好处： 1、只绑定一个事件函数，可以减少大量的内存消耗，并且减少了dom操作，提高性能。 2、动态元素绑定事件，通过AJAX或者用户交互动态的增加或者去除li元素，在每一次改变的时候都需要重新给新增的元素绑定事件，给将要删除的元素解绑事件，使用了事件委托可以省去这些麻烦，因为事件是绑定在ul上，和li的增减没有关系。 节流和防抖事件节流 简单来说，就是从一个时间点开始，在某段时间，无论触发了多少次回调，我都只认第一次，并在计时结束时给予响应。 以scroll事件为例，当用户滚动页面触发了一次scroll事件后，就为这个触发操作开启一个固定时间的计时器。在这个计时器持续时间内，限制后续发生的所有scroll事件对回调函数的触发，当计时器计时结束后，响应执行第一次触发scroll事件的回调函数。 123456789101112131415161718192021222324// interval是时间间隔的阈值, fn是我们需要包装的事件回调function throttle(interval,fn){ //上次触发回调的时间 let lastTime = 0 //事件节流操作的闭包返回 return (params) =&gt; { //记录本次回调触发的时间 let now = +new Date() //判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值，若不小于，则执行回调 if(now - lastTime &gt;= interval){ lastTime = now fn(params) } }}//通过事件节流优化事件回调函数const throttle_scroll = throttle(1000, () =&gt; console.log('页面滚动'))//绑定事件document.addEventListener('scroll', throttle_scroll) 事件防抖 只响应最后一次触发事件。在一定时间内，不管事件触发了多少次，都只认最后一次。假设设置时间为 1000ms，第一次触发这个事件时会启动一个定时器，后面每次触发这个事件都会清除已有定时器，并重新设置新的定时器，起点为最近一次触发的这个时间。 123456789101112131415161718192021function debounce(time,fn){ //设置定时器 let timer = null //事件防抖的闭包操作 return (params) =&gt; { //每次事件被触发时，都去清除之前的旧定时器 if(timer) clearTimeout(timer) //设置新的定时器 timer = setTimeout(() =&gt; fn(params), time) }}//通过事件防抖优化事件回调函数const debounce_scroll = debounce(1000, () =&gt; console.log('页面滚动'))//绑定事件document.addEventListener('scroll', debounce_scroll) 回流、重绘回流：当我们对DOM的修改引发了DOM几何尺寸的变化，比如修改元素的宽，高或隐藏元素等，浏览器需要重新计算元素的几何属性进行布局，然后再将计算结果绘制出来。这个过程就是回流（也叫重排或页面布局） 重绘：当DOM需要更新属性，而这些属性只是影响其外观，风格，并不会影响布局，比如只修改了颜色或背景色，浏览器不需重新计算元素的几何属性，直接为该元素绘制新的样式。这个过程叫做重绘。 重绘不一定导致回流，回流一定会导致重绘。回流比重绘的代价要更高。那么哪些操作可能触发回流呢？ 触发回流的操作： 1、改变DOM元素的几何属性，这些属性包括width、height、padding、margin、left、top等。 2、改变DOM树的结构。节点的增减、移动等操作。 这都可以在写样式的时候显式地通过代码效果看出来。对于上面触发面流的操作，浏览器自身也做了优化。浏览器会维护一个队列，把所有会引起回流，重绘的操作放入这个队列，等队列中的操作达到一个阈值或者到了一定的时间间隔，浏览器就会flush队列，进行一个批处理。这样就会让多次的回流/重绘变成一次回流/重绘。但是当你获取某些特定地属性值或者调用某些方法时，浏览器会立刻清空队列。 3、获取下面这些属性值或者调用方法。这些属性和方法有一个共性，就是需要通过即时计算得到，所以浏览器需要立刻重新进行布局计算。 1234offsetTop、offsetLeft、 offsetWidth、offsetHeightscrollTop、scrollLeft、scrollWidth、scrollHeightclientTop、clientLeft、clientWidth、clientHeightscrollIntoView()、getComputedStyle()、getBoundingClientRect()、scrollTo() 方法： 1、浏览器自身提供的方法 - 将回流，重绘操作放到队列里，到达一个时间就批处理。让多次的回流/重绘变成一次回流/重绘。 2、对回流、重绘最直观的优化，就是减少它的发生次数。 2.1 避免频繁改变样式。使用class或者cssText合并多次对样式的修改，然后一次更新。 1234const el = document.querySelector('.test')el.style.height = '100px'el.style.width = '200px'el.style.color = '#333' 优化后： (1) cssText 12const el = document.querySelector('.test')el.style.cssText = &quot;height:100px; width:200px; color: #333;&quot;; (2) class 12345.new-style { height:100px; width:200px; color: #333;} 12const el = document.querySelector('.test')container.classList.add('new-style') 2.2 批量修改DOM。在上面的减少DOM操作中已经写过，这里不再赘述。 2.3 避免频繁读取“敏感”属性。上文我们说过，当我们访问元素的一些属性的时候，会导致浏览器强制清空队列。 比如，我们想将一组元素的宽度赋值为某一个元素的宽度，我们可能写出这样的代码： 1234567function setWidth() { const lis = document.querySelectorAll('li') const div = document.querySelector('.test') for (let i = 0; i &lt; lis.length; i++) { lis[i].style.width = div.offsetWidth + 'px'; }} 每一次循环的时候，都读取了div的offsetWidth属性值，这就导致了，每一次循环都会强制浏览器刷新队列。作为优化，我们可以将敏感属性通过变量的形式缓存起来。 12345678const width = div.offsetWidth;function initP() { const lis = document.querySelectorAll('li') const width = document.querySelector('.test').offsetWidth for (let i = 0; i &lt; lis.length; i++) { lis[i].style.width = width + 'px'; }} 分层与合成：动画效果对于一些复杂的动画效果，比如常见的点击菜单时弹出收回菜单的动画特效，还有一些炫酷的3D动画特效，如果没有采用分层机制，会经常引起回流重绘。 关于分层的机制，我们在上面的页面渲染流程中有讲到过。一个网页可以分解很多个图层（分层），每个图层都可以单独地设置大小、位置、透明度、旋转角度等，图层的上下位置可以调整，最后将这些图层叠加在一起后（合成），就能呈现出最终的效果。 在Chrome的渲染流水线中，分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为图层树（Layer Tree），合成则是当图层的绘制列表准备好了之后，交由合成线程来完成。 对于需要动画效果的元素，可以将其创建为单独图层，比如使用绝对定位，当它发生改变，不会引起其他元素的频繁回流。 而使用css3的一些属性，可以使得动画效果不会引起回流重绘。在了解了渲染流程各部分的功能和作用后，我们知道如果一个动画的实现不经过页面布局和重绘环节，仅在合成阶段就能完成，将会大大提升性能。 符合这一要求的动画属性有：transform和opacity。它们能实现的动画效果：平移、缩放、旋转、倾斜、矩阵变换、透明度。 在使用transform和opacity实现动画效果时，尽量用 will-change 来提前告诉渲染引擎，让它为元素创建独立的层。 123.create-layer { will-change: transform, opacity;} [1]: https://juejin.cn/post/6969494172151578660#heading-14 “浏览器渲染流程和性能优化”","link":"/2022/12/14/optimize/"},{"title":"Responsive Image Design","text":"Responsive images that are in the wrong format, images that are not compressed properly, and images that are too big will all decrease the page speed and impact your SEO. According to Google, anything above 2 seconds of download time will put off your users and discourage the crawlers from indexing your website. 本文目的：快速生成适用于所有浏览器的响应式图像并且大大降低下载速度。 方法： WebP格式、picture标签、@media规则、srcset与image-set属性 响应式图片设计 Tips 如果要优化图像，则必须从具有正确格式和正确大小的高质量图像开始： 将 JPG 用于照片，将 PNG 用于需要透明度的图形或其他图像 对于颜色数量有限的图形，请使用较小的 PNG-8 而不是 PNG-24。要进一步减小尺寸，您还可以将颜色数量从 256 减少到 16 将 SVG（矢量图形图像）用于图标和徽标。它们将很好地扩展而不会增加文件的大小 使用 10KB 以下的内联图像作为 64base 编码字符串（谨慎） 图像的实际宽度不应超过将在其中显示的最大容器的宽度乘以 2（对于视网膜显示器） 硬件像素 VS 软件像素 硬件和 CSS 像素之间的关系由以下公式描述： CSS 像素 = 硬件像素 / 像素密度 比如 Macbook Pro 屏幕全宽的图像是 1440 像素宽，但视网膜显示器的实际分辨率是 2880x1800 的两倍。因为显示器的像素密度因子为 2。 放置图片的方法There are two primary ways to put an image on a website, either by using HTML’s img element or a background-image in CSS. 浏览器兼容 srcset 目前，除了 IE、Edge 和 Opera Mini 之外的大多数浏览器都srcset实现了该属性。 WebP Chrome 和 Opera 支持 WebP 格式，约占所有浏览器的 60% 。 picture 让我们将元素添加为source元素内的第一个选项picture，您的图像采用 WebP 格式，然后img指向常规 JPG 图像。现在，当浏览器不支持 WebP 时，它会优雅地回退到img元素（例如 Safari）。 image-set 目前，它在 Chrome、Android 版 Chrome、Safari、iOS Safari 和其他一些浏览器中实现。您可以添加polyfill以使其image-set在其他浏览器上工作，但鉴于 Chrome 和 Safari 组合是当今 70% 用户的首选浏览器，大多数浏览器很有可能在不久的将来实现该属性。但不用担心，background-image作为后备选项的常规选项可以解决问题。 HTML方法12345678910111213141516171819&lt;picture&gt; &lt;source media=&quot;(min-width: 900px)&quot; srcset=&quot;image-lg_1x.webp 1x, image-lg_2x.webp 2x&quot; type=&quot;image/webp&quot; /&gt; &lt;source media=&quot;(min-width: 601px)&quot; srcset=&quot;image-md_1x.webp 1x, image-md_2x.webp 2x&quot; type=&quot;image/webp&quot; /&gt; &lt;source srcset=&quot;image-sm_1x.webp 1x, image-sm_2x.webp 2x&quot; type=&quot;image/webp&quot; /&gt; &lt;img srcset=&quot;image-sm_1x.jpg 600w, image-md_1x.jpg 900w, image-lg_1x.jpg 1440w&quot; src=&quot;image_lg_1x.jpg&quot; type=&quot;image/jpeg&quot; alt=&quot;image description&quot; /&gt;&lt;/picture&gt; 1、基本 HTMLimg元素具有src指向图像 URL 的属性 2、如果要优化图像，使用srcset属性。 3、scrset属性后跟空格是像素密度，例如1x, 2x …… 4、请注意，在img元素中，srcset属性应放在src属性之前。否则，浏览器会src先下载图像，然后，如果它在 中找到更好的图像srcset，它也会下载这个图像。这样我们最终会得到两个图像。 5、img标签，当浏览器不支持scrset属性时，会回退到src属性。 6、img标签，scrset属性接受宽度单位w，相当于 CSS 像素。宽度单位使浏览器能够为给定的显示功能选择正确的图像尺寸。 7、img标签，如果想要全宽图像（full-image)，就使用sizes属性 8、img标签，如果希望600px上使用100vw，以下使用50vw，则可以添加媒体查询 1234567&lt;img srcset=&quot;image-sm.jpg 600w, image-md.jpg 900w, image-lg.jpg 1440w&quot; sizes=&quot;(max-width: 600px) 100vw, 50vw&quot; src=&quot;image_1x.jpg&quot;/&gt; 9、picture元素接受source和img元素作为子元素，我们可以使用source元素列出希望提供给浏览器的其他图像格式。 10、如果浏览器不支持webp，会回退到img元素。 CSS方法1234567891011121314151617181920212223242526272829303132333435363738394041.bg-image { width: 100vw; height: 500px; background-size: cover; background-position: center; background-image: url(/images/image-lg_1x.jpg); // 负责处理不支持该image-set属性的浏览器。 background-image: -webkit-image-set( url(/images/image-lg_1x.webp) 1x, url(/images/image-lg_2x.webp) 2x ); background-image: image-set( url(/images/image-lg_1x.jpg) 1x, url(/images/image-lg_2x.jpg) 2x ); @media (max-width: 900px) { background-image: url(/images/image-md_2x.jpg); background-image: -webkit-image-set( url(/images/image-md_1x.webp) 1x, url(/images/image-md_2x.webp) 2x ); background-image: image-set( url(/images/image-md_1x.jpg) 1x, url(/images/image-md_2x.jpg) 2x ); } @media (max-width: 600px) { background-image: url(/images/image-sm_2x.jpg); background-image: -webkit-image-set( url(/images/image-sm_1x.webp) 1x, url(/images/image-sm_2x.webp) 2x ); background-image: image-set( url(/images/image-sm_1x.jpg) 1x, url(/images/image-sm_2x.jpg) 2x ); }} 1、如果我们不知道要用图像覆盖的容器的确切高度和宽度，我们可以使用通用元素，例如指向图像 URLdiv的属性：background-image 1background-image: url(&quot;/images/image.jpg&quot;); 2、如果要优化图像，使用image-set, image-setin CSS 相当于srcsetin HTML 。 3、使用-webkit-image-set，我们需要列出不同像素密度的 WebP 图像。 4、要记住的一件重要事情是 Chrome 和 Safari 都使用 WebKit 布局引擎，但 Safari 不支持 WebP 格式。这就是为什么我们必须为image-setJPG 图像添加最后一组属性（Safari 将使用它，即使它不以 开头-webkit）。 5、备选选项必须放在优化前面(background-imageswith the image-set attribute), 否则Safari会下载两张图片。 总结CSS与HTML方法 1、HTML的备选img与CSSbackground-image一样。 2、备选是指不支持优化属性是程序员指示浏览器加载的代码，备选的图片格式一般都是jpg。 3、HTML的优化srcset与CSSimage-set一样。 4、优化就是先细分断点，再细分像素密度，再针对不同浏览器规则细分。 如何内联小图像 为了改善用户体验，我们不仅应该压缩和提供尽可能小的图像，还应该减少发送到服务器的请求数量。浏览器必须为每个图像发送单独的请求。当发送到服务器时，请求必须首先在队列中等待，这需要时间。浏览器调用的次数越多，用户等待的时间就越长。当您必须下载许多小图像时尤其如此。如果可能，应将徽标和图标保存为矢量图形 (SVG)。小图像可以作为 base64 编码字符串直接嵌入 HTML 或 CSS 中。我们可以将图像作为字符串传递，而不是将常规 URL 传递给元素中的src属性：img。 在大多数情况下，生成的字符串将比原始图像大 30% 左右，但您将节省另一次往返服务器的时间。 反对在 CSS 文件中使用 base64 编码图像的最常见论点是图像是非阻塞资源，而 CSS 文件是。这意味着如果您在 CSS 中嵌入过多的小图像，则会增加 CSS 文件的大小并延长网站第一次绘制的时间，这将使用户等待更长时间才能看到任何内容。可以观看这篇文章，不使用Base64. [Base64 Encoding &amp; Performance, Part 1: What’s Up with Base64?]: https://csswizardry.com/2017/02/base64-encoding-and-performance/ “Base64 Encoding &amp; Performance, Part 1: What’s Up with Base64?” The truth lays probably somewhere in the middle, and injecting one or two small files as base64 strings into CSS or HTML shouldn’t do any harm. 其他什么是SVG？（伸缩矢量） SVG 指可伸缩矢量图形 (Scalable Vector Graphics) SVG 用来定义用于网络的基于矢量的图形 SVG 使用 XML 格式定义图形 SVG 图像在放大或改变尺寸的情况下其图形质量不会有所损失 SVG 是万维网联盟的标准 SVG 与诸如 DOM 和 XSL 之类的 W3C 标准是一个整体 什么是PNG？（无损压缩）便携式网络图形（英语：Portable Network Graphics，PNG）是一种支持无损压缩的位图图形格式，支持索引、灰度、RGB三种颜色方案以及Alpha通道等特性。PNG的开发目标是改善并取代GIF作为适合网络传输的格式而不需专利许可，所以被广泛应用于互联网及其他方面上。 什么是JPG？（失真压缩）JPEG（ Joint Photographic Experts Group）即联合图像专家组，是用于连续色调静态图像压缩的一种标准，文件后缀名为.jpg或.jpeg，是最常用的图像文件格式。其主要是采用预测编码（DPCM）、离散余弦变换（DCT）以及熵编码的联合编码方式，以去除冗余的图像和彩色数据，属于**有损压缩**格式，它能够将图像压缩在很小的储存空间，一定程度上会造成图像数据的损伤。尤其是使用过高的压缩比例，将使最终解压缩后恢复的图像质量降低，如果追求高品质图像，则不宜采用过高的压缩比例。 Base64In computer programming, Base64 is a group of binary-to-text encoding schemes that represent binary data (more specifically, a sequence of 8-bit bytes) in sequences of 24 bits that can be represented by four 6-bit Base64 digits. Base64 是一种编码方式，最早出现在电子邮件传输协议中。电子邮件问世之初，传递消息时只支持 ASCII 字符，后来随着电子邮件的广泛使用，传递非ASCII字符内容的需求增加，例如：传输中文、传输文件（图片、视频）。为解决这一问题，最好的方案是在不改变传输协议的基础上，做一种扩展方案来支持非ASCII内容传输，把非 ASCII 字符用ASCII来表示，Base64编码应运而生。1 二、Base64定义Base64 是一种基于64个 ASCII 字符来表示二进制数据的表示方法。Base64 将8比特位为一个单元的字节数据拆分为以6个比特位为一个单元的二进制片段，每6个比特位单元对应Base64索引表中的一个字符，这样最终构成一个超过编码前字节数据33%的字符串。 Base64 中64个可打印字符包括字母A-Z、a-z、数字0-9，此外还有两个字符为+和/，这样构成了共有64字符的Base64索引表 字符串转base64的转码规则： Base64 将8比特位为一个单元的字节数据拆分为以6个比特位为一个单元的二进制片段；每6个比特位单元对应Base64索引表中的一个字符；按照以上方式可以算出base64编码后的字符串大约比编码前增加了33%。 为什么一些Base64后的字符中末尾有“==” 以上举例中：编码前字节数正好被3整除，转化为二进制ASCII 编码（ 3*8=24 ）后，正好可以被6整除。若编码前字节数不能被3整除，最后会余出1个或2个字节，那么编码时需要： 使用 000000 字节值在末尾补足，使其字节数能够被3整除； 编码时补位的6个比特位单元用 = 表示。 举例如下：编码 Lucy 的Base64结果为THVjeQ==，Base64编码计算过程如下： 123456文 本：L u c yASCII 编码：76 117 99 1218bit 字节：01001100 01110101 01100011 01111001 (补)00000000 (补)000000006bit 字节：010011 000111 010101 100011 011110 010000 000000 000000Base64索引：19 7 21 35 30 16 (补位) (补位)Base64编码：T H V j e Q = = WebP （有损/无损）WebP（发音：weppy）是一种同时提供了有损压缩与无损压缩（可逆压缩）的图片文件格式，派生自影像编码格式VP8，被认为是WebM多媒体格式的姊妹项目，是由Google在购买[On2 Technologies](https://baike.baidu.com/item/On2 Technologies?fromModule=lemma_inlink)后发展出来，以BSD授权条款发布。 WebP支持的像素最大数量是16383x16383。有损压缩的WebP仅支持8-bit的YUV 4:2:0格式。而无损压缩（可逆压缩）的WebP支持VP8L编码与8-bit之ARGB色彩空间。又无论是有损或无损压缩皆支持Alpha透明通道、ICC色彩配置、XMP诠释数据。 WebP有静态与动态两种模式。动态WebP（Animated WebP）支持有损与无损压缩、ICC色彩配置、XMP诠释数据、Alpha透明通道。 什么是media queryMedia Types Value Description all Default. Used for all media type devices print Used for printers screen Used for computer screens, tablets, smart-phones etc. speech Used for screenreaders that “reads” the page out loud Media Features Value Description any-hover Does any available input mechanism allow the user to hover over elements? (added in Media Queries Level 4) any-pointer Is any available input mechanism a pointing device, and if so, how accurate is it? (added in Media Queries Level 4) aspect-ratio The ratio between the width and the height of the viewport color The number of bits per color component for the output device color-gamut The approximate range of colors that are supported by the user agent and output device (added in Media Queries Level 4) color-index The number of colors the device can display grid Whether the device is a grid or bitmap height The viewport height hover Does the primary input mechanism allow the user to hover over elements? (added in Media Queries Level 4) inverted-colors Is the browser or underlying OS inverting colors? (added in Media Queries Level 4) light-level Current ambient light level (added in Media Queries Level 4) max-aspect-ratio The maximum ratio between the width and the height of the display area max-color The maximum number of bits per color component for the output device max-color-index The maximum number of colors the device can display max-height The maximum height of the display area, such as a browser window max-monochrome The maximum number of bits per “color” on a monochrome (greyscale) device max-resolution The maximum resolution of the device, using dpi or dpcm max-width The maximum width of the display area, such as a browser window min-aspect-ratio The minimum ratio between the width and the height of the display area min-color The minimum number of bits per color component for the output device min-color-index The minimum number of colors the device can display min-height The minimum height of the display area, such as a browser window min-monochrome The minimum number of bits per “color” on a monochrome (greyscale) device min-resolution The minimum resolution of the device, using dpi or dpcm min-width The minimum width of the display area, such as a browser window monochrome The number of bits per “color” on a monochrome (greyscale) device orientation The orientation of the viewport (landscape or portrait mode) overflow-block How does the output device handle content that overflows the viewport along the block axis (added in Media Queries Level 4) overflow-inline Can content that overflows the viewport along the inline axis be scrolled (added in Media Queries Level 4) pointer Is the primary input mechanism a pointing device, and if so, how accurate is it? (added in Media Queries Level 4) resolution The resolution of the output device, using dpi or dpcm scan The scanning process of the output device scripting Is scripting (e.g. JavaScript) available? (added in Media Queries Level 4) update How quickly can the output device modify the appearance of the content (added in Media Queries Level 4) width The viewport width More ExamplesExampleHide an element when the browser’s width is 600px wide or less: 12345@media screen and (max-width: 600px) { div.example { display: none; }} What is GatsbyGatsby 是一个基于React ，用于搭建静态站点的开源框架，用于帮助开发者构建运行速度极快的网站。 可以说它是一个静态站点生成器，Gatsby 主要的应用的技术是React 和GraphQL。 What is PageSpeedGoogle PageSpeed工具集是一組由Google提供的網站性能優化工具集。 Google於2010年的開發者大會上推出。page speed是开源Firefox、Firebug 插件，网站管理员和网络开发人员可以使用来评估他们网页的性能，并获得有关如何改进性能的建议。 如何生成响应式图像假设您刚刚保存了一张完美的图像，并且您想创建所有变体，以便您可以在您的网站上使用它。 有许多工具可以提供帮助。简单的工具包括compressjpeg.com、compresspng.com和tinyjpg.com。更高级的工具包括用于 JPEG、PNG 和 GIF 的ImageOptim以及用于 PNG 的ImageAlpha。 在我寻求完全控制压缩级别、格式和缩放的过程中，我需要一个工具来帮助我自动化整个过程。而且我不喜欢拖放几十张图像。 ImageMagic和GraphicsMagick都是免费且功能强大的软件，可与JavaScript 任务运行器Grunt 轻松配对。 更好的是，有 Grunt 插件可以进一步简化任务。几项快速测试表明，在相同压缩级别下，GraphicsMagick 生成的 JPG 图像比 ImageMagic 小 20%。所以选择很明确。 在我们开始穿越像素丛林之前，我们必须准备好工具并磨砺我们的斧头。从这里下载 GraphicsMagick或使用Homebrew安装它。 1brew install graphicsmagick 接下来，全局安装 Grunt 的 CLI： 1npm install -g grunt-cli 创建一个单独的文件夹responsive-images并初始化项目： 123mkdir responsive-imagescd responsive-imagesnpm init 最后，安装本地版本的 Grunt： 1npm install grunt --save-dev 创建两个文件夹：src/用于原始图像和dest/Grunt 和 GraphicsMagick 将生成的响应式图像： 12mkdir srcmkdir dest 原始图像应以等于或大于您要在src/文件夹中生成的最大图像的分辨率保存。我以 100% 质量和 2880 像素宽将我的保存为 JPG。大约是 2.5MB。 首先，让我们使用grunt-responsive-images插件生成响应式图像。安装它： 1npm install grunt-responsive-images --save-dev 现在，在项目的根目录中，创建一个附加文件Gruntfile.js： 1touch Gruntfile.js 这是我们必须配置插件的地方。 将代码复制并粘贴到Gruntfile.js，让我引导您完成代码： 1234567891011121314151617181920212223242526272829module.exports = function (grunt) { grunt.initConfig({ responsive_images: { dev: { options: { engine: &quot;gm&quot;, sizes: [ { name: &quot;sm&quot;, suffix: &quot;_1x&quot;, quality: 60, width: 600 }, { name: &quot;sm&quot;, suffix: &quot;_2x&quot;, quality: 60, width: 1200 }, { name: &quot;md&quot;, suffix: &quot;_1x&quot;, quality: 60, width: 900 }, { name: &quot;md&quot;, suffix: &quot;_2x&quot;, quality: 60, width: 1800 }, { name: &quot;lg&quot;, suffix: &quot;_1x&quot;, quality: 60, width: 1440 }, { name: &quot;lg&quot;, suffix: &quot;_2x&quot;, quality: 60, width: 2880 }, ], }, files: [ { expand: true, src: [&quot;**/*.{jpg,png}&quot;], cwd: &quot;src/&quot;, dest: &quot;dest/&quot;, }, ], }, }, }); grunt.loadNpmTasks(&quot;grunt-responsive-images&quot;); grunt.registerTask(&quot;default&quot;, [&quot;responsive_images&quot;]);}; 在options中，我们将 GraphicsMagick 设置为我们选择的引擎：engine: &quot;gm&quot;. 您还可以通过将 ImageMagick 更改为engine: &quot;im&quot;. 接下来，在sizes数组中，我们必须指定要生成的图像的参数，例如name将附加到原始名称的 a suffix，也将添加到名称的 a ， aquality和 a width。 生成的图像将具有以下命名结构： 1original-[name]_[suffix}.jpg 例如，使用第一个sizes对象，Grunt 将从原始图像中生成 60% 压缩级别和 600 像素宽my-image.jpg的图像。my-image-sm_1x.jpg 在选项下方，我们需要列出源文件夹和目标文件夹以及我们想要处理的文件名模式。 要启用文件对象的动态构建，让我们将expand属性设置为true并定义： cwd— 源文件夹 src— 要匹配的模式数组。在我们的例子中，我们希望匹配**源文件夹中的任何文件夹 ( ) 以及所有带有扩展名jpg或png dest— 目标文件夹 上述 Grunt 任务将根据源图像文件扩展名生成一组 JPG 和/或 PNG 文件。 我们还想生成一组相应的 WebP 图像。 我们需要另一个插件来完成这项工作：grunt-cwebp. 让我们安装它： 1npm install grunt-cwebp --save-dev 使用以下配置附加 Gruntfile.js： 12345678910111213141516171819202122232425module.exports = function (grunt) { grunt.initConfig({ responsive_images: { ... }, cwebp: { dynamic: { options: { q: 60, }, files: [ { expand: true, cwd: &quot;dest/&quot;, src: [&quot;**/*.{jpg,png}&quot;], dest: &quot;dest/&quot;, }, ], }, }, }); grunt.loadNpmTasks(&quot;grunt-responsive-images&quot;); grunt.loadNpmTasks(&quot;grunt-cwebp&quot;); grunt.registerTask(&quot;default&quot;, [&quot;responsive_images&quot;, &quot;cwebp&quot;]);}; 该grunt-cwebp插件使用该dest/文件夹作为图像的来源。我们希望所有新生成的 JPG 都有它们的 WebP 兄弟，我们应该将它们放在同一个文件夹中。 现在，我们可以处理图像： 1grunt 对于src/文件夹中的每张图片，Grunt 将生成 12 张所有必要尺寸、像素密度以及 JPG 和 WebP 格式的图片！ 如何生成base64字符串如果你想生成 base64 字符串来内联你的图像，这里是如何做的。 这一次，让我们使用 Grunt 插件：grunt-base64. 在单独的文件夹中创建一个新项目base64-images。npm使用本地版本的 Grunt初始化并安装它： 1234mkdir base64-imagescd base64-imagesnpm initnpm install grunt --save-dev 安装grunt-base64插件： 1npm install grunt-base64 --save-dev 在根目录中，创建一个新images/文件夹和Gruntfile.js： 12mkdir imagestouch Gruntfile.js 并将代码复制并粘贴到Gruntfile.js： 12345678910111213module.exports = function (grunt) { grunt.initConfig({ base64: { dev: { files: { &quot;images/output.b64&quot;: [&quot;images/*.{jpg,png}&quot;], }, }, }, }); grunt.loadNpmTasks(&quot;grunt-base64&quot;); grunt.registerTask(&quot;default&quot;, [&quot;base64&quot;]);}; 将小的原始图像放在images/文件夹中并运行 Grunt： 1grunt 任务完成后，复制文件中的全部内容output.b64——这是您可以粘贴到元素url的属性background-image或src属性中的 base64 字符串。img 还有一种更简单的方法（在 Mac OS X 或 Linux 上）： 1uuencode -m image-file-name remotename remotename不使用，您甚至可以将xyzbase64 字符串打印到标准输出中——在大多数情况下，打印到终端窗口中。您必须使用-m选项来获取 base64 编码。 引用 [1]: https://en.wikipedia.org/wiki/Email#Internet_Message_Format “Email “[2]: https://www.cnblogs.com/xiaxveliang/p/15097947.html “一文详解 Base64 编码原理”[3]: https://developer.mozilla.org/en-US/docs/Learn/HTML/Multimedia_and_embedding/Responsive_images “Responsive images”[4]: https://www.freecodecamp.org/news/a-guide-to-responsive-images-with-ready-to-use-templates-c400bd65c433 “A Guide to Responsive Images with Ready-to-Use Templates”[5]: https://www.youtube.com/watch?v=fgOO9YUFlGI “Responsive Design Tutorial - Tips for making web sites look great on any device”","link":"/2022/10/16/responsive-design/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2019/10/10/hello-world/"},{"title":"牛客后端项目学习记录","text":"目前进度1.14 1.2 搭建开发环境Redis：是操作内存的数据库 Kafka：消息队列 Elasticsearch：分布式搜索引擎 Apache Maven：是一个软件项目管理和理解工具。基于项目对象模型(POM)的概念，Maven可以从一个中心信息块管理项目的构建、报告和文档。(打包，生成文档，管理项目jar包，类似前端webpack，本地没有就从远程仓库下载，在config里修改setting.xml，将远程仓库改成阿里云的) 下载包：Binary开头的是不带源码，Source开头的带源码，tar后缀是针对Linux系统而言，zip后缀是针对Window系统。 Jar包地址：C:\\Users\\liny.m2 Springboot: 包里内嵌了一个tomcat，其功能是起步依赖，自动配置，端点监控。 Spring FrameworkSPring Boot - Build AnythingSpring Cloud - Coordinate Anything 微服务Spring Cloud Data Flow - Connect Everything 连接多个客户端官网 ： https://spring.io 1.6 Spring Framework Spring Core Ioc：管理Bean（对象） AOP：面向切面编程思想，对面向对象编程的补充 Spring Data Access Transactions、Spring MyBatis Web Servlet Spring MVC （Web开发） Integration Email、Scheduling（定时任务）、AMQP（消息队列）、Security Spring IoC Inversion of Control 控制反转，是一种面向对象编程的设计思想。 Dependency Injection 依赖注入，是Ioc思想的实现方式。 IoC Container IoC容器，是实现依赖注入的关键，本质上是一个工厂。 具体过程：给Spring Container两个输入，一个是Your Business Object （POJOs）对象，一个是对象的配置文件Configuration Metadata。 具体代码：SpringApplication.run底层自动创建了Spring容器，并去扫描部分包下的Bean，装配到容器里@SpringBootConfiguration ： 这是一个配置文件@EnableAutoConfiguration ： 自动配置@ComponentScan ： 组件扫描，去扫描包下Bean去装配，它会去扫描配置类下所在的包，还得有@Controller（处理请求组件）这样的注解才能被扫描，除此之外，还有Service业务组件，Repository数据库访问组件，这些都是Component下的类。@Component是通用的。 ApplicationContext就是Spring容器， 它扩展了父接口HierarchicalBeanFactory，父接口继承了BeanFactory，这个就是Spring容器的顶层接口。 AlphaDao alphaDao = applicationContext.getBean(AlphaDao.class); // 我要从容器里获取这个类型的Bean @Primary // getBean的时候有更高优先级 //@Scope(“singleton”) // 单例 @Scope(“prototype”) // 多例 我要去管理一个第三方的Bean，但是那是别人写的第三方插件，我的注解没用，怎么办？需要自己写一个配置类，然后通过Bean注解声明来解决这个问题 依赖注入自动注入：@Autowired通过名字注入特定Bean ：@Qualifier(“alphaHibernate”) 1.14 Spring MVC （Web Servlet）Spring MVC将后端架构分为三层，表现层，业务层和数据层，然后MVC不是指的这三层，而是指的表现层，将表现层再分为三层，控制层Controller接受前端请求，然后控制层去调用业务层以及数据层获取到数据后发给Model层，Model层将数据整理好，发给View层去渲染，就是SSR。 然后表现层的调度是交给一个核心组件，前端控制器：DispatcherServlet。 MCV中Model层是View层的数据容器，Jsp页面上所有的参数传递都是通过绑定到模型。 HTTP参考：https://developer.mozilla.org/zh-CN/docs/Learn Front Controller就是DispatcherServlet 怎么去调度你要讲清楚 ThymeleafModel层 -&gt; View层的实现过程。 问题，与React，Vue这些实现过程的区别？","link":"/2022/12/18/nowcoder/"},{"title":"Deploy Hexo","text":"本文主要介绍 Hexo + icarus 基础环境搭建，包含 Hexo 框架的下载安装，icarus 及其组件的下载安装，完成以下操作步骤将初步完成 Hexo 博客 + icarus 主题的配置。后续将对 Hexo 博客进行功能扩展。 即： 已安装 Git 1$ git --version # 查看 git 版本 已安装 Node.js (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本) 12$ node -v # 查看 node.js 版本$ npm -v # 查看 npm 包管理器版本 如未正确安装，请参照 Hexo官方文档 进行安装，以下操作均基于Mac平台。 我的电脑需要如下操作，至今没去查为何每次使用node都需要source一下。 12$ source ~/.bash_profile # 编译一下bash文件 ？？？ $ nvm use 16 # 使用nvm切换node版本 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo 框架。 1$ npm install -g hexo-cli # 全局安装 Hexo 框架 查看 Hexo 版本，检查是否安装成功。 1$ hexo -v Hexo 初始化在任意位置新建一个文件夹，取名 blog，在blog/ 目录下 打开 CMD 窗口，运行以下命令，进行 Hexo 框架初始化。 1$ hexo init # Hexo 初始化 我安装时候，vpn有毒，即使复制终端代理命令也不行，老是断一下连一下 出现问题： 1$ npm not working - &quot;read ECONNRESET&quot; 后面用如下命令解决： use so that npm requests for http url instead of https. and then try the same npm install command 1$ npm config set registry http://registry.npmjs.org/ 我原本的源 12$ npm config get registryhttp://registry.npmjs.org/ 最后换源了 1$ npm config set registry http://registry.npmjs.org/ 下载icarus主题运行下列命令以下载 icarus 主题，此处可能下载较慢，请耐心等待。 1$ git clone https://github.com/ppoffice/hexo-theme-icarus.git themes/icarus 切换icarus主题打开 _config.yml 文件，将 thems 项的值更改为 icarus 启动Hexo1$ hexo g # 生成静态页面 这里会提示错误 ERROR 我们根据上图中的错误提示安装 icarus 主题所需组件。 1$ npm install --save bulma-stylus@0.8.0 hexo-renderer-inferno@^0.1.3 hexo-component-inferno@^0.10.1 inferno@^7.3.3 inferno-create-element@^7.3.3 再依次运行命令行，重新生成静态页面，并启动 Hexo 服务。 12$ hexo g # 生成静态页面$ hexo s # 启动服务 打开浏览器输入下列网址预览效果。 1http://localhost:4000 添加 自定义页面 新建一个 分类 页面 1$ hexo new page categories 新建一个 标签 页面 1$ hexo new page tags 新建一个 关于我 页面 1$ hexo new page &quot;about&quot; 写作123$ hexo new [layout] &lt;title&gt; # layout布局默认为post，有三种默认布局即post、page 和 draft，在创建者三种不同类型的文件时，它们将会被保存到不同的路径；# 而您自定义的其他布局和 post 相同，都将储存到 source/_posts 文件夹。 新建一篇文章示例： 1$ hexo new 第一篇文章的名字 在此之前通常建议开启 _config.yml 中的资源文件夹，以便创建文章的同时，自动为你创建同名资源文件夹，这通常用于存放你在本篇文章所用到的图片等资源。存在此文件夹中的图片，Hexo 生成静态页面时，将会将二者存放在同一文件夹下。 1post_asset_folder: true # 开启文章资源文件夹 部署在正式开始部署上传到 GitHub 上前，通常建议配置 SSH 秘钥，这样不用每次上传部署都要进行登录验证，有关如何配置 SSH 秘钥，请参阅 ————–此处省略10000字————————- ————–挖坑1：GitHub 添加 SSH————— 详情请参阅：Git配置SSH秘钥 ————–挖坑2：GitHub 静态页面————— 首先在_config.yml中修改添加以下内容，指定部署上传的 GitHub 库。 123456789deploy: type: git repo: git@github.com:local-host-8080/local-host-8080.github.io.git branch: master type: git repo: &lt;repository url&gt; branch: [branch] message: [message]Site updated: {{ now('YYYY-MM-DD HH:mm:ss') }}) 安装 1git 组件 1$ npm install hexo-deployer-git --save 此外，如果您的 Github Pages 需要使用 CNAME 文件自定义域名，请将 CNAME 文件置于 source/ 目录下，只有这样 hexo deploy 才能将 CNAME 文件一并推送至部署分支。 上传至GitHub 123$ hexo clean$ hexo g$ hexo d Hexo 一篇文章多个 categories子分类下面的分类配置会将该文章放到 Sports/Baseball 这个分类下。 123categories: - Sports - Baseball 同样的作用还可以这样写： 1categories: [Sports,Baseball] 上面两种写法最终的效果都是一样的，都是将文章放在了一个子分类目录下。 多个分类如果我们的要求是将文章同时分到两个或者多个不同的类目下呢？官方给出的方法是： 123categories: - [Sports] - [Baseball] 只需要用中括号将独立的分类括起来即可，这样上面的文章就会被分类在 Sports 和 Baseball 这两个不同的目录中了。 扩展一下，如果我们要将其分类到 Sports/Baseball 和 Play 两个不同的目录下（一个是子目录，一个是一级目录），我们该怎么写呢？如下： 123categories: - [Sports,Baseball] - [Play] 图片放置1{% asset_img 1.jpg This is an image %} 摘要1&lt;!--more--&gt; 评论Gitalk安装指南在线预览 登录GitHub并点此注册一个新的OAuth应用。填写”应用名称“(Application name)，”应用主页“(Homepage URL)，”应用描述“(Application description)。然后，在”认证回调地址“(Authorization callback URL)填写你的博客的根URL地址。点击“注册应用”(Register application)按钮来跳转到应用详情界面。 复制”Client ID“与”Client Secret“的值并填入主题配置的相应配置项中。 例如，对于下面的”Client ID“和”Client Secret“： 1234Client IDxxxxxxxxxxxxxxxxxxxxClient Secretxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx 对应如下的Gitalk的配置： 123456789101112131415comment: type: gitalk client_id: xxxxxxxxxxxxxxxxxxxx client_secret: xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx repo: Some-of-Your-GitHub-Repo # 你的github分支名字就好，不用全部 owner: you_github_name admin: - you_github_name per_page: 20 # 可选填 distraction_free_mode: false # 可选填 pager_direction: last # 可选填 create_issue_manually: false # 可选填 proxy: # 可选填 flip_move_options: # 可选填 enable_hotkey: true # 可选填 Markdown 链接语法链接文本放在中括号内，链接地址放在后面的括号中，链接title可选。 超链接Markdown语法代码：[超链接显示名](超链接地址 &quot;超链接title&quot;) 对应的HTML代码：&lt;a href=&quot;超链接地址&quot; title=&quot;超链接title&quot; style=&quot;text-decoration:none;&quot;&gt;超链接显示名&lt;/a&gt; 1这是一个链接 [Markdown语法](https://markdown.com.cn)。 渲染效果如下： 这是一个链接 Markdown语法。 #给链接增加 Title链接title是当鼠标悬停在链接上时会出现的文字，这个title是可选的，它放在圆括号中链接地址后面，跟链接地址之间以空格分隔。 1这是一个链接 [Markdown语法](https://markdown.com.cn &quot;最好的markdown教程&quot;)。 渲染效果如下： 这是一个链接 Markdown语法。 侧边栏设置sidebar中某个侧边栏的sticky为true来让它的位置固定而不跟随页面滚动。 1234567_config.icarus.ymlsidebar: left: sticky: false right: sticky: true 布局配置文件布局配置文件遵循着与主题配置文件相同的格式和定义。 _config.post.yml中的配置对所有文章生效，而_config.page.yml中的配置对所有自定义页面生效。 这两个文件将覆盖主题配置文件中的配置。 例如，你可以在_config.post.yml中把所有文章变为两栏布局： 123456789101112_config.post.ymlwidgets: - type: recent_posts position: left - type: categories position: left - type: tags position: left 同时所有其他页面仍保持三栏布局： 123456789101112_config.icarus.ymlwidgets: - type: recent_posts position: left - type: categories position: right - type: tags position: right 业内跳转.html标签实现 定义一个锚(id)： &lt;span id=&quot;jump&quot;&gt;跳转到的地方&lt;/span&gt; 使用markdown语法：[点击跳转](#jump) 自定义Hexo标签插件Mdx123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419&lt;article class=&quot;message message-immersive is-primary&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-globe-americas mr-2&quot;&gt;&lt;/i&gt;本文同时提供以下语言的翻译：&lt;a href=&quot;{% post_path en/Custom-Hexo-Tag-Helpers %}&quot;&gt;English&lt;/a&gt;。&lt;/div&gt;&lt;/article&gt;&lt;article class=&quot;message message-immersive is-primary&quot;&gt;&lt;div class=&quot;message-body&quot;&gt;&lt;i class=&quot;fas fa-info-circle mr-2&quot;&gt;&lt;/i&gt;下面的标签插件由&lt;a href=&quot;https://github.com/ppoffice/hexo-component-inferno&quot;&gt;ppoffice/hexo-component-inferno&lt;/a&gt;提供，完整的支持插件列表和配置详情以其为准。&lt;/div&gt;&lt;/article&gt;&lt;style&gt;.example-tab-container { margin: 0 0 20px 0; padding: 10px 20px 20px 20px; border-radius: 6px; box-shadow: 0 0.5em 0.75em -0.125em rgba(10,10,10,0.1), 0 0px 0 1px rgba(10,10,10,0.02);}&lt;/style&gt;## 消息五颜六色的消息块可以用来强调你文章中的部分文本。它的语法定义如下：```{% message color:&lt;颜色&gt; size:&lt;大小&gt; icon:&lt;图标&gt; title:&lt;标题&gt; %} &lt;内容&gt;{% endmessage %}```### color此选项定义消息块的颜色。其为可选项。它可用的配置值与示例如下：{% message &quot;title:default&quot; %} 一个没有设置颜色的代码块。{% endmessage %}{% message color:dark &quot;title:dark&quot; %} 一个深色(`dark`)的代码块。{% endmessage %}{% message color:primary &quot;title:primary&quot; %} 一个主题色(`primary`)的代码块。{% endmessage %}{% message color:info &quot;title:info&quot; %} 一个提示色(`info`)的代码块。{% endmessage %}{% message color:success &quot;title:success&quot; %} 一个成功色(`success`)的代码块。{% endmessage %}{% message color:warning &quot;title:warning&quot; %} 一个警示色(`warning`)的代码块。{% endmessage %}{% message color:danger &quot;title:danger&quot; %} 一个危险色(`danger`)的代码块。{% endmessage %}### size此选项定义消息块的大小。其为可选项。它可用的配置值与示例如下：{% message size:small &quot;title:small&quot; %} 一个小(`small`)的代码块。{% endmessage %}{% message &quot;title:default&quot; %} 一个没有设置大小的代码块。{% endmessage %}{% message size:medium &quot;title:medium&quot; %} 一个中等大小(`small`)的代码块。{% endmessage %}{% message size:large &quot;title:large&quot; %} 一个大(`small`)的代码块。{% endmessage %}### icon此选项定义显示在消息块头部的图标。其为可选项。它的值应为FontAwesome的图标class name。如果图标的class name含有空格，则配置名与配置值需要用引号包裹住。{% message &quot;icon:fa-brands fa-github&quot; &quot;title:一个有着GitHub图标的消息块&quot; %} 一个有着GitHub图标(`&quot;icon:fa-brands fa-github&quot;`)的消息块。{% endmessage %}{% message color:success &quot;icon:fa-brands fa-node-js&quot; &quot;title:一个有着Node.js图标的消息块&quot; %} 一个有着Node.js图标(`&quot;icon:fa-brands fa-node-js&quot;`)的消息块。{% endmessage %}{% message color:danger &quot;icon:fa-brands fa-npm&quot; &quot;title:一个有着NPM图标的消息块&quot; %} 一个有着NPM图标(`&quot;icon:fa-brands fa-npm&quot;`)的消息块。{% endmessage %}### title此选项定义消息块的标题。其为可选项。如果标题含有空格，则配置名与配置值需要用引号包裹住。{% message &quot;title:有标题的消息块&quot; %} 有标题的消息块(`&quot;title:有标题的消息块&quot;`)。{% endmessage %}{% message %} 没有标题的消息块。{% endmessage %}{% message color:dark %} 没有标题的消息块。{% endmessage %}{% message color:primary %} 没有标题的消息块。{% endmessage %}{% message color:info %} 没有标题的消息块。{% endmessage %}{% message color:success %} 没有标题的消息块。{% endmessage %}{% message color:warning %} 没有标题的消息块。{% endmessage %}{% message color:danger %} 没有标题的消息块。{% endmessage %}## 标签页标签页是一个功能强大的用于展示平行内容的标签插件。同一时间内，只有活动的标签页内容才能展示给用户。它的语法定义如下：```{% tabs size:&lt;大小&gt; align:&lt;对齐&gt; style:&lt;样式&gt; %}&lt;!-- tab id:&lt;标签ID&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; active --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;&lt;!-- tab id:&lt;标签ID&gt; icon:&lt;图标&gt; title:&lt;标签标题&gt; --&gt;&lt;标签内容&gt;&lt;!-- endtab --&gt;...{% endtabs %}```### 标签容器一个标签容器有着以下选项：#### size此选项定义标签页的大小。其为可选项。它可用的配置值与示例如下：&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs size:small %}&lt;!-- tab id:tab_size_small_1 &quot;title:第一页&quot; active --&gt;这是一个小(`small`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_size_small_2 &quot;title:第二页&quot; --&gt;这是一个小(`small`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs %}&lt;!-- tab id:tab_size_default_1 &quot;title:第一页&quot; active --&gt;这是一个没有指定大小的标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_size_default_2 &quot;title:第二页&quot; --&gt;这是一个没有指定大小的标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs size:medium %}&lt;!-- tab id:tab_size_medium_1 &quot;title:第一页&quot; active --&gt;这是一个中等大小(`medium`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_size_medium_2 &quot;title:第二页&quot; --&gt;这是一个中等大小(`medium`)标签页容器的第一页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs size:large %}&lt;!-- tab id:tab_size_large_1 &quot;title:第一页&quot; active --&gt;这是一个大(`large`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_size_large_2 &quot;title:第二页&quot; --&gt;这是一个大(`large`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;#### align此选项定义标签页按钮的对齐方式。其为可选项。它可用的配置值与示例如下：&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs %}&lt;!-- tab id:tab_align_default_1 &quot;title:第一页&quot; active --&gt;这是一个没有指定对齐方式的标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_align_default_2 &quot;title:第二页&quot; --&gt;这是一个没有指定对齐方式的标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs align:centered %}&lt;!-- tab id:tab_align_centered_1 &quot;title:第一页&quot; active --&gt;这是一个居中对齐的(`centered`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_align_centered_2 &quot;title:第二页&quot; --&gt;这是一个居中对齐的(`centered`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs align:right %}&lt;!-- tab id:tab_align_right_1 &quot;title:第一页&quot; active --&gt;这是一个右对齐的(`centered`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_align_right_2 &quot;title:第二页&quot; --&gt;这是一个右对齐的(`centered`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs align:fullwidth %}&lt;!-- tab id:tab_align_fullwidth_1 &quot;title:第一页&quot; active --&gt;这是一个全宽的(`fullwidth`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_align_fullwidth_2 &quot;title:第二页&quot; --&gt;这是一个全宽的(`fullwidth`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;#### style此选项定义标签页按钮的样式。其为可选项。此外你可以将样式与全宽(`fullwidth`)对齐方式结合。它可用的配置值与示例如下：&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs style:boxed %}&lt;!-- tab id:tab_style_boxed_1 &quot;title:第一页&quot; active --&gt;这是一个盒状(`boxed`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_style_boxed_2 &quot;title:第二页&quot; --&gt;这是一个盒状(`boxed`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs style:toggle %}&lt;!-- tab id:tab_style_toggle_1 &quot;title:第一页&quot; active --&gt;这是一个拨动开关状(`toggle`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_style_toggle_2 &quot;title:第二页&quot; --&gt;这是一个拨动开关状(`toggle`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs style:toggle-rounded %}&lt;!-- tab id:tab_style_toggle_rounded_1 &quot;title:第一页&quot; active --&gt;这是一个圆角拨动开关状(`toggle-rounded`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_style_toggle_rounded_2 &quot;title:第二页&quot; --&gt;这是一个圆角拨动开关状(`toggle-rounded`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs align:fullwidth style:boxed %}&lt;!-- tab id:tab_style_boxed_fullwidth_1 &quot;title:第一页&quot; active --&gt;这是一个全宽(`fullwidth`)盒状(`boxed`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_style_boxed_fullwidth_2 &quot;title:第二页&quot; --&gt;这是一个全宽(`fullwidth`)盒状(`boxed`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs align:fullwidth style:toggle %}&lt;!-- tab id:tab_style_toggle_fullwidth_1 &quot;title:第一页&quot; active --&gt;这是一个全宽(`fullwidth`)拨动开关状(`toggle`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_style_toggle_fullwidth_2 &quot;title:第二页&quot; --&gt;这是一个全宽(`fullwidth`)拨动开关状(`toggle`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs align:fullwidth style:toggle-rounded %}&lt;!-- tab id:tab_style_toggle_rounded_fullwidth_1 &quot;title:第一页&quot; active --&gt;这是一个全宽(`fullwidth`)圆角拨动开关状(`toggle-rounded`)标签页容器的第一页。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_style_toggle_rounded_fullwidth_2 &quot;title:第二页&quot; --&gt;这是一个全宽(`fullwidth`)圆角拨动开关状(`toggle-rounded`)标签页容器的第二页。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;### Tab一个标签页有如下选项：#### id此选项为标签页元素的独特标识符(ID)。此项为必填项。一个标签页ID应当在整个页面内为独一无二的，这样Icarus才能定位、显示、和隐藏正确的标签页内容。#### active此选项标记当前的标签页是否默认显示。此项为选填项。同一时刻一个标签组中只有一个标签页可以标记为活动(`active`)标签页。#### icon此选项定义标签按钮中显示的图标。此项为选填项。它的值应为FontAwesome图标的class name。如果图标的class name含有空格，则配置名与配置值需要用引号包裹住。&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs %}&lt;!-- tab id:tab_icon_1 &quot;icon:fa-brands fa-github&quot; &quot;title:GitHub&quot; active --&gt;这个标签页的图标(`icon`)为`&quot;icon:fa-brands fa-github&quot;`。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_icon_2 &quot;icon:fa-brands fa-node-js&quot; &quot;title:Node.js&quot; --&gt;这个标签页的图标(`icon`)为`&quot;icon:fa-brands fa-node-js&quot;`。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs align:fullwidth style:toggle-rounded %}&lt;!-- tab id:tab_boxed_icon_1 &quot;icon:fa-brands fa-github&quot; &quot;title:GitHub&quot; active --&gt;这个标签页的图标(`icon`)为`&quot;icon:fa-brands fa-github&quot;`。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_boxed_icon_2 &quot;icon:fa-brands fa-node-js&quot; &quot;title:Node.js&quot; --&gt;这个标签页的图标(`icon`)为`&quot;icon:fa-brands fa-node-js&quot;`。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt;#### title此选项定义标签按钮的标题。其为可选项。如果标题含有空格，则配置名与配置值需要用引号包裹住。&lt;div class=&quot;example-tab-container&quot;&gt;{% tabs style:toggle %}&lt;!-- tab id:tab_title_boxed_1 &quot;title:有标题的标签页&quot; active --&gt;这个标签页的标题(`title`)为(`&quot;title:有标题的标签页&quot;`)。&lt;!-- endtab --&gt;&lt;!-- tab id:tab_title_boxed_2 &quot;title:另一个有标题的标签页&quot; --&gt;这个标签页的标题(`title`)为(`&quot;title:另一个有标题的标签页&quot;`)。&lt;!-- endtab --&gt;{% endtabs %}&lt;/div&gt; 增加文献引用增加引用的文献列表示例如下： 参考 [1] 百度学术 [2] Wikipedia1增加锚点 参考 - [1] [百度学术](http://xueshu.baidu.com/) - [2] [Wikipedia](https://en.wikipedia.org/wiki/Main_Page) ———————————————— 版权声明：本文为CSDN博主「MurphyZhao」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/u012349679/article/details/103815049 增加引用使用 标注引用，如下所示： Markdown 增加文献引用这边文章是介绍如何在 Markdown 中增加文献引用。1 参考 [1] 百度学术 [2] Wikipedia 其他配置你可以参考Icarus用户指南来了解更多第三方的插件、挂件、以及CDN提供商的配置。 更多请参考[1]: https://ppoffice.github.io/hexo-theme-icarus/Configuration/icarus%E7%94%A8%E6%88%B7%E6%8C%87%E5%8D%97-%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE/ “Icarus用户指南” 暂时就这样…","link":"/2022/10/08/%E9%83%A8%E7%BD%B2Hexo/"}],"tags":[{"name":"JS","slug":"JS","link":"/tags/JS/"},{"name":"Echarts","slug":"Echarts","link":"/tags/Echarts/"},{"name":"Vue2","slug":"Vue2","link":"/tags/Vue2/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Modular","slug":"Modular","link":"/tags/Modular/"},{"name":"TypeScript","slug":"TypeScript","link":"/tags/TypeScript/"},{"name":"Vue3","slug":"Vue3","link":"/tags/Vue3/"},{"name":"Vite","slug":"Vite","link":"/tags/Vite/"},{"name":"Flask","slug":"Flask","link":"/tags/Flask/"},{"name":"uWsgi","slug":"uWsgi","link":"/tags/uWsgi/"},{"name":"Nginx","slug":"Nginx","link":"/tags/Nginx/"},{"name":"MongoDB","slug":"MongoDB","link":"/tags/MongoDB/"},{"name":"English","slug":"English","link":"/tags/English/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"},{"name":"CSS","slug":"CSS","link":"/tags/CSS/"},{"name":"Hexo","slug":"Hexo","link":"/tags/Hexo/"},{"name":"Icarus","slug":"Icarus","link":"/tags/Icarus/"}],"categories":[{"name":"Summary","slug":"Summary","link":"/categories/Summary/"},{"name":"FrontEnd","slug":"FrontEnd","link":"/categories/FrontEnd/"},{"name":"Personal works","slug":"Personal-works","link":"/categories/Personal-works/"},{"name":"BackEnd","slug":"BackEnd","link":"/categories/BackEnd/"},{"name":"Deploy","slug":"Deploy","link":"/categories/Deploy/"}],"pages":[{"title":"Concepts","text":"微前端微前端是一种多个团队通过独立发布功能的方式，来共同构建现代化web应用的技术手段及方法策略。 不同于单纯的前端框架/工具，微前端是一套架构体系，这个概念最早在2016年底由 ThoughtWorks 提出。 微前端是一种类似于后端微服务的架构，它将微服务的理念应用于浏览器端，将 Web 应用从整个的「单体应用」转变为多个小型前端应用的「聚合体」。 各个前端应用「原子化」，可以独立运行、开发、部署，从而满足业务的快速变化，以及分布式、多团队并行开发的需求 引用[1]: https://juejin.cn/post/7114589692560932878 “我终于把微前端(qiankun)落地生产项目了” 大前端面向终端更多，承担的任务更多，功能更强大更复杂，技术形态更多，更趋向于工程化自动化，与后端解耦独立开发测试 BFF(Backend for Frontends，为前端而存在的后端)属于 中间层，剥离出来不属于后台的部分，让前端自己维护处理（比如传统后端的接口层） 端开发，云开发，泛客户端开发（flutter,react native） D.ts文件扩展名“d.ts”文件用于提供有关用 JavaScript 编写的 API 的打字稿类型信息。 这个想法是你正在使用 jQuery 或 underscore 之类的东西，一个现有的 javascript 库。 你想从你的打字稿代码中使用那些。 与其用 typescript 重写 jquery 或 underscore 或其他任何东西，不如编写 d.ts 文件，它只包含类型注释。 然后从您的 typescript 代码中，您可以获得静态类型检查的 typescript 好处，同时仍然使用纯 JS 库。 这要归功于 TypeScript 的限制，即不允许您在 import 语句的末尾添加“.ts”扩展名。 因此，当你引用某个文件时，比方说，my-module.js，如果它旁边有一个 my-module.d.ts，那么 TypeScript 将包含它的内容： 1234src/ my-module.js my-module.d.ts index.ts my-module.js 123const thing = 42;module.exports = { thing }; my-module.d.ts 1export declare const thing: number; index.ts 1234567import { thing } from &quot;./my-module&quot;; // &lt;- no extension// runtime implementation of `thing` is taken from &quot;.js&quot;console.log(thing); // 42// type declaration of `thing` is taken from &quot;.d.ts&quot;type TypeOfThing = typeof thing; // number Is there any way to get the typescript compiler to search for declaration files in a given directory? Something like the INCLUDE_PATH for C++ ?Not currently. You have to reference the file explicitly using: 1///&lt;reference path=&quot;path/to/file.d.ts&quot; /&gt; You can use the references.ts trick to ease the referencing in your program (just put all your references in a single file so all your other files just point to that one). You need to add a ///&lt;reference line to the top of the consuming ts file. You’ll need to have both the d.ts and the .js file available. [1]: https://stackoverflow.com/questions/21247278/about-d-ts-in-typescript “About &quot;*.d.ts&quot; in TypeScript” Less、Sass和Scss1、Less： 是一种动态样式语言. 对CSS赋予了动态语言的特性，如变量、继承、运算、函数。 Less 既可以在客户端上运行 (支持IE 6+, Webkit, Firefox)，也可在服务端运行。 2、Sass： 是一种动态样式语言，Sass语法属于缩排语法， 比css比多出好些功能(如变量、嵌套、运算,混入(Mixin)、继承、颜色处理，函数等)，更容易阅读。 Sass与Scss是什么关系? Sass的缩排语法，对于写惯css前端的web开发者来说很不直观，也不能将css代码加入到Sass里面，因此sass语法进行了改良，Sass 3就变成了Scss(sassy css)。与原来的语法兼容，只是用{}取代了原来的缩进。 二、less和sass的相同之处Less和Sass在语法上有些共性，比如下面这些： 1、混入(Mixins)——class中的class； 2、参数混入——可以传递参数的class，就像函数一样； 3、嵌套规则——Class中嵌套class，从而减少重复的代码； 4、运算——CSS中用上数学； 5、颜色功能——可以编辑颜色； 6、名字空间(namespace)——分组样式，从而可以被调用； 7、作用域——局部修改样式； 8、JavaScript 赋值——在CSS中使用JavaScript表达式赋值。 三、less和sass的区别Less和Sass的主要不同就是他们的实现方式。 Less是基于JavaScript，是在客户端处理的。 Sass是基于Ruby的，是在服务器端处理的。 关于变量在Less和Sass中的唯一区别就是Less用@，Sass用$。 LoadshLodash 是一个一致性、模块化、高性能的 JavaScript 实用工具库。 Lodash 通过降低 array、number、objects、string 等等的使用难度从而让 JavaScript 变得更简单。 Lodash 的模块化方法 非常适用于： 遍历 array、object 和 string 对值进行操作和检测 创建符合功能的函数 [1]: https://juejin.cn/post/6922710332813082638 “Lodash 个人使用文档”[2]: https://www.lodashjs.com/ “Lodash官网” AJAXAJAX 是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。AJAX = Asynchronous JavaScript and XML.AJAX 通过在后台与服务器进行少量数据交换，使网页实现异步更新。这意味着可以在不重载整个页面的情况下，对网页的某些部分进行更新。传统的网页（不使用 AJAX）如果需要更新内容，必须重载整个页面。 发起请求用的～ SOTA resultstate-of-the-art result，指的是在该项研究任务中，目前最好的模型的结果/性能/表现。 自我介绍模版面试官好，我是XX，本科就读于XX大学的XX专业2023届毕业生。这次面试的职位是XX。 [专业课程、项目、实习、性格] 首先，我的专业是XX，学习了XX课程(一定要说这个岗位需要具备的能力)，参加过XX比赛拿到过XX类奖项;其次，我曾在XX公司和XX公司有实习经历，主要负责XX工作，锻炼了我的Xx能力;第三，在性格上，我有XX特质，身边人评价我XX优势1个性，这些都有助于我更好地完成该岗位的XX工作。同时我也很喜欢XX(面试岗位)的XX工作方向，特别是在XX这块与我的经历与爱好十分四配，期待能够在XX(面试公司)继续学习成长，谢谢。","link":"/Concepts/index.html"},{"title":"categories","text":"","link":"/categories/index.html"},{"title":"Ana","text":"目前的很多困惑，不确定性，等到以后就会因为解决不了和自己妥协或者努力解决了，反正都是车到山前就自然解决了。人是一个在慢慢探索自己边界的一个过程，最后呢，就是在自己边界的舒适区活着就好，这个地方就是自己的能力上限。 面对众人的凝视，何妨不凝视回去 Worrying is using your imagination to create the reality you don’t want and forcing yourself to live in it. 4、应该更深入的了解自己。 5、确认需求背景，再去实现，技术服务于业务，成长取决于自己，别把公司当成“家”，勿把低质内卷当充实 要多思考需求背后的价值，分析整个业务流程和技术运用的合理性，不要为了用技术而用技术，或者只会一味的跟着命令去完成需求，成为一个需求机器。 成长的机会是需要我们自己来争取的，没人教你，你就自己旭熙公司的源码，自己试着把自己学到的新技术，引入到公司的项目中，争取把你在公司做的事情，项目作为你自己的履历，帮助你找到更好的机会。 千万不要把自己和公司绑定，也不要因为工作不满意，就让自己的职业发展躺平了，既然改变不了环境，那就改变我们自己，坚持学习，多去尝试，找到自己的特长，这样做之后，哪怕突然又发生了变化，我们也能够从容应对，找到新的去处 6、你以为的巅峰往往是陷阱，而人生的绝望之谷也常常拥抱你。 7、我要根据大家都认可的感受去规范自己的感受 ｜｜ 我可以出于自己的感受去做决定 8、哪里钱多去哪里，薪资其实代表着公司对你这个岗位的定义，薪资代表着公司对这个岗位的重视程度不一样。即使入职没几个月后悔，此时你对公司了解很皮毛，应该了解完后才做决定。 9、培训课程很重要，基础很重要。 10、学不进去的时候听歌，多看官方资料，多做自己不喜欢的事情。 11、一切不可规划的，才是你人生中最让你记忆犹深的东西。但规划是一个抗风险，底线的策略。 12、规划对于我来说是提高安全感的导航，但是其他人眼里却是懒惰的路径依赖。规划一边拖住了你的底线，但另一边也锁死了你的天花板。 13、人生的意义是爱，善意和体验，而不是闯关。","link":"/Ana/index.html"},{"title":"tags","text":"","link":"/tags/index.html"},{"title":"About","text":"关于 ‘ JS原型 ’ 套娃一开始，先说说为何这个知识点为什么理解起来这么乱个人感觉原因有三： JS内函数即对象。 Function对象和Object对象这两个内置对象的特殊性。（官方的神仙操作） 很多讲解图的指向一眼下去花里胡哨，看着都头疼[手动狗头]。 再说说，为何网上各位前辈的相关文章都难以参透很多前辈在讲解相关知识点的时候都是从__proto__开始讲起，但在我看来，__proto__与prototype关系之密切是无法单独提出来讲的（单独讲就意味着难以理解）；而prototype与constructor又有密切关系，这就造成一种很尴尬的处境，要先讲__proto__就必然需要同时讲解prototype和constructor属性，这个也就是为何对于小白的我们而言这些概念是那么的难以理解。（以上个人看法，仅供参考） 关于 ‘Undateable‘这是电影《弗兰西斯·哈》里主角用来形容自己的一个词语。 很喜欢电影的一段旁白撒 ～ “ 你和别人在一起的时候，有这样的瞬间，他们知道你爱他们，你也知道他们爱着你。你们在一个派对里，在跟不同的人说这话，都在开心的笑着，这时候你望向屋子的另一边，两个人的眼光交汇了，并不是那种占有欲的意思，也不是那种色眯眯的眼神，只是因为那就是你生命中的那个人。“ 改进目前大部分blog都是在二手资料基础上阅读进而整理或者直接复制得来，缺乏个人思考以及阅读官方材料，问题很大，希望未来改进，多一些原创，多看英文资料，少看中文博客（坑很多撒）～ 对用户的期望有更低的阈值～ 未填的坑[1]: https://www.youtube.com/watch?v=fgOO9YUFlGI “Responsive Design Tutorial - Tips for making web sites look great on any device” [3]: https://juejin.cn/post/6844903506797658119 “手把手教你 React 添加双向数据绑定”[4]: “计算机网络”[5]: “浏览器渲染过程与性能优化”[6]: JS的模块化[7]: JS异步 本网站依托于GitHub pages，采用Hexo，主题为Icarus，图床采用SM.MS。Repository","link":"/about/index.html"},{"title":"Resume","text":"CN EN 林佑光 18810018512 ｜ 1093742432@qq.com Github ｜个人博客 教育经历 香港中文大学 2021年09月-2022年11月 香港 信息工程 硕士 工程学院 GPA: 3.54/4.00 北京邮电大学 2017年09月-2021年06月 北京 物联网工程 学士 物联网工程 GPA: 3.45/4.00 实习经历 公司名称：HelloToby 2022年 05月 - 2022年 08月 实习背景：该公司为香港一家一站式服务配对公司。本人工作是维护面向后端人员使用的数据管理系统，完善支持后端管理人员对客户合同与任务的增删改查的功能。 主要工作： 解决开发和测试环境下的跨域问题 编写SendGrid模版作为公司邮件模版 更换组件库(Vue Material替换为Ant Design Vue) 使用Vue2框架维护现有组件 使用Git进行代码提交 公司名称：清氢捷能科技有限公司 2021年 06月 - 2021年 08月 实习背景：此项目为清华大学车辆与运载学院新能源汽车测试组参与的国家重点研发计划科技冬奥重点专项“氢能出行”。本人的工作是负责构建信息监控大数据平台，实时展示新能源汽车的数据信息。 主要工作： 使用Vue2框架搭配Echarts与百度地图通过点聚合方式显示78辆氢能源汽车的数据 使用Flex与Grid布局 使用Webpack打包与部署前端应用 项目地址：https://blog.linyouguang.com/2021/09/08/New-Energy-Car/ 项目经历 项目名称：前端监控系统 2022年 07月 - 2022年 09月 技术栈：前端：Vue3 + Vite + TypeScript + Arco Design 后端： Flask + MongoDB + Nginx 项目介绍：本项目主要是实现一个前端监控系统，使用者将本项目开发的埋点代码放置在需要被监控的前端项目中，用户的行为数据会被记录，使用者可以通过一个中台页面监控项目情况。 主要工作： 负责用户细查及总概览页面，编写相关前后端接口、用户行为捕获sdk。 使用Nginx部署前后端。 使用Swagger自动生成文档 项目地址：www.linyouguang.com:8080/login 项目文档：https://blog.linyouguang.com/2022/09/01/Monitor-SDK/ 项目名称：购物网站 2022年 01月 - 2022年 03月 技术栈：前端：JS + CSS + HTML 后端：SqlLite + PHP 项目介绍：开发一个运作良好且安全的购物网站。 主要工作： 使用HTML，CSS和JS搭建购物网站并基于AJAX与JS实现购物车功能。 基于Amazon EC2的Linux系统配置环境(Apache,PHP和SQLite)与安全设置。 基于Cookie与Session实现免登录功能。设置HttpOnly防止XSS。 使用PHP减少Web应用程序安全威胁。比如SQL注入、XSS注入与参数篡改漏洞、CSRF。 为域名申请SSL证书并使用Paypal的SDK实现支付功能。 项目名称：基于图数据库HugeGraph的医学知识图谱可视化系统 2020年 05月 - 2021年 05月 技术栈：前端：Vue + Echarts + Element-UI 后端：SpringBoot + HugeGraph 项目介绍：本项目是我的本科毕设，背景是实验室与协和医院合作开发智能医疗项目，旨在提高就诊效率等。本人的工作是将存在图数据库里的医学数据通过可视化的方式呈现出来，方便病人查阅相关医学资料。 主要工作： 利用Vue2+Echarts+Element-UI实现可视化界面。 运用Springboot实现后端查询数据接口。 运用拦截器和JWT实现特定请求的登录认证和鉴权。 利用ExceptionHandler统一处理异常，减少代码耦合度。 项目地址：https://blog.linyouguang.com/2020/09/08/Graph-Database-Visualization/ 研究经历 研究项目名称：大学生创新创业训练项目 项目名称：基于深度学习遥感图像信息提取 项目描述：我们将自动驾驶领域的实时语义模型BiseNet复现于遥感数据集Postdam上，实现了在具有实时处理速度的情况下达到了0.88的高精度。 项目成果：国家级 论文链接：https://ieeexplore.ieee.org/document/9553336 专业技能 前端：熟悉JS/HTML/CSS，ES6，了解前端页面性能监控相关知识 后端：了解Java，了解其集合类，JVM，Java内存区域，垃圾回收。掌握多线程编程，java内存模型，AQS。 计算机基础：了解操作系统，了解虚拟内存，了解TCP/IP 网络架构与HTTP协议 数据库：了解SQL语句的基本用法，了解MySQL基本架构，索引，锁，事务机制。 技能/证书及其他 证书：字节前端青训营结营证书、校级三等奖学金、优秀团员 语言：IELTS-6.5 Youguang Lin 18810018512 ｜ 1093742432@qq.com Github ｜Blog Education The Chinese University of Hong Kong Sep 2021 - Nov 2022 Information Engineering - Master - College of Engineering 3.54/4.00 Beijing University of Posts and Telecommunications Sep 2017 - Jun 2021 Internet of Things Engineering - Bachelor - International College 3.45/4.00 INTERNSHIP EXPERIENCE Company Name：HelloToby May 2022 - Aug 2022 BackGround：Toby is a community driven marketplace for services. My job is to maintain and develop the background data management system, which mainly includes the contract management and the task center, etc. In addition, it also includes support for management personnel to add, delete, modify and check contracts. Works： Solve cross-domain problems in development and testing environments Write a SendGrid template as a company email template Replace component library (Vue Material replaced with Ant Design Vue) Maintain existing components PROJECT Project Name：Monitoring System July 2022 - Sep 2022 Technology stack： Vue3 + Vite + TypeScript + Arco Design + Flask + MongoDB + Nginx Project introduction：This project mainly implements a front-end monitoring system. The user places the buried code developed by this project in the front-end project that needs to be monitored, and the user's behavior data will be recorded. Users can monitor the project status through a middle platform page. Works： Responsible for user detailed inspection and general overview page, write related front-end and back-end interfaces, user behavior capture SDK. Use Nginx to deploy the front and back ends. Automatically generate documents using Swagger Project Address：www.linyouguang.com:8080/login Project Document：https://blog.linyouguang.com/2022/09/01/Monitor-SDK/ Project Name：Shopping Website Jan 2022 - Mar 2022 Technology stack：FrontEnd：JS + CSS + HTML BackEnd：SqlLite + PHP Project introduction：The postgraduate course \"Network Programming and Security. The aim is to develop a well-functioning and secure shopping site. Works： Use HTML,CSS and JS to build shopping websites and implement shopping cart function based on AJAX and JS. Linux system configuration environment (Apache,PHP and SQLite) and security settings based on Amazon EC2. Implement login-free function based on Cookie and Session. Set HttpOnly to prevent XSS. Use PHP to reduce security threats to Web applications. Such as SQL injection, XSS injection and parameter tampering vulnerabilities, CSRF. Apply for SSL certificate for domain name and use Paypal SDK to realize payment function. Project Name：Medical Knowledge Atlas Visualization System Based on Graph Database HugeGraph May 2020 - May 2021 Technology stack：FrontEnd：Vue + Echarts + Element-UI BackEnd：SpringBoot + HugeGraph Project introduction：This project is my undergraduate program. The background is the cooperation between the laboratory and Union Medical College Hospital to develop an intelligent medical project to improve the efficiency of medical treatment. My job is to present the medical data in the graph database in a visual way to facilitate patients to consult relevant medical data. Works： Use Vue framework to cooperate with UI component library Element and visual library Echarts to build a front-end display platform Use the Springboot framework to independently build a back-end platform based on MVC pattern Obtain data through Restful API and Gremlin query language provided by HugeGraph officials Project address：https://blog.linyouguang.com/2020/09/08/Graph-Database-Visualization/ RESEARCH EXPERIENCE Innovation and entrepreneurship training program for college students Project name：Remote sensing image information extraction based on deep learning Project description：We reproduced the real-time semantic model BiseNet in the field of autonomous driving on the remote sensing dataset Postdam, and achieved a high accuracy of 0.88 with real-time processing speed. Project achievements：National level Paper Link：https://ieeexplore.ieee.org/document/9553336 SKILLS Front-end：Familiar with JS/HTML/CSS, ES6, and knowledge about front-end page performance monitoring Backend Java：Familiar with collection classes, familiar with JVM, familiar with Java memory area, garbage collection. Master multi-threaded programming, java memory model, AQS. Computer Basics：Master the operating system, understand the virtual memory, understand the TCP/IP network architecture and the HTTP protocol Database MySQL：Master the basic usage of SQL statements, familiar with the basic MySQL architecture, indexes, locks, and transaction mechanisms. AWARDS Certificate： Byte Front-end Youth Training Camp Completion Certificate School-level Third-Class Scholarship Language：IELTS-6.5","link":"/resume/index.html"},{"title":"中文简历","text":"第一页 第二页 这是一个全宽(fullwidth)圆角拨动开关状(toggle-rounded)标签页容器的第一页。 这是一个全宽(fullwidth)圆角拨动开关状(toggle-rounded)标签页容器的第二页。 林佑光 18810018512 ｜ 1093742432@qq.com Github ｜个人博客 应届生 教育经历 primary 一个主题色(primary)的代码块。 香港中文大学 2021年09月-2022年11月 香港 信息工程 硕士 工程学院 GPA: 3.54/4.00 北京邮电大学 2017年09月-2021年06月 北京 物联网工程 学士 物联网工程 GPA: 3.45/4.00 实习经历 公司名称：HelloToby 2022年 05月 - 2022年 08月 实习背景：该公司为香港一家一站式服务配对公司。本人工作是维护面向后端人员使用的数据管理系统，完善支持后端管理人员对客户合同与任务的增删改查的功能。 主要工作： 1、解决开发和测试环境下的跨域问题 2、编写SendGrid模版作为公司邮件模版 3、更换组件库(Vue Material替换为Ant Design Vue) 4、使用Vue2框架维护现有组件 5、使用Git进行代码提交 公司名称：清氢捷能科技有限公司 2021年 06月 - 2021年 08月 项目介绍：此项目为清华大学车辆与运载学院新能源汽车测试组参与的国家重点研发计划科技冬奥重点专项“氢能出行”。本人的工作是负责构建信息监控大数据平台，实时展示新能源汽车的数据信息。 主要工作： 1、使用Vue2框架搭配Echarts与百度地图通过点聚合方式显示78辆氢能源汽车的数据 2、使用Flex与Grid布局 3、使用Webpack打包与部署前端应用 项目地址：https://blog.linyouguang.com/2021/09/08/New-Energy-Car/ 项目经历 项目名称：前端监控系统 2022年 07月 - 2022年 09月 技术栈：前端：Vue3 + Vite + TypeScript + Arco Design 后端： Flask + MongoDB + Nginx 项目介绍：本项目主要是实现一个前端监控系统，使用者将本项目开发的埋点代码放置在需要被监控的前端项目中，用户的行为数据会被记录，使用者可以通过一个中台页面监控项目情况。 主要工作： 1、负责用户细查及总概览页面，编写相关前后端接口、用户行为捕获sdk。 2、使用Nginx部署前后端。 3、使用Swagger自动生成文档 项目地址：www.linyouguang.com:8080/login 项目文档：https://blog.linyouguang.com/2022/09/01/Monitor-SDK/ 项目名称：购物网站 2022年 01月 - 2022年 03月 技术栈：前端：JS + CSS + HTML 后端：SqlLite + PHP 项目介绍：开发一个运作良好且安全的购物网站。 主要工作： 1、使用HTML，CSS和JS搭建购物网站并基于AJAX与JS实现购物车功能。 2、基于Amazon EC2的Linux系统配置环境(Apache,PHP和SQLite)与安全设置。 3、基于Cookie与Session实现免登录功能。设置HttpOnly防止XSS。 4、使用PHP减少Web应用程序安全威胁。比如SQL注入、XSS注入与参数篡改漏洞、CSRF。 5、为域名申请SSL证书并使用Paypal的SDK实现支付功能。 项目名称：基于图数据库HugeGraph的医学知识图谱可视化系统 2020年 05月 - 2021年 05月 技术栈：前端：Vue + Echarts + Element-UI 后端：SpringBoot + HugeGraph 项目介绍：本项目是我的本科毕设，背景是实验室与协和医院合作开发智能医疗项目，旨在提高就诊效率等。本人的工作是将存在图数据库里的医学数据通过可视化的方式呈现出来，方便病人查阅相关医学资料。主要工作： 1、利用Vue2+Echarts+Element-UI实现可视化界面 2、运用Springboot实现后端查询数据接口 3、运用拦截器和JWT实现特定请求的登录认证和鉴权； 4、利用ExceptionHandler统一处理异常，减少代码耦合度； 项目地址：https://blog.linyouguang.com/2020/09/08/Graph-Database-Visualization/ 研究经历 研究项目名称：大学生创新创业训练项目 项目名称：基于深度学习的遥感图像信息提取 项目描述：我们将自动驾驶领域的实时语义模型BiseNet复现于遥感数据集Postdam上，实现了在具有实时处理速度的情况下达到了0.88的高精度。 项目成果：国家级 论文链接：https://ieeexplore.ieee.org/document/9553336 专业技能 前端JS：熟悉JS/HTML/CSS，ES6，了解前端页面性能监控相关知识 后端Java：熟悉集合类，了解JVM，熟悉Java内存区域，垃圾回收。掌握多线程编程，java内存模型，AQS。 计算机基础：掌握操作系统，了解虚拟内存，了解TCP/IP 网络架构与HTTP协议数据库MySQL：掌握SQL语句的基本用法，熟悉MySQL基本架构，索引，锁，事务机制。 技能/证书及其他 证书：字节前端青训营结营证书、校级三等奖学金、优秀团员 语言：IELTS-6.5 Youguang Lin 18810018512 ｜ 1093742432@qq.com Github ｜Blog Education The Chinese University of Hong Kong Sep 2021 - Nov 2022 Hong Kong Information Engineering - Master - College of Engineering GPA: 3.54/4.00 Beijing University of Posts and Telecommunications Sep 2017 - Jun 2021 Beijing Internet of Things Engineering - Bachelor - International College GPA 3.45/4.00 INTERNSHIP EXPERIENCE HelloToby May 2022 - Aug 2022 Internship background: Toby is a community driven marketplace for services. My job is to maintain and develop the background data management system, which mainly includes the contract management and the task center, etc. In addition, it also includes support for management personnel to add, delete, modify and check contracts. Main tasks: Solve cross-domain problems in development and testing environments Write a SendGrid template as a company email template Replace component library (Vue Material replaced with Ant Design Vue) Maintain existing components PROJECT EXPERIENCE Project Name : Front-end Monitoring System July 2022 - Sep 2022 Technology stack: Vue3 + Vite + TypeScript + Arco Design + Flask + MongoDB + Nginx Project introduction: This project mainly implements a front-end monitoring system. The user places the buried code developed by this project in the front-end project that needs to be monitored, and the user’s behavior data will be recorded. Users can monitor the project status through a middle platform page. Main tasks Responsible for user detailed inspection and general overview page, write related front-end and back-end interfaces, user behavior capture SDK. Use Nginx to deploy the front and back ends. Project address: www.linyouguang.com:8080/login Project Name : Shopping Website Jan 2022 - Mar 2022 Technology stack :PHP, JS, CSS, HTML, SqlLite Project Introduction: The postgraduate course “Network Programming and Security. The aim is to develop a well-functioning and secure shopping site. Main tasks: Use HTML,CSS and JS to build shopping websites and implement shopping cart function based on AJAX and JS. Linux system configuration environment (Apache,PHP and SQLite) and security settings based on Amazon EC2. Implement login-free function based on Cookie and Session. Set HttpOnly to prevent XSS. Use PHP to reduce security threats to Web applications. Such as SQL injection, XSS injection and parameter tampering vulnerabilities, CSRF. Apply for SSL certificate for domain name and use Paypal SDK to realize payment function. Project Name: Medical Knowledge Atlas Visualization System Based on Graph Database HugeGraph Technology Stack :SpringBoot, HugeGraph, Vue, Echarts, Element-UI Project Description: This project is my undergraduate program. The background is the cooperation between the laboratory and Union Medical College Hospital to develop an intelligent medical project to improve the efficiency of medical treatment. My job is to present the medical data in the graph database in a visual way to facilitate patients to consult relevant medical data. Main tasks: Use Vue framework to cooperate with UI component library Element and visual library Echarts to build a front-end display platform Use the Springboot framework to independently build a back-end platform based on MVC pattern Obtain data through Restful API and Gremlin query language provided by HugeGraph officials RESEARCH EXPERIENCE Innovation and entrepreneurship training program for college students Project name: Remote sensing image information extraction based on deep learning Project description: We reproduced the real-time semantic model BiseNet in the field of autonomous driving on the remote sensing dataset Postdam, and achieved a high accuracy of 0.88 with real-time processing speed. Project achievements: National level Paper Link :https://ieeexplore.ieee.org/document/9553336 SKILLS LIST Front-end JS: Familiar with JS/HTML/CSS, ES6, and knowledge about front-end page performance monitoring Backend Java: Familiar with collection classes, familiar with JVM, familiar with Java memory area, garbage collection. Master multi-threaded programming, java memory model, AQS. Computer Basics: Master the operating system, understand the virtual memory, understand the TCP/IP network architecture and the HTTP protocolDatabase MySQL: Master the basic usage of SQL statements, familiar with the basic MySQL architecture, indexes, locks, and transaction mechanisms. AWARDS Certificate Byte Front-end Youth Training Camp Completion Certificate School-level Third-Class Scholarship Language IELTS-6.5","link":"/resume/index%E7%9A%84%E5%89%AF%E6%9C%AC.html"}]}