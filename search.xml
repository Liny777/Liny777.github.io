<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DOM重点核心</title>
    <url>/2022/01/13/DOM%E9%87%8D%E7%82%B9%E6%A0%B8%E5%BF%83/</url>
    <content><![CDATA[<p>DOM 文档对象模型 （Document Object Model) 是W3C组织推荐的处理可扩展标记语言 （HTML或者XML）的标准编程接口。<br>通过这些DOM接口，可以改变网页的内容，结构和样式。<br>1、对于JS，为了能够使JS操作HTML，JS就有了一套自己的DOM编程接口。<br>2、对于HTML，dom使得html形成一棵dom树，包括文档，元素，节点。</p>
<ul>
<li><p>文档：一个页面就是一个文档，DOM中使用Document表示</p>
</li>
<li><p>元素：页面中的所有标签都是元素，DOM中使用element表示</p>
</li>
<li><p>节点：网页中的所有内容都是节点（标签，属性，文本，注释等），DOM中使用node表示<br>我们获取过来的<strong>DOM元素是一个对象（Object）</strong>，所以称为文档对象模型。<br>关于dom操作，我们主要针对于元素的操作。主要有创建，增，删，改，查、属性操作、事件操作。</p>
</li>
</ul>
<span id="more"></span>

<h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>1、document.write（直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘，同document.write）<br>2、innerHTML （将内容写入某个DOM节点，不会导致页面全部重绘，创建多个元素效率更高（不要拼接字符串，采取数组形式[document.body.innerHTML = array.join(‘’);]拼接），结构稍微复杂）<br>3、createElement （创建多个元素效率稍低一点点，但是结构更清晰）</p>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><p>1、appendChild （末尾追加）<br>2、insertBefore （前面追加）</p>
<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><p>1、removeChild</p>
<h1 id="改-——-主要修改dom的元素属性，dom元素的内容，属性，表单的值等"><a href="#改-——-主要修改dom的元素属性，dom元素的内容，属性，表单的值等" class="headerlink" title="改 —— 主要修改dom的元素属性，dom元素的内容，属性，表单的值等"></a>改 —— 主要修改dom的元素属性，dom元素的内容，属性，表单的值等</h1><p>1、修改元素属性：src，href，title等<br>2、修改普通元素内容：innerHTML（识别html标签，W3C标准，保留空格和换行。推荐），innerText（不识别html标签，非标准，去除空格和换行）<br>3、修改表单元素：value，type，disabled等<br>4、修改元素样式：style（修改比较少的时候使用，行内样式操作，所以优先级高，样式采取驼峰命名法 比如 fontSize,backgroundColor），className（修改比较多的时候使用，类名样式操作，会直接更改元素类名，会覆盖原先的类名，如果想保留原先的类名，我们可以这么做，多类名选择器）<br>查 —— 主要获取查询dom的元素<br>1、DOM提供的API方法：getElementById，getElementsByTagName(大小写敏感,若在当前Document下没有找到，则返回null,古老用法不推荐)<br>2、H5提供的新方法：querySelector(只获取第一个元素，类.,id是#)，querySelectorAll （提倡）<br>3、利用节点操作获取元素：父（parentNode）、子（children）、兄（previousElementSibling、nextElementSibling）提倡<br>4、获取特殊对象：document.body(返回body元素对象) document.documentElement(返回html元素对象)<br>5、parentNode.childNodes (标准 子节点 childNodes所有的子节点 包含 元素节点 文本节点等）<br>6、parentNode.children是一个只读属性，返回所有的子元素节点，它只返回子元素节点，其余节点不返回（这个是我们重点掌握的）虽然children是一个非标准，但是得到了各个游览器的支持，因此我们可以放心使用<br>7、parentNode.firstChild和parentNode.lastChild<br>firstChild返回第一个子节点，找不到则返回null。同样，也是包含所有的节点<br>firstChild第一个子节点，不管是文本节点还是元素节点<br>8、firstElementChild（返回第一个子元素节点，但是有兼容性问题 IE9以上才支持）lastElementChild返回第一个子元素节点<br>9实际开发中，firstChild和lastChild包含其他节点，操作不方便，而firstElementChild和lastElementChild又有兼容性问题，那么我们如何<br>获取第一个子元素节点或者最后一个子元素节点呢？解决方法：实际开发中，既没有兼容性问题，又返回第一个子元素ol.children[0]和ol.children[ol.children.length-1]</p>
<h1 id="属性操作-——-主要针对自定义属性"><a href="#属性操作-——-主要针对自定义属性" class="headerlink" title="属性操作 —— 主要针对自定义属性"></a>属性操作 —— 主要针对自定义属性</h1><p>1、setAttribute：设置dom的属性值<br>2、getAttribute：得到dom的属性值<br>3、removeAttribute：移除属性<br>4、常规取非自定义属性：element.属性 = 值<br>// h5新增的获取自定义属性的方法 它只能获取data-开头的<br>// dataset是一个集合里面存放了所有以data开头的自定义属性<br>console.log(div.dataset)<br>console.log(div.dataset.index)<br>console.log(div.dataset[‘index’])<br>如果是 data-list-name<br>div.getAttribute(‘data-list-name’)<br>console.log(div.dataset.listName)  驼峰命名法</p>
<h1 id="事件操作-——-给元素注册事件，采取事件源-事件类型-事件处理程序"><a href="#事件操作-——-给元素注册事件，采取事件源-事件类型-事件处理程序" class="headerlink" title="事件操作 —— 给元素注册事件，采取事件源.事件类型 = 事件处理程序"></a>事件操作 —— 给元素注册事件，采取事件源.事件类型 = 事件处理程序</h1><p>onclick 鼠标点击左键触发<br>onmouseover 鼠标经过触发<br>onmouseout 鼠标离开触发<br>onfocus 获得鼠标焦点触发<br>onblur 失去鼠标焦点触发<br>onmousemove 鼠标移动触发<br>onmouseup 鼠标弹起触发<br>onmousedown 鼠标按下触发</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>大四-清华大学实习——清华大学车辆与运载学院汽车安全与节能国家重点实验室新能源汽车测试组</title>
    <url>/2022/01/13/%E5%A4%A7%E5%9B%9B-%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%AE%9E%E4%B9%A0%E2%80%94%E2%80%94%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E8%BD%A6%E8%BE%86%E4%B8%8E%E8%BF%90%E8%BD%BD%E5%AD%A6%E9%99%A2%E6%B1%BD%E8%BD%A6%E5%AE%89%E5%85%A8%E4%B8%8E%E8%8A%82%E8%83%BD%E5%9B%BD%E5%AE%B6%E9%87%8D%E7%82%B9%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%96%B0%E8%83%BD%E6%BA%90%E6%B1%BD%E8%BD%A6%E6%B5%8B%E8%AF%95%E7%BB%84/</url>
    <content><![CDATA[<p>作品展示：</p>
<img src="/2022/01/13/%E5%A4%A7%E5%9B%9B-%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%AE%9E%E4%B9%A0%E2%80%94%E2%80%94%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E8%BD%A6%E8%BE%86%E4%B8%8E%E8%BF%90%E8%BD%BD%E5%AD%A6%E9%99%A2%E6%B1%BD%E8%BD%A6%E5%AE%89%E5%85%A8%E4%B8%8E%E8%8A%82%E8%83%BD%E5%9B%BD%E5%AE%B6%E9%87%8D%E7%82%B9%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%96%B0%E8%83%BD%E6%BA%90%E6%B1%BD%E8%BD%A6%E6%B5%8B%E8%AF%95%E7%BB%84/5.png" class="" title="This is an image">

<span id="more"></span>

<p>作品描述：</p>
<p>科技冬奥重点专项的大数据平台</p>
<p>实时展示车辆的数据信息</p>
<p>Vue+Echarts+socket.io</p>
]]></content>
      <categories>
        <category>作品集</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
        <tag>Vue</tag>
        <tag>Socket.io</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱可视化系统</title>
    <url>/2022/01/13/%E5%A4%A7%E5%9B%9B-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>作品描述：</p>
<p>知识图谱可视化系统</p>
<p>Vue+Echarts+Element-UI+Springboot + HugeGraph + MongoDB :</p>
<p>作品展示：</p>
<img src="/2022/01/13/%E5%A4%A7%E5%9B%9B-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/4.png" class="" title="This is an image">

<span id="more"></span>

<img src="/2022/01/13/%E5%A4%A7%E5%9B%9B-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/7.png" class="" title="This is an image">

<img src="/2022/01/13/%E5%A4%A7%E5%9B%9B-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/8.png" class="" title="This is an image">

<img src="/2022/01/13/%E5%A4%A7%E5%9B%9B-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/10.png" class="" title="This is an image">

<p>视频展示-1：</p>
<iframe height=500 width="100%" src='https://player.youku.com/embed/XNTE2OTU2ODQ4MA==' frameborder=0 'allowfullscreen'></iframe>

<p>视频展示-2:</p>
<iframe height=498 width=510 src='https://player.youku.com/embed/XNTE2OTU3NzgwOA==' frameborder=0 'allowfullscreen'></iframe>

<p>代码地址：</p>
<p><a href="https://github.com/Liny777/Visualization-vue-sample">https://github.com/Liny777/Visualization-vue-sample</a></p>
]]></content>
      <categories>
        <category>作品集</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
        <tag>Vue</tag>
        <tag>Element-ui</tag>
        <tag>HugeGraph</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>This指向问题</title>
    <url>/2022/01/15/this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>this指向问题 一般情况下this的最终指向的是那个调用它的对象</p>
<ol>
<li><p>全局作用域或者普通函数中的this指向全局对象window(注意定时器里面的this指向window)</p>
</li>
<li><p>方法调用中谁调用this指向谁</p>
</li>
<li><p>构造函数中的this指向构造函数的实例</p>
</li>
</ol>
<span id="more"></span>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>进程与线程的区别小结</title>
    <url>/2022/01/15/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>进程是系统进行资源分配和调度的  “独立” 单位。</p>
<p>线程是CPU真正运行 实现CPU调度和分配的 “基本” 单位。</p>
<p>主要从两方向分析</p>
<p>1、线程简单的原因</p>
<p>2、进程困难的原因</p>
<p>主要从两方面解答</p>
<p>1、内存</p>
<p>2、通信</p>
<p>3、同步</p>
<span id="more"></span>

<p>1、线程简单的原因 —— 通信</p>
<p>线程之间通信：在同一进程下，共享全局变量，静态变量等数据，指针指向同一个内存，交互很方便。</p>
<p>2、进程困难的原因 —— 通信</p>
<p>进程之间通信：进程可以通过套接字、管道、信号交互、共享内存、消息队列等进行通信</p>
<p>进而可能问你啥是 套接字、管道、信号交互、消息队列 ？</p>
<p>3、线程简单的原因 —— 同步</p>
<p>线程之间需要满足一些合作规则才能进行合作，因此 如何实现 线程同步 ？</p>
<p>4、进程困难的原因 —— 同步</p>
<p>在单个CPU下，实际上在任何时刻只能有一个进程处于执行状态。而其他进程则处于非执行状态。我们是如何确定在任意时刻到底由哪个进程执行，哪些不执行呢？（如何进行进程调度？）</p>
<p>5、线程简单的原因 —— 内存</p>
<p>栈：主线程main函数、进行函数调用的参数和返回地址、局部变量等内容都会被压入栈内</p>
<p>PC（Program Couner）：程序计数器，PC的指针指向代码所在的内存地址。</p>
<p>TLS（Thread local storage）：分配内存，存放变量</p>
<p>6、进程困难的原因 —— 内存</p>
<p>进程与进程之间相对独立</p>
<p>进程可以包括几个或者上百个线程在运行</p>
<p>内存（逻辑内存）包括在进程里面，每个进程的内存都是互相独立的，但从一个更高的层次上看，不同的进程也共享着一个巨大的空间，这个空间就是整个计算机</p>
<p>进程共有文件/网络句柄（handle），这样可以打开同一个文件，抢同一个网络端口</p>
<p>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
]]></content>
      <categories>
        <category>面经小知识</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>JS执行机制-同步与异步</title>
    <url>/2022/01/15/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<img src="/2022/01/15/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/1.jpg" class="" title="This is an image">

<span id="more"></span>

<h1 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h1><h2 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h2><p>同步任务都在主线程上执行，形成一个执行栈</p>
<h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><p>JS的异步是通过回调函数实现的。<br>一般而言，异步任务有以下三种类型：<br>1、普通事件，如click，resize等<br>2、资源加载，如load，error等<br>3、定时器：包括setInterval，setTimeout等<br>异步任务相关回调函数添加到任务队列中（任务队列也称为消息队列）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<h2 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h2><p>1、先执行执行栈中的同步任务<br>2、异步任务（回调函数）放入任务队列中。<br>3、一旦执行栈中所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（event loop)</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>简单与复杂数据类型</title>
    <url>/2022/01/15/%E7%AE%80%E5%8D%95%E4%B8%8E%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型</p>
<ul>
<li>值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型<br>string number boolean undefined null</li>
<li>简单数据类型 null 返回的是一个空的对象 object // 当时设计的时候有问题，所以这个错误一直继续下去<br>// 如果有个变量我们以后打算存储为对象，暂时没想好放啥，这个时候就给null</li>
<li>引用类型：复杂数据类型，在存储变量中存储的仅仅是地址（引用），因此叫做引用数据类型<br>通过new关键字创建的对象（系统对象，自定义对象），如Object，Array，Date等</li>
</ul>
<hr>
<span id="more"></span>

<p>堆和栈</p>
<ul>
<li>简单存栈<br>1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈</li>
<li>复杂存堆<br>1、堆（操作系统）：存储复杂数据类型（对象），一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收<br>！！ 注意 JavaScript中没有堆栈的概念，通过堆栈的方式，可以让大家更容易理解代码的一些执行方式，便于将来的学习</li>
</ul>
<p>简单数据类型的内存分配<br>1、存放在栈里面，直接开辟一个空间存放 值<br>变量名 指向 栈里值</p>
<p>复杂数据类型的内存分配<br>1、引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间里<br>变量名 指向 栈里的值（存的是地址，不是值） 再从地址 去 堆里找值<br>2、首先在栈里面存放地址（十六进制表示）然后这个地址只想堆里面的数据</p>
<p>简单类型如何传参<br>1、函数形参也可以看作是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量<br>2、拷贝值  然后传值</p>
<p>复杂数据类型如何传参<br>1、函数的形参也可以看作是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象<br>2、拷贝地址，然后传地址</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>高级事件</title>
    <url>/2022/01/15/%E9%AB%98%E7%BA%A7%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>1、能够写出元素注册事件的两种方式</p>
<p>2、能够说出删除事件的两种方式</p>
<p>3、能够说出DOM事件流的三个阶段</p>
<p>4、能够利用时间对象完成跟随鼠标案例</p>
<p>5、能够封装阻止冒泡的兼容性函数</p>
<p>6、能够说出事件委托的原理</p>
<p>7、能够说出常用的鼠标和键盘事件</p>
<span id="more"></span>

<p>1.1 注册事件概述（绑定事件）</p>
<p>给元素添加事件，称为注册事件或者绑定事件。</p>
<p>注册事件有两种方式：传统方式和方法监听注册方式</p>
<p>传统注注册方式</p>
<p>1、利用on开头的事件onclick</p>
<p>2、&lt;button onclick=”alert(“hi~”)”&gt;</button></p>
<p>btn.onclick = function(){}</p>
<p>特点：注册事件的唯一性</p>
<p>同一个元素同一个事件只能设置一个处理函数</p>
<p>方法监听注册方式</p>
<p>w3c标准，推荐方式</p>
<p>addEventListener()它是一个方式</p>
<p>IE9之前的IE不支持此方法，可使用attachEvent（）代替</p>
<p>特点：同一个元素同一个事件可以注册多个监听器</p>
<p>1.2 addEventListener事件监听方式</p>
<p>eventTarget.addEventListener(type,listener[,useCapture])</p>
<p>eventTarget.addEventListener()方法将指定的监听器注册到eventTarget(目标对象)上，当该对象触发指定的事件时，就会执行事件处理函数。</p>
<p>该方法接受三个参数：</p>
<p>type：事件类型字符串，比如click，mouseover,注意这里不要带on</p>
<p>listener:事件处理函数，事件发生时，会调用该监听函数</p>
<p>useCapture：可选参数，是一个布尔值，默认是false，学完DOM事件流后，我们再进一步学习</p>
<p>attachEvent 非标准 不要在生产环境使用</p>
<p>eventTarget.attachEvent(eventNameWithOn,callback)</p>
<p>eventTarget.attachEvent()方法将指定的监听器注册到eventTarget（目标对象）上，当该对象触发指定的事件时，指定的回调函数就会被执行。</p>
<p>该方法接受两个参数：</p>
<p>eventnameWithOn:事件类型字符串，比如onclick,onmouseover,这里要带on</p>
<p>callback：事件处理函数，当目标触发事件时回调函数被调用。</p>
<p>注册事件兼容性解决方案</p>
<p>function addEventListener(element,eventName,fn){</p>
<p>​    //判断当前游览器是否支持addEventListener方法</p>
<p>​    if(element.addEventListener){</p>
<p>​        element.addEventListener(eventName fn); // 第三个参数，默认是false</p>
<p>​    }else if (element.attachEvent){</p>
<p>​        element.attachEvent(‘on’+eventName,fn)</p>
<p>​    }else{</p>
<p>​        // 相当于 element.onclick = fn</p>
<p>​        element[‘on’+eventName] = fn;</p>
<p>​    }</p>
<p>}</p>
<p>兼容性处理原则：首先照顾大多数游览器，再处理特殊游览器</p>
<p>\2. 删除事件（解绑事件）</p>
<p>2.1 删除事件的方式</p>
<p>1.传统注册方式</p>
<p>eventTarget.onclick = null</p>
<p>2.2 方法监听注册方式</p>
<p>eventTarget.removeEventListener(type,listener[,useCapture])</p>
<p>eventTarget.detachEvent(eventNameWithOn,callback)</p>
<hr>
<p>DOM事件流</p>
<p>事件流描述的是从页面中接受事件的顺序。</p>
<p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流。</p>
<p>DOM事件流分为3个阶段</p>
<p>1、捕获阶段</p>
<p>2、当前目标阶段</p>
<p>3、冒泡阶段</p>
<p>事件冒泡：IE最早提出，事件开始时由最具体的元素接受，然后逐级向上传播到DOM最顶层节点的过程</p>
<p>事件捕获：网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到最具体的元素接受过程。</p>
<p>1、JS代码中只能执行捕获或者冒泡其中的一个阶段</p>
<p>2、onclick和attachEvent只能得到冒泡阶段</p>
<p>3、addEventListener（type，listener[,useCapture])第三个参数如果是true，表示事件捕获阶段调用事件处理程序，如果是false（不写默认就是false）表示在事件冒泡阶段调用事件处理程序。</p>
<p>4、实际开发中我们很少使用事件捕获，我们更关注事件冒泡。</p>
<p>5、有些事件是没有冒泡的，比如onblur,onfocus,onmouseenter,onmouseleave</p>
<p>6、事件冒泡有时候会带来麻烦，有时候会帮助很巧妙地做某些事情。</p>
<p>事件对象</p>
<p>1.event 就是只有一个事件对象 写到我们侦听函数的小括号里面当形参来看</p>
<p>2.事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数</p>
<p>3.事件对象 是 我们事件的一系列相关数据的集合，跟事件相关的，比如鼠标点击里面就包含了鼠标相关信息，鼠标坐标啊，如果是键盘事件里面就包含</p>
<p>的键盘事件的信息 比如 判断用户按下了那个键</p>
<p>4、这个事件对象我们可以自己命名，比如event、evt、e</p>
<p>5、事件对象也有兼容性问题 ie678通过window.event 兼容性问题 e = e || window.event;</p>
<p>var div = document.querySelector(‘div’)</p>
<p>div.onclick = function(e){</p>
<p>​    console.log(e)</p>
<p>​    console.log(window.event)</p>
<p>​    e = e || window.event; // 如果e为真，就执行e，如果e为假，就会执行后面的window.event</p>
<p>}</p>
<p>div.addEventListener(‘click’,function(e){</p>
<p>​    console.log(e)</p>
<p>})</p>
<p>官方解释：event对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态</p>
<p>简单理解：事件发生后，跟事件相关的一系列信息数据的集合，都放到这个对象里面，这个对象就是事件对象event，它有很多属性和方法。</p>
<p>比如：</p>
<p>1、谁绑定了这个事件</p>
<p>2、鼠标触发事件的话就会得到鼠标相关信息，如鼠标位置</p>
<p>3、键盘触发事件的话，会得到键盘的相关信息，如按了哪个键</p>
<p>\4. 事件对象</p>
<p>4.4 事件对象的常见属性和方法</p>
<p>e.target 返回触发事件的对象 标准</p>
<p>e.srcElement 返回触发事件的对象 非标准 ie6-8使用</p>
<p>e.type 返回事件的类型，比如click mouseover 不带on</p>
<p>e.cancelBubble 该属性阻止冒泡 非标准ie6-8使用</p>
<p>e.returnValue该属性阻止默认事件 （默认行为）非标准ie6-8使用 比如不让链接跳转</p>
<p>e.preventDefault() 该属性阻止默认事件（默认行为）  标准 比如不让链接跳转</p>
<p>e.stopPropagation() 阻止冒泡 标准</p>
<p>// 1. e.target 返回的是触发事件对象（元素） this返回的是绑定事件的对象（元素）</p>
<p>阻止事件冒泡</p>
<p>阻止事件冒泡的两种方式</p>
<p>事件冒泡：开始时由具体的元素接受然后逐级向上传播到DOM最顶层节点</p>
<p>事件冒泡本身的特性，会带来的坏处，也会带来好处，需要我们灵活掌握</p>
<p>标准写法：利用事件对象里面的stopPropagation()方法</p>
<p>阻止事件冒泡的兼容性解决方案</p>
<p>if(e &amp;&amp; e.stopPropagation){</p>
<p>​    e.stopPropagation()</p>
<p>}else{</p>
<p>​    window.event.cancelBubble = true</p>
<p>}</p>
<p>事件委托（代理，委托）</p>
<p>事件委托也称为事件代理，在jQuery里面称为事件委派</p>
<p>事件委托的原理： **********（必考）</p>
<p>不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置的每个子节点上</p>
<p>以上案例：给ul注册点击事件，然后利用事件对象的target来找到当前点击的li，因为点击li，事件会冒泡到ul上，ul有注册事件，就会触发事件监听器</p>
<p>事件委托的作用</p>
<p>我们只操作了一次DOM，提高程序性能</p>
<p>常用的鼠标事件</p>
<p>不给别人复制文字</p>
<p>1、禁止鼠标右键菜单</p>
<p>contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单</p>
<p>我们可以禁用右键</p>
<p>document.addEventListener(‘contextmenu’,function(e){</p>
<p>​    e.preventDefault()</p>
<p>})</p>
<p>2、禁止鼠标选中 (selectstart)</p>
<!-- document.querySelector -->



<p>常用鼠标事件对象</p>
<p>event对象代表事件的状态 跟事件相关的</p>
<p>鼠标事件对象</p>
<p>e.clientX 返回鼠标相对于浏览器窗口可视区的X坐标</p>
<p>e.clientY 返回鼠标相对于浏览器窗口可视区的Y坐标</p>
<p>e.pageX 返回鼠标相对于文档页面的X坐标 IE9+支持  重点记住</p>
<p>e.pageY 返回鼠标相对于文档页面的Y坐标 IE9+支持  重点记住</p>
<p>e.screenX 返回相对于电脑屏幕的X坐标</p>
<p>e.screenY 返回相对于电脑屏幕的Y坐标</p>
<p>鼠标事件</p>
<p>1、鼠标不断的移动，使用鼠标移动事件mousemove</p>
<p>2、在页面中移动，给document注册事件</p>
<p>3、图片要移动距离，而且不占位置，我们使用绝对定位即可</p>
<p>4、核心原理：每次鼠标移动，我们都会获得最新的鼠标坐标，把这个x和y坐标做为图片的top和left值就可以移动图片</p>
<p>常用的键盘事件</p>
<p>事件除了使用鼠标触发，还可以使用键盘触发</p>
<p>onkeyup: 某个键盘按键被松开时触发</p>
<p>onkeydown: 某个键盘按键被按下时 触发 能识别功能键 比如 ctrl shift箭头等</p>
<p>onkeypress：某个键盘按键被按下时 触发 但是它不识别功能键 比如 ctrl shift箭头等</p>
<p>三个事件的执行顺序 keydown – keypress – keyup</p>
<p>键盘事件对象</p>
<p>document</p>
<p>// 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值</p>
<p>// 我们的keyup和keydown事件不区分字母大小写 a和A得到的都是65</p>
<p>// keypress 区分 字母大小写 a和A，a=97，A=65</p>
<p>// 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
