<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>IP与域名</title>
    <url>/2022/01/15/IP%E4%B8%8E%E5%9F%9F%E5%90%8D/</url>
    <content><![CDATA[<p>1、一个IP可以对应多个域名</p>
<p>一台主机可以托管多个网站，这种情况下这多个网站的IP地址可能就会相同。那么主机如何知道请求是发给哪个网站的呢？具体的实现过程是这样的，首先通过配置域名解析，将多个域名都解析到同一个主机IP，然后我们在该主机上通过配置来让主机可以将来自不同域名的请求转发给不同的网站程序去处理。主机会截获到请求头信息。然后获取到host这个请求头的值，这个值也就是该请求的来源域名。主机根据所配置的域名与网站程序的对应关系，将来自不同的域名的请求转发给不同的程序去处理。</p>
<p>2、一个域名也可以对应多个IP</p>
<p>这种情况一般是针对那种访问量特别大的网站，为了负载均衡，访问者会解析到距离最近的IP地址。例如百度，qq这种访问量巨大的网站，一般都有多个IP地址。可以通过wireshark抓包实验。</p>
<span id="more"></span>

<p>网站和域名的关系</p>
<p>一个域名就是一个网站吗？不是的。一个域名下面可以建立多个网站，例如一级域名是<a href="http://baidu.com，下面可以做很多二级域名。比如：http://zhidao.baidu.com，http://baike.baidu.com，http://tieba.baidu.com。这些二级域名可以做解析指定某个地址，也可以全部指向一个地址。所以说这个问题的答案取决于域名解析时的设置了。">http://baidu.com，下面可以做很多二级域名。比如：http://zhidao.baidu.com，http://baike.baidu.com，http://tieba.baidu.com。这些二级域名可以做解析指定某个地址，也可以全部指向一个地址。所以说这个问题的答案取决于域名解析时的设置了。</a></p>
<p>域名的分类</p>
<p>域名可以分为顶级域名、二级域名……顶级域名就是域名中最后一个.的右边，又被称为一级域名，比如.com、.cn等。最后一个.的左边是二级域名，以此类推。</p>
]]></content>
      <categories>
        <category>面经小知识</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>JS执行机制-同步与异步</title>
    <url>/2022/01/15/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<img src="/2022/01/15/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/1.jpg" class="" title="This is an image">

<span id="more"></span>

<h1 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h1><h2 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h2><p>同步任务都在主线程上执行，形成一个执行栈</p>
<h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><p>JS的异步是通过回调函数实现的。<br>一般而言，异步任务有以下三种类型：<br>1、普通事件，如click，resize等<br>2、资源加载，如load，error等<br>3、定时器：包括setInterval，setTimeout等<br>异步任务相关回调函数添加到任务队列中（任务队列也称为消息队列）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<h2 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h2><p>1、先执行执行栈中的同步任务<br>2、异步任务（回调函数）放入任务队列中。<br>3、一旦执行栈中所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（event loop)</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>This指向问题</title>
    <url>/2022/01/15/this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>this指向问题 一般情况下this的最终指向的是那个调用它的对象</p>
<ol>
<li><p>全局作用域或者普通函数中的this指向全局对象window(注意定时器里面的this指向window)</p>
</li>
<li><p>方法调用中谁调用this指向谁</p>
</li>
<li><p>构造函数中的this指向构造函数的实例</p>
</li>
</ol>
<span id="more"></span>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>从输入 URL 到页面展示到底发生了什么?</title>
    <url>/2022/01/15/%E4%BB%8E%E8%BE%93%E5%85%A5-URL-%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%B1%95%E7%A4%BA%E5%88%B0%E5%BA%95%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<p>从输入 URL 到页面展示到底发生了什么?</p>
<p>1、输入地址</p>
<p>2、浏览器查找域名的IP地址</p>
<p>3、浏览器向web服务器发送一个HTTP请求</p>
<p>4、服务器的永久重定向响应  ？</p>
<p>5、服务器处理请求</p>
<p>6、服务器返回一个HTTP响应</p>
<p>7、浏览器显示HTML</p>
<p>8、浏览器发送请求获取嵌入在HTML中的资源（如图片，音频，视频，CSS、JS等）</p>
<span id="more"></span>

<p>1、输入地址</p>
<p>当我们开始在浏览器中输入网址的时候，浏览器其实就已经在智能的匹配可能得到的url了，他会从历史记录，书签等地方，找到已经输入的字符串可能对应的url，然后给出智能提示，让你可以补全url地址。对于google的chrome的浏览器，他甚至会直接从缓存中把网页展示出来，就是说，你还没有按下enter，页面就出来了。</p>
<p>2、浏览器查找域名的IP地址</p>
<p>1、请求一旦发起，浏览器首先要做的事情就是解析这个域名，一般来说，浏览器会首先查看本地硬盘的hosts文件，看看其中有没有和这个域名对应的规则，如果有的话就直接使用hosts文件里面的ip地址。</p>
<p>2、如果在本地的hosts文件没有能够找到对应的ip地址，浏览器会发出一个DNS请求到本地DNS服务器。本地DNS服务器一般都是你的网络接入服务器商提供，比如中国电信，中国移动。</p>
<p>3、查询你输入的网址的DNS请求到本地DNS服务器之后，本地DNS服务器会首先查询它的缓存记录，如果缓存中有此条记录，就可以直接返回结果。此过程是递归的方式进行查询。如果没有，本地DNS服务器还要向DNS根服务器进行查询。</p>
<p>4、根DNS服务器没有记录具体的域名和IP地址的对应关系，而是告诉本地DNS服务器，你可以到域服务器上去继续查询，并给出域服务器的地址，这种过程是迭代过程。</p>
<p>5、本地DNS服务器继续向域服务器发出请求，在这个例子中，请求的对象是.com域服务器。.com域服务器收到请求之后，也不会直接返回域名和IP地址的对应关系，而是告诉本地DNS服务器，你的域名的解析服务器的地址。</p>
<p>6、最后，本地DNS服务器向域名的解析服务器发出请求，这时就能收到一个域名和IP地址对应关系，本地DNS服务器不仅要把IP地址返回给用户电脑，还要把这个对应关系保存在缓存中，以备下次别的用户查询时，可以直接返回结果，加快网络访问。</p>
<p>4和5其实就是</p>
<p>根DNS服务器 告诉你 .com这个服务器在哪（域服务器）</p>
<p>域服务器 告诉你 163.com这个服务器在哪 （DNS服务器）</p>
<p>1、什么是DNS</p>
<p>DNS ： Domain Name System 域名系统</p>
<p>因特网上作为域名和IP地址相互映射的一个分布式数据库 —— 一个存映射关系的数据库</p>
<p>作用：方便用户访问互联网，不用记住IP地址。</p>
<p>主机名 -》 IP地址 = 域名解析</p>
<p>2、DNS查询两种方式：递归和迭代查询</p>
<p>1、递归解析</p>
<p>当局部DNS服务器不能回答时候，一般先向域名的根域服务器查询，再由根域名服务器一级级向下查询。最后得到的查询结果返回给局部DNS服务器，再由局部DNS服务器返回给客户端。</p>
<p>2、迭代解析</p>
<p>局部DNS服务器不是自己向其他DNS服务器进行查询，而是把能解析该域名的其他DNS服务器的IP地址返回给客户端DNS程序，客户端DNS程序再继续向这些DBS服务器进行查询，直到得到查询结果为止。也就是说，迭代解析只是帮你找到相关的服务器而已，而不会帮你去查。</p>
<p>负载均衡：</p>
<p>同一个主机名配置多个IP地址（相当于备份了在多台电脑上，毕竟一个ip地址就可能是一个服务器或者程序），这样将客户端的访问引导到不同的机器上去，使得不同的客户端访问不同的服务器。</p>
<p>3、浏览器向web服务器发送一个HTTP请求</p>
<p>拿到域名对应的IP地址之后，浏览器会以一个随机端口（1024&lt;端口&lt;65535），向服务器的WEB程序（常用的是httpd，nginx等）80端口发起TCP的连接请求。这个连接请求到达服务器端后（这中间通过各种路由设备，局域网内除外）进入网卡，然后是进入到内核的TCP/IP协议栈（用于识别该连接的请求，解封包，一层一层的剥开），还有可能要经过Netfilter防火墙（属于内核模块）的过滤，最终到达WEB程序，最终建立TCP/IP连接。</p>
<p>建立了TCP连接之后，发起一个http请求。一个典型的http request header 一般需要包括请求的方法，例如GET，post等，客户端向服务器发起http请求的时候，会有一些请求消息，请求消息包含三个部分：</p>
<p>1、请求方法</p>
<p>第一行是URI协议/版本</p>
<p>请求头包含许多有关的客户端环境和请求正文的有用信息，例如请求头可以声明浏览器所用的语言，请求正文的长度。</p>
<p>3、请求正文</p>
<p>请求头和请求正文之间时一个空行，这个行非常重要，它表示请求头已经结束，接下来的是请求正文。请求正文中可以包含客户提交的查询字符串信息：</p>
<p>TCP</p>
<p>第一次握手：</p>
<p>客户端A将标志为止SYN置为1，随机产生一个值为seq=J（J的取值范围为1234567）的数据包到服务器，客户端A进入SYN_SENT状态，等待服务端B确认</p>
<p>第二次握手：</p>
<p>服务端B收到数据包后由标志位SYN=1知道客户端A请求建立连接，服务端B将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给客户端A以确认连接请求，服务端B进入SYN_RCVD状态。</p>
<p>第三次握手：</p>
<p>客户端A收到确认后，检查ack是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给服务端B，服务端B检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，客户端A和服务端B进入ESTABLISHED状态，完成三次握手，随后客户端A和服务端B之间可以开始传输数据来。</p>
<p>目的</p>
<p>第四版中讲“三次握手”的目的是“为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误”</p>
<p>TCP四次挥手</p>
<p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。</p>
<p>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1，（与-SYN相同，一个FIN占用一个序号），Server进入Close_wait状态</p>
<p>第三次挥手：Server发送一个FIN，用来关闭Server到Client的数据传送，Server进入LAST_ACK状态。</p>
<p>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p>
<p>4、为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</p>
<p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发生数据了但是还能接受数据，己方也未必全部数据都发送给对方了，所以已方可以立即close，也可以发送一些数据给对方后，再发生FIN报文给对方来表示同意现在关闭连接，因此，己方ACK和FIN一般都会分开发送。</p>
<p><a href="https://zhuanlan.zhihu.com/p/133906695">https://zhuanlan.zhihu.com/p/133906695</a></p>
]]></content>
      <categories>
        <category>面经小知识</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>二分（手写不调用库）+前缀+JS</title>
    <url>/2022/01/27/%E4%BA%8C%E5%88%86%EF%BC%88%E6%89%8B%E5%86%99%E4%B8%8D%E8%B0%83%E7%94%A8%E5%BA%93%EF%BC%89-%E5%89%8D%E7%BC%80-JS/</url>
    <content><![CDATA[<h4 id="209-长度最小的子数组"><a href="#209-长度最小的子数组" class="headerlink" title="209. 长度最小的子数组"></a><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/">209. 长度最小的子数组</a></h4><span id="more"></span>

<p>思路：<br>我们只需要找到 sums[k]-sums[j]&gt;=s，那么 k-j 就是满足的连续子数组 因此转换成求 sums[k]-sums[j]&gt;=s 我们可以求 sums[j]+s&lt;=sums[k]，我们只需要求出 sum[j]+s 的值，然后使用二分法查找即可找到这个 k。<br>二分优化（优化在找右端点）：<br>由于本题保证nums[i]为正，所以前缀和数组是递增的，也就是说在确定了区间左端之后，可以二分找右端点：<br>时间复杂度：<br>O(logn)<br>空间复杂度<br>O(n)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"><span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"><span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"><span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">var</span> minSubArrayLen = <span class="function"><span class="keyword">function</span>(<span class="params">s, nums</span>) </span>&#123;</span><br><span class="line"><span class="comment">// 二分查找</span></span><br><span class="line"><span class="keyword">var</span> binarySearch = <span class="function"><span class="keyword">function</span>(<span class="params">nums,target</span>)</span>&#123;</span><br><span class="line"><span class="keyword">let</span> left=-<span class="number">1</span>,right = nums.length,middle = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(left+<span class="number">1</span>!=right)&#123;</span><br><span class="line">middle = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>)</span><br><span class="line"><span class="keyword">if</span>(nums[middle]&gt;=target)&#123;</span><br><span class="line">right = middle;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">left = middle</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> right==nums.length?-<span class="number">1</span>:right</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ----------------------------------</span></span><br><span class="line"><span class="keyword">let</span> length=nums.length,min=+<span class="literal">Infinity</span>,sums=[]</span><br><span class="line">sums[<span class="number">0</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">1</span>;i&lt;=length;i++)&#123;</span><br><span class="line">sums[i] = sums[i-<span class="number">1</span>] + nums[i-<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;s: &quot;</span>+s);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;sums[0]: &quot;</span>+sums[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;=length;i++)&#123;</span><br><span class="line"><span class="keyword">let</span> target = s + sums[i]</span><br><span class="line"><span class="built_in">console</span>.log(i+<span class="string">&quot; sums[i]: &quot;</span>+sums[i]);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;target: &quot;</span>+target);</span><br><span class="line"><span class="keyword">let</span> index = binarySearch(sums,target)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;index: &quot;</span>+index)</span><br><span class="line"><span class="keyword">if</span>(index&lt;<span class="number">0</span>)&#123;</span><br><span class="line"><span class="keyword">break</span>. <span class="comment">// 当没找到，意味着加起来的和小于target，意味着当前的index与他之后的元素相加都没有超过target，意味着他之后的元素也都无法超过target,因此直接跳出循环即可.</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>( index&lt;=length)&#123;</span><br><span class="line">min = <span class="built_in">Math</span>.min(min,index-i)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;min: &quot;</span>+min)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;----------&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> min == +<span class="literal">Infinity</span>?<span class="number">0</span>:min</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM重点核心</title>
    <url>/2022/01/13/DOM%E9%87%8D%E7%82%B9%E6%A0%B8%E5%BF%83/</url>
    <content><![CDATA[<p>DOM 文档对象模型 （Document Object Model) 是W3C组织推荐的处理可扩展标记语言 （HTML或者XML）的标准编程接口。<br>通过这些DOM接口，可以改变网页的内容，结构和样式。<br>1、对于JS，为了能够使JS操作HTML，JS就有了一套自己的DOM编程接口。<br>2、对于HTML，dom使得html形成一棵dom树，包括文档，元素，节点。</p>
<ul>
<li><p>文档：一个页面就是一个文档，DOM中使用Document表示</p>
</li>
<li><p>元素：页面中的所有标签都是元素，DOM中使用element表示</p>
</li>
<li><p>节点：网页中的所有内容都是节点（标签，属性，文本，注释等），DOM中使用node表示<br>我们获取过来的<strong>DOM元素是一个对象（Object）</strong>，所以称为文档对象模型。<br>关于dom操作，我们主要针对于元素的操作。主要有创建，增，删，改，查、属性操作、事件操作。</p>
</li>
</ul>
<span id="more"></span>

<h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>1、document.write（直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘，同document.write）<br>2、innerHTML （将内容写入某个DOM节点，不会导致页面全部重绘，创建多个元素效率更高（不要拼接字符串，采取数组形式[document.body.innerHTML = array.join(‘’);]拼接），结构稍微复杂）<br>3、createElement （创建多个元素效率稍低一点点，但是结构更清晰）</p>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><p>1、appendChild （末尾追加）<br>2、insertBefore （前面追加）</p>
<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><p>1、removeChild</p>
<h1 id="改-——-主要修改dom的元素属性，dom元素的内容，属性，表单的值等"><a href="#改-——-主要修改dom的元素属性，dom元素的内容，属性，表单的值等" class="headerlink" title="改 —— 主要修改dom的元素属性，dom元素的内容，属性，表单的值等"></a>改 —— 主要修改dom的元素属性，dom元素的内容，属性，表单的值等</h1><p>1、修改元素属性：src，href，title等<br>2、修改普通元素内容：innerHTML（识别html标签，W3C标准，保留空格和换行。推荐），innerText（不识别html标签，非标准，去除空格和换行）<br>3、修改表单元素：value，type，disabled等<br>4、修改元素样式：style（修改比较少的时候使用，行内样式操作，所以优先级高，样式采取驼峰命名法 比如 fontSize,backgroundColor），className（修改比较多的时候使用，类名样式操作，会直接更改元素类名，会覆盖原先的类名，如果想保留原先的类名，我们可以这么做，多类名选择器）<br>查 —— 主要获取查询dom的元素<br>1、DOM提供的API方法：getElementById，getElementsByTagName(大小写敏感,若在当前Document下没有找到，则返回null,古老用法不推荐)<br>2、H5提供的新方法：querySelector(只获取第一个元素，类.,id是#)，querySelectorAll （提倡）<br>3、利用节点操作获取元素：父（parentNode）、子（children）、兄（previousElementSibling、nextElementSibling）提倡<br>4、获取特殊对象：document.body(返回body元素对象) document.documentElement(返回html元素对象)<br>5、parentNode.childNodes (标准 子节点 childNodes所有的子节点 包含 元素节点 文本节点等）<br>6、parentNode.children是一个只读属性，返回所有的子元素节点，它只返回子元素节点，其余节点不返回（这个是我们重点掌握的）虽然children是一个非标准，但是得到了各个游览器的支持，因此我们可以放心使用<br>7、parentNode.firstChild和parentNode.lastChild<br>firstChild返回第一个子节点，找不到则返回null。同样，也是包含所有的节点<br>firstChild第一个子节点，不管是文本节点还是元素节点<br>8、firstElementChild（返回第一个子元素节点，但是有兼容性问题 IE9以上才支持）lastElementChild返回第一个子元素节点<br>9实际开发中，firstChild和lastChild包含其他节点，操作不方便，而firstElementChild和lastElementChild又有兼容性问题，那么我们如何<br>获取第一个子元素节点或者最后一个子元素节点呢？解决方法：实际开发中，既没有兼容性问题，又返回第一个子元素ol.children[0]和ol.children[ol.children.length-1]</p>
<h1 id="属性操作-——-主要针对自定义属性"><a href="#属性操作-——-主要针对自定义属性" class="headerlink" title="属性操作 —— 主要针对自定义属性"></a>属性操作 —— 主要针对自定义属性</h1><p>1、setAttribute：设置dom的属性值<br>2、getAttribute：得到dom的属性值<br>3、removeAttribute：移除属性<br>4、常规取非自定义属性：element.属性 = 值<br>// h5新增的获取自定义属性的方法 它只能获取data-开头的<br>// dataset是一个集合里面存放了所有以data开头的自定义属性<br>console.log(div.dataset)<br>console.log(div.dataset.index)<br>console.log(div.dataset[‘index’])<br>如果是 data-list-name<br>div.getAttribute(‘data-list-name’)<br>console.log(div.dataset.listName)  驼峰命名法</p>
<h1 id="事件操作-——-给元素注册事件，采取事件源-事件类型-事件处理程序"><a href="#事件操作-——-给元素注册事件，采取事件源-事件类型-事件处理程序" class="headerlink" title="事件操作 —— 给元素注册事件，采取事件源.事件类型 = 事件处理程序"></a>事件操作 —— 给元素注册事件，采取事件源.事件类型 = 事件处理程序</h1><p>onclick 鼠标点击左键触发<br>onmouseover 鼠标经过触发<br>onmouseout 鼠标离开触发<br>onfocus 获得鼠标焦点触发<br>onblur 失去鼠标焦点触发<br>onmousemove 鼠标移动触发<br>onmouseup 鼠标弹起触发<br>onmousedown 鼠标按下触发</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>DOM</tag>
      </tags>
  </entry>
  <entry>
    <title>大四-清华大学实习——清华大学车辆与运载学院汽车安全与节能国家重点实验室新能源汽车测试组</title>
    <url>/2022/01/13/%E5%A4%A7%E5%9B%9B-%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%AE%9E%E4%B9%A0%E2%80%94%E2%80%94%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E8%BD%A6%E8%BE%86%E4%B8%8E%E8%BF%90%E8%BD%BD%E5%AD%A6%E9%99%A2%E6%B1%BD%E8%BD%A6%E5%AE%89%E5%85%A8%E4%B8%8E%E8%8A%82%E8%83%BD%E5%9B%BD%E5%AE%B6%E9%87%8D%E7%82%B9%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%96%B0%E8%83%BD%E6%BA%90%E6%B1%BD%E8%BD%A6%E6%B5%8B%E8%AF%95%E7%BB%84/</url>
    <content><![CDATA[<p>作品展示：</p>
<img src="/2022/01/13/%E5%A4%A7%E5%9B%9B-%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%AE%9E%E4%B9%A0%E2%80%94%E2%80%94%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E8%BD%A6%E8%BE%86%E4%B8%8E%E8%BF%90%E8%BD%BD%E5%AD%A6%E9%99%A2%E6%B1%BD%E8%BD%A6%E5%AE%89%E5%85%A8%E4%B8%8E%E8%8A%82%E8%83%BD%E5%9B%BD%E5%AE%B6%E9%87%8D%E7%82%B9%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%96%B0%E8%83%BD%E6%BA%90%E6%B1%BD%E8%BD%A6%E6%B5%8B%E8%AF%95%E7%BB%84/5.png" class="" title="This is an image">

<span id="more"></span>

<p>作品描述：</p>
<p>科技冬奥重点专项的大数据平台</p>
<p>实时展示车辆的数据信息</p>
<p>Vue+Echarts+socket.io</p>
]]></content>
      <categories>
        <category>作品集</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
        <tag>Vue</tag>
        <tag>Socket.io</tag>
      </tags>
  </entry>
  <entry>
    <title>双指针</title>
    <url>/2022/01/27/%E5%8F%8C%E6%8C%87%E9%92%88/</url>
    <content><![CDATA[<h2 id="什么是双指针（对撞指针、快慢指针）"><a href="#什么是双指针（对撞指针、快慢指针）" class="headerlink" title="什么是双指针（对撞指针、快慢指针）"></a>什么是双指针（对撞指针、快慢指针）</h2><p><strong>双指针</strong>，指的是在遍历对象的过程中，不是普通的使用单个指针进行访问，而是使用两个相同方向（<em>快慢指针</em>）或者相反方向（<em>对撞指针</em>）的指针进行扫描，从而达到相应的目的。</p>
<p>换言之，双指针法充分使用了数组有序这一特征，从而在某些情况下能够简化一些运算。</p>
<span id="more"></span>

<h2 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h2><h3 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h3><p><strong>快慢指针</strong>也是双指针，但是两个指针从同一侧开始遍历数组，将这两个指针分别定义为<code>快指针（fast）</code>和<code>慢指针（slow）</code>，两个指针以不同的策略移动，直到两个指针的值相等（或其他特殊条件）为止，如fast每次增长两个，slow每次增长一个。</p>
<p>以<a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/linked-list-cycle/">LeetCode 141.环形链表</a>为例,，判断给定链表中是否存在环，可以定义快慢两个指针，快指针每次增长一个，而慢指针每次增长两个，最后两个指针指向节点的值相等，则说明有环。就好像一个环形跑道上有一快一慢两个运动员赛跑，如果时间足够长，跑地快的运动员一定会赶上慢的运动员。</p>
<p>再比如<a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/">LeetCode 26 删除排序数组中的重复项</a>，这里还是定义快慢两个指针。快指针每次增长一个，慢指针只有当快慢指针上的值不同时，才增长一个（由于是有序数组，快慢指针值不等说明找到了新值）。</p>
<h3 id="对撞指针"><a href="#对撞指针" class="headerlink" title="对撞指针"></a>对撞指针</h3><p><strong>对撞指针</strong>是指在有序数组中，将指向最左侧的索引定义为<code>左指针(left)</code>，最右侧的定义为<code>右指针(right)</code>，然后从两头向中间进行数组遍历。</p>
<blockquote>
<p>对撞数组适用于<strong>有序数组</strong>，也就是说当你遇到题目给定有序数组时，应该第一时间想到用对撞指针解题。</p>
</blockquote>
<p>以**LeetCode 881<a href="https://link.zhihu.com/?target=https://leetcode-cn.com/problems/boats-to-save-people/">救生艇</a>**问题为例</p>
<p>由于本题只要求计算出<code>最小船数</code>，所以原数组是否被改变，和元素索引位置都不考虑在内，所以可以先对于给定数组进行排序，再从数组两侧向中间遍历。所以解题思路如下：</p>
<ol>
<li>对给定数组进行升序排序</li>
<li>初始化左右指针</li>
<li>每次都用一个”最重的“和一个”最轻的“进行配对，如果二人重量小于<code>Limit</code>，则此时的”最轻的“上船，即（<code>left++</code>）。不管”最轻的“是否上船，”最重的“都要上船，即（<code>right--</code>）并且所需船数量加一，即（<code>num++</code>）</li>
</ol>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>当遇到有序数组时，应该优先想到<code>双指针</code>来解决问题，因两个指针的同时遍历会减少空间复杂度和时间复杂度。</p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱可视化系统</title>
    <url>/2022/01/13/%E5%A4%A7%E5%9B%9B-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>作品描述：</p>
<p>知识图谱可视化系统</p>
<p>Vue+Echarts+Element-UI+Springboot + HugeGraph + MongoDB :</p>
<p>作品展示：</p>
<img src="/2022/01/13/%E5%A4%A7%E5%9B%9B-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/4.png" class="" title="This is an image">

<span id="more"></span>

<img src="/2022/01/13/%E5%A4%A7%E5%9B%9B-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/7.png" class="" title="This is an image">

<img src="/2022/01/13/%E5%A4%A7%E5%9B%9B-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/8.png" class="" title="This is an image">

<img src="/2022/01/13/%E5%A4%A7%E5%9B%9B-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/10.png" class="" title="This is an image">

<p>视频展示-1：</p>
<iframe height=500 width="100%" src='https://player.youku.com/embed/XNTE2OTU2ODQ4MA==' frameborder=0 'allowfullscreen'></iframe>

<p>视频展示-2:</p>
<iframe height=498 width=510 src='https://player.youku.com/embed/XNTE2OTU3NzgwOA==' frameborder=0 'allowfullscreen'></iframe>

<p>代码地址：</p>
<p><a href="https://github.com/Liny777/Visualization-vue-sample">https://github.com/Liny777/Visualization-vue-sample</a></p>
]]></content>
      <categories>
        <category>作品集</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
        <tag>Vue</tag>
        <tag>Element-ui</tag>
        <tag>HugeGraph</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>螺旋矩阵</title>
    <url>/2022/01/27/%E8%9E%BA%E6%97%8B%E7%9F%A9%E9%98%B5/</url>
    <content><![CDATA[<h4 id="54-螺旋矩阵"><a href="#54-螺旋矩阵" class="headerlink" title="54. 螺旋矩阵"></a><a href="https://leetcode-cn.com/problems/spiral-matrix/">54. 螺旋矩阵</a></h4><span id="more"></span>

<p>由于56题K神写法只适用于正方形，因此当题目变为矩形时，需要给后面的两个方向（右到左，下到上)增加判断条件，因为如果是正方形，最后到达中心点的时候，最后一次循环，必然是l=r,t=b,然后后两个方向就不会执行了，因为下一步就是r&lt;l,t&lt;b,但如果是矩形，那么就有可能出现l+1=r或者t+1=b在最后一次循环里，那么这时候就会导致最后两个方向会执行其中一个，导致最后结果多出一个值，这时候只需要加一个判断条件，如果返回的矩阵已经达到要求的数量，那么就不执行后面两个方向，强制不让后面两个方向执行即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> spiralOrder = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line"><span class="keyword">let</span> n = matrix.length,m = matrix[<span class="number">0</span>].length,l=t=<span class="number">0</span>,r=m-<span class="number">1</span>,b=n-<span class="number">1</span>,mat= <span class="keyword">new</span> <span class="built_in">Array</span>(nm).fill(<span class="number">0</span>),num=<span class="number">0</span>,tar=nm</span><br><span class="line"><span class="keyword">while</span>(num&lt;tar)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=l;i&lt;=r;i++) mat[num++] = matrix[t][i]</span><br><span class="line">t++</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=t;i&lt;=b;i++) mat[num++] = matrix[i][r]</span><br><span class="line">r--</span><br><span class="line"><span class="keyword">if</span>(mat[nm-<span class="number">1</span>]===<span class="number">0</span>)<span class="keyword">for</span>(<span class="keyword">let</span> i=r;i&gt;=l;i--) mat[num++] = matrix[b][i]</span><br><span class="line">b--</span><br><span class="line"><span class="keyword">if</span>(mat[n*m-<span class="number">1</span>]===<span class="number">0</span>)<span class="keyword">for</span>(<span class="keyword">let</span> i=b;i&gt;=t;i--) mat[num++] = matrix[i][l]</span><br><span class="line">l++</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> mat</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="59-螺旋矩阵-II"><a href="#59-螺旋矩阵-II" class="headerlink" title="59. 螺旋矩阵 II"></a><a href="https://leetcode-cn.com/problems/spiral-matrix-ii/">59. 螺旋矩阵 II</a></h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">n</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[][]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> generateMatrix = <span class="function"><span class="keyword">function</span>(<span class="params">n</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> l=t=<span class="number">0</span>,r=b=n-<span class="number">1</span></span><br><span class="line">    <span class="keyword">const</span> matrix = <span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>).map(<span class="function">()=&gt;</span><span class="keyword">new</span> <span class="built_in">Array</span>(n).fill(<span class="number">0</span>))</span><br><span class="line">    <span class="keyword">let</span> num=<span class="number">1</span>,tar=n*n</span><br><span class="line">    <span class="keyword">while</span>(num&lt;=tar)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=l;i&lt;=r;i++) matrix[t][i] = num++</span><br><span class="line">        t++</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=t;i&lt;=b;i++) matrix[i][r] = num++</span><br><span class="line">        r--</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=r;i&gt;=l;i--) matrix[b][i] = num++</span><br><span class="line">        b--</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">let</span> i=b;i&gt;=t;i--) matrix[i][l] = num++</span><br><span class="line">        l++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matrix</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>盛最多水的容器</title>
    <url>/2022/01/27/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<img src="/2022/01/27/%E7%9B%9B%E6%9C%80%E5%A4%9A%E6%B0%B4%E7%9A%84%E5%AE%B9%E5%99%A8/1.png" class="" title="This is an image">

<span id="more"></span>

<p>给你 n 个非负整数 a1，a2，…，an，每个数代表坐标中的一个点 (i, ai) 。在坐标内画 n 条垂直线，垂直线 i 的两个端点分别为 (i, ai) 和 (i, 0) 。找出其中的两条线，使得它们与 x 轴共同构成的容器可以容纳最多的水。</p>
<p>说明：你不能倾斜容器。</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>小的一边往内挪动</p>
<p>大的不动</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> \* <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">height</span></span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> \* <span class="doctag">@return <span class="type">&#123;number&#125;</span></span></span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> maxArea = <span class="function"><span class="keyword">function</span>(<span class="params">height</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">let</span> maxArea = <span class="number">0</span>,left=<span class="number">0</span>,right=height.length-<span class="number">1</span>,max=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line"></span><br><span class="line">​       </span><br><span class="line"></span><br><span class="line">​       <span class="keyword">if</span>(height[left]&lt;=height[right])&#123;</span><br><span class="line"></span><br><span class="line">​           max = height[left]*(right-left)</span><br><span class="line"></span><br><span class="line">​           left++</span><br><span class="line"></span><br><span class="line">​       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"></span><br><span class="line">​           max = height[right]*(right-left)</span><br><span class="line"></span><br><span class="line">​           right--</span><br><span class="line"></span><br><span class="line">​       &#125;</span><br><span class="line"></span><br><span class="line">​       maxArea = <span class="built_in">Math</span>.max(max,maxArea)</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">​    <span class="keyword">return</span> maxArea;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>





]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>红蓝二分法</title>
    <url>/2022/01/27/%E7%BA%A2%E8%93%9D%E4%BA%8C%E5%88%86%E6%B3%95/</url>
    <content><![CDATA[<img src="/2022/01/27/%E7%BA%A2%E8%93%9D%E4%BA%8C%E5%88%86%E6%B3%95/1.png" class="" title="This is an image">

<span id="more"></span>

<p>``</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number[]&#125;</span> <span class="variable">nums</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param <span class="type">&#123;number&#125;</span> <span class="variable">target</span></span></span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return <span class="type">&#123;number[]&#125;</span></span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="keyword">let</span> countLeft = <span class="function"><span class="keyword">function</span>(<span class="params">nums,target</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> left=-<span class="number">1</span>,right=nums.length,mid=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>!=right)&#123;</span><br><span class="line">            mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target)&#123;</span><br><span class="line">                left = mid</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> countRight = <span class="function"><span class="keyword">function</span>(<span class="params">nums,target</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">let</span> left=-<span class="number">1</span>,right=nums.length,mid=<span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span>(left+<span class="number">1</span>!=right)&#123;</span><br><span class="line">            mid = <span class="built_in">Math</span>.floor((left+right)/<span class="number">2</span>)</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;=target)&#123;</span><br><span class="line">                left = mid</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                right = mid</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">var</span> searchRange = <span class="function"><span class="keyword">function</span>(<span class="params">nums, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> ans = [-<span class="number">1</span>,-<span class="number">1</span>]</span><br><span class="line">    <span class="keyword">let</span> leftIndex = countLeft(nums,target)</span><br><span class="line">    <span class="keyword">let</span> rightIndex = countRight(nums,target)</span><br><span class="line">    <span class="keyword">if</span>(leftIndex&lt;=rightIndex &amp;&amp; leftIndex&gt;=<span class="number">0</span> &amp;&amp; rightIndex&lt;nums.length &amp;&amp; nums[leftIndex]===target &amp;&amp; nums[rightIndex]===target)&#123;</span><br><span class="line">        <span class="keyword">return</span> [leftIndex,rightIndex]</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ans</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>``</p>
<h2 id="b站视频讲解"><a href="#b站视频讲解" class="headerlink" title="b站视频讲解"></a>b站视频讲解</h2><iframe src="//player.bilibili.com/player.html?aid=841423368&bvid=BV1d54y1q7k7&cid=216724849&page=1" scrolling="no" border="0" frameborder="no" framespacing="0" allowfullscreen="true"> </iframe>

<h3 id="LeetCode题目"><a href="#LeetCode题目" class="headerlink" title="LeetCode题目"></a>LeetCode题目</h3><p><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/lan-hong-hua-fen-fa-dan-mo-ban-miao-sha-e7r40/">https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/solution/lan-hong-hua-fen-fa-dan-mo-ban-miao-sha-e7r40/</a></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>简单与复杂数据类型</title>
    <url>/2022/01/15/%E7%AE%80%E5%8D%95%E4%B8%8E%E5%A4%8D%E6%9D%82%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<p>简单类型又叫做基本数据类型或者值类型，复杂类型又叫做引用类型</p>
<ul>
<li>值类型：简单数据类型/基本数据类型，在存储时变量中存储的是值本身，因此叫做值类型<br>string number boolean undefined null</li>
<li>简单数据类型 null 返回的是一个空的对象 object // 当时设计的时候有问题，所以这个错误一直继续下去<br>// 如果有个变量我们以后打算存储为对象，暂时没想好放啥，这个时候就给null</li>
<li>引用类型：复杂数据类型，在存储变量中存储的仅仅是地址（引用），因此叫做引用数据类型<br>通过new关键字创建的对象（系统对象，自定义对象），如Object，Array，Date等</li>
</ul>
<hr>
<span id="more"></span>

<p>堆和栈</p>
<ul>
<li>简单存栈<br>1、栈（操作系统）：由操作系统自动分配释放存放函数的参数值，局部变量的值等，其操作方式类似于数据结构中的栈</li>
<li>复杂存堆<br>1、堆（操作系统）：存储复杂数据类型（对象），一般由程序员分配释放，若程序员不释放，由垃圾回收机制回收<br>！！ 注意 JavaScript中没有堆栈的概念，通过堆栈的方式，可以让大家更容易理解代码的一些执行方式，便于将来的学习</li>
</ul>
<p>简单数据类型的内存分配<br>1、存放在栈里面，直接开辟一个空间存放 值<br>变量名 指向 栈里值</p>
<p>复杂数据类型的内存分配<br>1、引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间里<br>变量名 指向 栈里的值（存的是地址，不是值） 再从地址 去 堆里找值<br>2、首先在栈里面存放地址（十六进制表示）然后这个地址只想堆里面的数据</p>
<p>简单类型如何传参<br>1、函数形参也可以看作是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量<br>2、拷贝值  然后传值</p>
<p>复杂数据类型如何传参<br>1、函数的形参也可以看作是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象<br>2、拷贝地址，然后传地址</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>进程与线程的区别小结</title>
    <url>/2022/01/15/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>进程是系统进行资源分配和调度的  “独立” 单位。</p>
<p>线程是CPU真正运行 实现CPU调度和分配的 “基本” 单位。</p>
<p>主要从两方向分析</p>
<p>1、线程简单的原因</p>
<p>2、进程困难的原因</p>
<p>主要从两方面解答</p>
<p>1、内存</p>
<p>2、通信</p>
<p>3、同步</p>
<span id="more"></span>

<p>1、线程简单的原因 —— 通信</p>
<p>线程之间通信：在同一进程下，共享全局变量，静态变量等数据，指针指向同一个内存，交互很方便。</p>
<p>2、进程困难的原因 —— 通信</p>
<p>进程之间通信：进程可以通过套接字、管道、信号交互、共享内存、消息队列等进行通信</p>
<p>进而可能问你啥是 套接字、管道、信号交互、消息队列 ？</p>
<p>3、线程简单的原因 —— 同步</p>
<p>线程之间需要满足一些合作规则才能进行合作，因此 如何实现 线程同步 ？</p>
<p>4、进程困难的原因 —— 同步</p>
<p>在单个CPU下，实际上在任何时刻只能有一个进程处于执行状态。而其他进程则处于非执行状态。我们是如何确定在任意时刻到底由哪个进程执行，哪些不执行呢？（如何进行进程调度？）</p>
<p>5、线程简单的原因 —— 内存</p>
<p>栈：主线程main函数、进行函数调用的参数和返回地址、局部变量等内容都会被压入栈内</p>
<p>PC（Program Couner）：程序计数器，PC的指针指向代码所在的内存地址。</p>
<p>TLS（Thread local storage）：分配内存，存放变量</p>
<p>6、进程困难的原因 —— 内存</p>
<p>进程与进程之间相对独立</p>
<p>进程可以包括几个或者上百个线程在运行</p>
<p>内存（逻辑内存）包括在进程里面，每个进程的内存都是互相独立的，但从一个更高的层次上看，不同的进程也共享着一个巨大的空间，这个空间就是整个计算机</p>
<p>进程共有文件/网络句柄（handle），这样可以打开同一个文件，抢同一个网络端口</p>
<p>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
]]></content>
      <categories>
        <category>面经小知识</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>时间复杂度</title>
    <url>/2022/01/27/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6/</url>
    <content><![CDATA[<p>O(1)常数阶 &lt; $O(\log n)$对数阶 &lt; $O(n)$线性阶 &lt; $O(n^2)$平方阶 &lt; $O(n^3)$立方阶 &lt; $O(2^n)$指数阶</p>
<span id="more"></span>

<p><strong>面试中说道算法的时间复杂度是多少指的都是一般情况</strong>。</p>
<p>？ 在决定使用哪些算法的时候，不是时间复杂越低的越好（因为简化后的时间复杂度忽略了常数项等等），要考虑数据规模，如果数据规模很小甚至可以用$O(n^2)$的算法比$O(n)$的更合适（在有常数项的时候）。 </p>
<p><strong>所以我们说的时间复杂度都是省略常数项系数的，是因为一般情况下都是默认数据规模足够的大，基于这样的事实，给出的算法时间复杂的的一个排行如下所示</strong></p>
]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>高级事件</title>
    <url>/2022/01/15/%E9%AB%98%E7%BA%A7%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<p>1、能够写出元素注册事件的两种方式</p>
<p>2、能够说出删除事件的两种方式</p>
<p>3、能够说出DOM事件流的三个阶段</p>
<p>4、能够利用时间对象完成跟随鼠标案例</p>
<p>5、能够封装阻止冒泡的兼容性函数</p>
<p>6、能够说出事件委托的原理</p>
<p>7、能够说出常用的鼠标和键盘事件</p>
<span id="more"></span>

<p>1.1 注册事件概述（绑定事件）</p>
<p>给元素添加事件，称为注册事件或者绑定事件。</p>
<p>注册事件有两种方式：传统方式和方法监听注册方式</p>
<p>传统注注册方式</p>
<p>1、利用on开头的事件onclick</p>
<p>2、&lt;button onclick=”alert(“hi~”)”&gt;</button></p>
<p>btn.onclick = function(){}</p>
<p>特点：注册事件的唯一性</p>
<p>同一个元素同一个事件只能设置一个处理函数</p>
<p>方法监听注册方式</p>
<p>w3c标准，推荐方式</p>
<p>addEventListener()它是一个方式</p>
<p>IE9之前的IE不支持此方法，可使用attachEvent（）代替</p>
<p>特点：同一个元素同一个事件可以注册多个监听器</p>
<p>1.2 addEventListener事件监听方式</p>
<p>eventTarget.addEventListener(type,listener[,useCapture])</p>
<p>eventTarget.addEventListener()方法将指定的监听器注册到eventTarget(目标对象)上，当该对象触发指定的事件时，就会执行事件处理函数。</p>
<p>该方法接受三个参数：</p>
<p>type：事件类型字符串，比如click，mouseover,注意这里不要带on</p>
<p>listener:事件处理函数，事件发生时，会调用该监听函数</p>
<p>useCapture：可选参数，是一个布尔值，默认是false，学完DOM事件流后，我们再进一步学习</p>
<p>attachEvent 非标准 不要在生产环境使用</p>
<p>eventTarget.attachEvent(eventNameWithOn,callback)</p>
<p>eventTarget.attachEvent()方法将指定的监听器注册到eventTarget（目标对象）上，当该对象触发指定的事件时，指定的回调函数就会被执行。</p>
<p>该方法接受两个参数：</p>
<p>eventnameWithOn:事件类型字符串，比如onclick,onmouseover,这里要带on</p>
<p>callback：事件处理函数，当目标触发事件时回调函数被调用。</p>
<p>注册事件兼容性解决方案</p>
<p>function addEventListener(element,eventName,fn){</p>
<p>​    //判断当前游览器是否支持addEventListener方法</p>
<p>​    if(element.addEventListener){</p>
<p>​        element.addEventListener(eventName fn); // 第三个参数，默认是false</p>
<p>​    }else if (element.attachEvent){</p>
<p>​        element.attachEvent(‘on’+eventName,fn)</p>
<p>​    }else{</p>
<p>​        // 相当于 element.onclick = fn</p>
<p>​        element[‘on’+eventName] = fn;</p>
<p>​    }</p>
<p>}</p>
<p>兼容性处理原则：首先照顾大多数游览器，再处理特殊游览器</p>
<p>\2. 删除事件（解绑事件）</p>
<p>2.1 删除事件的方式</p>
<p>1.传统注册方式</p>
<p>eventTarget.onclick = null</p>
<p>2.2 方法监听注册方式</p>
<p>eventTarget.removeEventListener(type,listener[,useCapture])</p>
<p>eventTarget.detachEvent(eventNameWithOn,callback)</p>
<hr>
<p>DOM事件流</p>
<p>事件流描述的是从页面中接受事件的顺序。</p>
<p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即DOM事件流。</p>
<p>DOM事件流分为3个阶段</p>
<p>1、捕获阶段</p>
<p>2、当前目标阶段</p>
<p>3、冒泡阶段</p>
<p>事件冒泡：IE最早提出，事件开始时由最具体的元素接受，然后逐级向上传播到DOM最顶层节点的过程</p>
<p>事件捕获：网景最早提出，由DOM最顶层节点开始，然后逐级向下传播到最具体的元素接受过程。</p>
<p>1、JS代码中只能执行捕获或者冒泡其中的一个阶段</p>
<p>2、onclick和attachEvent只能得到冒泡阶段</p>
<p>3、addEventListener（type，listener[,useCapture])第三个参数如果是true，表示事件捕获阶段调用事件处理程序，如果是false（不写默认就是false）表示在事件冒泡阶段调用事件处理程序。</p>
<p>4、实际开发中我们很少使用事件捕获，我们更关注事件冒泡。</p>
<p>5、有些事件是没有冒泡的，比如onblur,onfocus,onmouseenter,onmouseleave</p>
<p>6、事件冒泡有时候会带来麻烦，有时候会帮助很巧妙地做某些事情。</p>
<p>事件对象</p>
<p>1.event 就是只有一个事件对象 写到我们侦听函数的小括号里面当形参来看</p>
<p>2.事件对象只有有了事件才会存在，它是系统给我们自动创建的，不需要我们传递参数</p>
<p>3.事件对象 是 我们事件的一系列相关数据的集合，跟事件相关的，比如鼠标点击里面就包含了鼠标相关信息，鼠标坐标啊，如果是键盘事件里面就包含</p>
<p>的键盘事件的信息 比如 判断用户按下了那个键</p>
<p>4、这个事件对象我们可以自己命名，比如event、evt、e</p>
<p>5、事件对象也有兼容性问题 ie678通过window.event 兼容性问题 e = e || window.event;</p>
<p>var div = document.querySelector(‘div’)</p>
<p>div.onclick = function(e){</p>
<p>​    console.log(e)</p>
<p>​    console.log(window.event)</p>
<p>​    e = e || window.event; // 如果e为真，就执行e，如果e为假，就会执行后面的window.event</p>
<p>}</p>
<p>div.addEventListener(‘click’,function(e){</p>
<p>​    console.log(e)</p>
<p>})</p>
<p>官方解释：event对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态</p>
<p>简单理解：事件发生后，跟事件相关的一系列信息数据的集合，都放到这个对象里面，这个对象就是事件对象event，它有很多属性和方法。</p>
<p>比如：</p>
<p>1、谁绑定了这个事件</p>
<p>2、鼠标触发事件的话就会得到鼠标相关信息，如鼠标位置</p>
<p>3、键盘触发事件的话，会得到键盘的相关信息，如按了哪个键</p>
<p>\4. 事件对象</p>
<p>4.4 事件对象的常见属性和方法</p>
<p>e.target 返回触发事件的对象 标准</p>
<p>e.srcElement 返回触发事件的对象 非标准 ie6-8使用</p>
<p>e.type 返回事件的类型，比如click mouseover 不带on</p>
<p>e.cancelBubble 该属性阻止冒泡 非标准ie6-8使用</p>
<p>e.returnValue该属性阻止默认事件 （默认行为）非标准ie6-8使用 比如不让链接跳转</p>
<p>e.preventDefault() 该属性阻止默认事件（默认行为）  标准 比如不让链接跳转</p>
<p>e.stopPropagation() 阻止冒泡 标准</p>
<p>// 1. e.target 返回的是触发事件对象（元素） this返回的是绑定事件的对象（元素）</p>
<p>阻止事件冒泡</p>
<p>阻止事件冒泡的两种方式</p>
<p>事件冒泡：开始时由具体的元素接受然后逐级向上传播到DOM最顶层节点</p>
<p>事件冒泡本身的特性，会带来的坏处，也会带来好处，需要我们灵活掌握</p>
<p>标准写法：利用事件对象里面的stopPropagation()方法</p>
<p>阻止事件冒泡的兼容性解决方案</p>
<p>if(e &amp;&amp; e.stopPropagation){</p>
<p>​    e.stopPropagation()</p>
<p>}else{</p>
<p>​    window.event.cancelBubble = true</p>
<p>}</p>
<p>事件委托（代理，委托）</p>
<p>事件委托也称为事件代理，在jQuery里面称为事件委派</p>
<p>事件委托的原理： **********（必考）</p>
<p>不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置的每个子节点上</p>
<p>以上案例：给ul注册点击事件，然后利用事件对象的target来找到当前点击的li，因为点击li，事件会冒泡到ul上，ul有注册事件，就会触发事件监听器</p>
<p>事件委托的作用</p>
<p>我们只操作了一次DOM，提高程序性能</p>
<p>常用的鼠标事件</p>
<p>不给别人复制文字</p>
<p>1、禁止鼠标右键菜单</p>
<p>contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单</p>
<p>我们可以禁用右键</p>
<p>document.addEventListener(‘contextmenu’,function(e){</p>
<p>​    e.preventDefault()</p>
<p>})</p>
<p>2、禁止鼠标选中 (selectstart)</p>
<!-- document.querySelector -->



<p>常用鼠标事件对象</p>
<p>event对象代表事件的状态 跟事件相关的</p>
<p>鼠标事件对象</p>
<p>e.clientX 返回鼠标相对于浏览器窗口可视区的X坐标</p>
<p>e.clientY 返回鼠标相对于浏览器窗口可视区的Y坐标</p>
<p>e.pageX 返回鼠标相对于文档页面的X坐标 IE9+支持  重点记住</p>
<p>e.pageY 返回鼠标相对于文档页面的Y坐标 IE9+支持  重点记住</p>
<p>e.screenX 返回相对于电脑屏幕的X坐标</p>
<p>e.screenY 返回相对于电脑屏幕的Y坐标</p>
<p>鼠标事件</p>
<p>1、鼠标不断的移动，使用鼠标移动事件mousemove</p>
<p>2、在页面中移动，给document注册事件</p>
<p>3、图片要移动距离，而且不占位置，我们使用绝对定位即可</p>
<p>4、核心原理：每次鼠标移动，我们都会获得最新的鼠标坐标，把这个x和y坐标做为图片的top和left值就可以移动图片</p>
<p>常用的键盘事件</p>
<p>事件除了使用鼠标触发，还可以使用键盘触发</p>
<p>onkeyup: 某个键盘按键被松开时触发</p>
<p>onkeydown: 某个键盘按键被按下时 触发 能识别功能键 比如 ctrl shift箭头等</p>
<p>onkeypress：某个键盘按键被按下时 触发 但是它不识别功能键 比如 ctrl shift箭头等</p>
<p>三个事件的执行顺序 keydown – keypress – keyup</p>
<p>键盘事件对象</p>
<p>document</p>
<p>// 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值</p>
<p>// 我们的keyup和keydown事件不区分字母大小写 a和A得到的都是65</p>
<p>// keypress 区分 字母大小写 a和A，a=97，A=65</p>
<p>// 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>递归求斐波那契数列的性能分析</title>
    <url>/2022/01/27/%E9%80%92%E5%BD%92%E6%B1%82%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E6%80%A7%E8%83%BD%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<span id="more"></span>

<p><a href="https://zhuanlan.zhihu.com/p/27205391">https://zhuanlan.zhihu.com/p/27205391</a></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 版本二</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> first, <span class="keyword">int</span> second, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> first + second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">fibonacci</span>(second, first + second, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>LeetCode</category>
      </categories>
      <tags>
        <tag>数组</tag>
      </tags>
  </entry>
</search>
