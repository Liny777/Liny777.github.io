<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>DOM重点核心</title>
    <url>/2022/01/13/DOM%E9%87%8D%E7%82%B9%E6%A0%B8%E5%BF%83/</url>
    <content><![CDATA[<p>DOM 文档对象模型 （Document Object Model) 是W3C组织推荐的处理可扩展标记语言 （HTML或者XML）的标准编程接口。<br>通过这些DOM接口，可以改变网页的内容，结构和样式。<br>1、对于JS，为了能够使JS操作HTML，JS就有了一套自己的DOM编程接口。<br>2、对于HTML，dom使得html形成一棵dom树，包括文档，元素，节点。</p>
<ul>
<li><p>文档：一个页面就是一个文档，DOM中使用Document表示</p>
</li>
<li><p>元素：页面中的所有标签都是元素，DOM中使用element表示</p>
</li>
<li><p>节点：网页中的所有内容都是节点（标签，属性，文本，注释等），DOM中使用node表示<br>我们获取过来的<strong>DOM元素是一个对象（Object）</strong>，所以称为文档对象模型。<br>关于dom操作，我们主要针对于元素的操作。主要有创建，增，删，改，查、属性操作、事件操作。</p>
</li>
</ul>
<span id="more"></span>

<h1 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h1><p>1、document.write（直接将内容写入页面的内容流，但是文档流执行完毕，则它会导致页面全部重绘，同document.write）<br>2、innerHTML （将内容写入某个DOM节点，不会导致页面全部重绘，创建多个元素效率更高（不要拼接字符串，采取数组形式[document.body.innerHTML = array.join(‘’);]拼接），结构稍微复杂）<br>3、createElement （创建多个元素效率稍低一点点，但是结构更清晰）</p>
<h1 id="增"><a href="#增" class="headerlink" title="增"></a>增</h1><p>1、appendChild （末尾追加）<br>2、insertBefore （前面追加）</p>
<h1 id="删"><a href="#删" class="headerlink" title="删"></a>删</h1><p>1、removeChild</p>
<h1 id="改-——-主要修改dom的元素属性，dom元素的内容，属性，表单的值等"><a href="#改-——-主要修改dom的元素属性，dom元素的内容，属性，表单的值等" class="headerlink" title="改 —— 主要修改dom的元素属性，dom元素的内容，属性，表单的值等"></a>改 —— 主要修改dom的元素属性，dom元素的内容，属性，表单的值等</h1><p>1、修改元素属性：src，href，title等<br>2、修改普通元素内容：innerHTML（识别html标签，W3C标准，保留空格和换行。推荐），innerText（不识别html标签，非标准，去除空格和换行）<br>3、修改表单元素：value，type，disabled等<br>4、修改元素样式：style（修改比较少的时候使用，行内样式操作，所以优先级高，样式采取驼峰命名法 比如 fontSize,backgroundColor），className（修改比较多的时候使用，类名样式操作，会直接更改元素类名，会覆盖原先的类名，如果想保留原先的类名，我们可以这么做，多类名选择器）<br>查 —— 主要获取查询dom的元素<br>1、DOM提供的API方法：getElementById，getElementsByTagName(大小写敏感,若在当前Document下没有找到，则返回null,古老用法不推荐)<br>2、H5提供的新方法：querySelector(只获取第一个元素，类.,id是#)，querySelectorAll （提倡）<br>3、利用节点操作获取元素：父（parentNode）、子（children）、兄（previousElementSibling、nextElementSibling）提倡<br>4、获取特殊对象：document.body(返回body元素对象) document.documentElement(返回html元素对象)<br>5、parentNode.childNodes (标准 子节点 childNodes所有的子节点 包含 元素节点 文本节点等）<br>6、parentNode.children是一个只读属性，返回所有的子元素节点，它只返回子元素节点，其余节点不返回（这个是我们重点掌握的）虽然children是一个非标准，但是得到了各个游览器的支持，因此我们可以放心使用<br>7、parentNode.firstChild和parentNode.lastChild<br>firstChild返回第一个子节点，找不到则返回null。同样，也是包含所有的节点<br>firstChild第一个子节点，不管是文本节点还是元素节点<br>8、firstElementChild（返回第一个子元素节点，但是有兼容性问题 IE9以上才支持）lastElementChild返回第一个子元素节点<br>9实际开发中，firstChild和lastChild包含其他节点，操作不方便，而firstElementChild和lastElementChild又有兼容性问题，那么我们如何<br>获取第一个子元素节点或者最后一个子元素节点呢？解决方法：实际开发中，既没有兼容性问题，又返回第一个子元素ol.children[0]和ol.children[ol.children.length-1]</p>
<h1 id="属性操作-——-主要针对自定义属性"><a href="#属性操作-——-主要针对自定义属性" class="headerlink" title="属性操作 —— 主要针对自定义属性"></a>属性操作 —— 主要针对自定义属性</h1><p>1、setAttribute：设置dom的属性值<br>2、getAttribute：得到dom的属性值<br>3、removeAttribute：移除属性<br>4、常规取非自定义属性：element.属性 = 值<br>// h5新增的获取自定义属性的方法 它只能获取data-开头的<br>// dataset是一个集合里面存放了所有以data开头的自定义属性<br>console.log(div.dataset)<br>console.log(div.dataset.index)<br>console.log(div.dataset[‘index’])<br>如果是 data-list-name<br>div.getAttribute(‘data-list-name’)<br>console.log(div.dataset.listName)  驼峰命名法</p>
<h1 id="事件操作-——-给元素注册事件，采取事件源-事件类型-事件处理程序"><a href="#事件操作-——-给元素注册事件，采取事件源-事件类型-事件处理程序" class="headerlink" title="事件操作 —— 给元素注册事件，采取事件源.事件类型 = 事件处理程序"></a>事件操作 —— 给元素注册事件，采取事件源.事件类型 = 事件处理程序</h1><p>onclick 鼠标点击左键触发<br>onmouseover 鼠标经过触发<br>onmouseout 鼠标离开触发<br>onfocus 获得鼠标焦点触发<br>onblur 失去鼠标焦点触发<br>onmousemove 鼠标移动触发<br>onmouseup 鼠标弹起触发<br>onmousedown 鼠标按下触发</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>DOM</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>大四-清华大学实习——清华大学车辆与运载学院汽车安全与节能国家重点实验室新能源汽车测试组</title>
    <url>/2022/01/13/%E5%A4%A7%E5%9B%9B-%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%AE%9E%E4%B9%A0%E2%80%94%E2%80%94%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E8%BD%A6%E8%BE%86%E4%B8%8E%E8%BF%90%E8%BD%BD%E5%AD%A6%E9%99%A2%E6%B1%BD%E8%BD%A6%E5%AE%89%E5%85%A8%E4%B8%8E%E8%8A%82%E8%83%BD%E5%9B%BD%E5%AE%B6%E9%87%8D%E7%82%B9%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%96%B0%E8%83%BD%E6%BA%90%E6%B1%BD%E8%BD%A6%E6%B5%8B%E8%AF%95%E7%BB%84/</url>
    <content><![CDATA[<p>作品展示：</p>
<img src="/2022/01/13/%E5%A4%A7%E5%9B%9B-%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E5%AE%9E%E4%B9%A0%E2%80%94%E2%80%94%E6%B8%85%E5%8D%8E%E5%A4%A7%E5%AD%A6%E8%BD%A6%E8%BE%86%E4%B8%8E%E8%BF%90%E8%BD%BD%E5%AD%A6%E9%99%A2%E6%B1%BD%E8%BD%A6%E5%AE%89%E5%85%A8%E4%B8%8E%E8%8A%82%E8%83%BD%E5%9B%BD%E5%AE%B6%E9%87%8D%E7%82%B9%E5%AE%9E%E9%AA%8C%E5%AE%A4%E6%96%B0%E8%83%BD%E6%BA%90%E6%B1%BD%E8%BD%A6%E6%B5%8B%E8%AF%95%E7%BB%84/5.png" class="" title="This is an image">

<span id="more"></span>

<p>作品描述：</p>
<p>科技冬奥重点专项的大数据平台</p>
<p>实时展示车辆的数据信息</p>
<p>Vue+Echarts+socket.io</p>
]]></content>
      <categories>
        <category>作品集</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
        <tag>Vue</tag>
        <tag>Socket.io</tag>
      </tags>
  </entry>
  <entry>
    <title>知识图谱可视化系统</title>
    <url>/2022/01/13/%E5%A4%A7%E5%9B%9B-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<p>作品描述：</p>
<p>知识图谱可视化系统</p>
<p>Vue+Echarts+Element-UI+Springboot + HugeGraph + MongoDB :</p>
<p>作品展示：</p>
<img src="/2022/01/13/%E5%A4%A7%E5%9B%9B-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/4.png" class="" title="This is an image">

<span id="more"></span>

<img src="/2022/01/13/%E5%A4%A7%E5%9B%9B-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/7.png" class="" title="This is an image">

<img src="/2022/01/13/%E5%A4%A7%E5%9B%9B-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/8.png" class="" title="This is an image">

<img src="/2022/01/13/%E5%A4%A7%E5%9B%9B-%E7%9F%A5%E8%AF%86%E5%9B%BE%E8%B0%B1%E5%8F%AF%E8%A7%86%E5%8C%96%E7%B3%BB%E7%BB%9F/10.png" class="" title="This is an image">

<p>视频展示-1：</p>
<iframe height=500 width="100%" src='https://player.youku.com/embed/XNTE2OTU2ODQ4MA==' frameborder=0 'allowfullscreen'></iframe>

<p>视频展示-2:</p>
<iframe height=498 width=510 src='https://player.youku.com/embed/XNTE2OTU3NzgwOA==' frameborder=0 'allowfullscreen'></iframe>

<p>代码地址：</p>
<p><a href="https://github.com/Liny777/Visualization-vue-sample">https://github.com/Liny777/Visualization-vue-sample</a></p>
]]></content>
      <categories>
        <category>作品集</category>
      </categories>
      <tags>
        <tag>Echarts</tag>
        <tag>Vue</tag>
        <tag>Element-ui</tag>
        <tag>HugeGraph</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title>This指向问题</title>
    <url>/2022/01/15/this%E6%8C%87%E5%90%91%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p>this指向问题 一般情况下this的最终指向的是那个调用它的对象</p>
<ol>
<li><p>全局作用域或者普通函数中的this指向全局对象window(注意定时器里面的this指向window)</p>
</li>
<li><p>方法调用中谁调用this指向谁</p>
</li>
<li><p>构造函数中的this指向构造函数的实例</p>
</li>
</ol>
<span id="more"></span>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title>进程与线程的区别小结</title>
    <url>/2022/01/15/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%E5%B0%8F%E7%BB%93/</url>
    <content><![CDATA[<p>进程是系统进行资源分配和调度的  “独立” 单位。</p>
<p>线程是CPU真正运行 实现CPU调度和分配的 “基本” 单位。</p>
<p>主要从两方向分析</p>
<p>1、线程简单的原因</p>
<p>2、进程困难的原因</p>
<p>主要从两方面解答</p>
<p>1、内存</p>
<p>2、通信</p>
<p>3、同步</p>
<span id="more"></span>

<p>1、线程简单的原因 —— 通信</p>
<p>线程之间通信：在同一进程下，共享全局变量，静态变量等数据，指针指向同一个内存，交互很方便。</p>
<p>2、进程困难的原因 —— 通信</p>
<p>进程之间通信：进程可以通过套接字、管道、信号交互、共享内存、消息队列等进行通信</p>
<p>进而可能问你啥是 套接字、管道、信号交互、消息队列 ？</p>
<p>3、线程简单的原因 —— 同步</p>
<p>线程之间需要满足一些合作规则才能进行合作，因此 如何实现 线程同步 ？</p>
<p>4、进程困难的原因 —— 同步</p>
<p>在单个CPU下，实际上在任何时刻只能有一个进程处于执行状态。而其他进程则处于非执行状态。我们是如何确定在任意时刻到底由哪个进程执行，哪些不执行呢？（如何进行进程调度？）</p>
<p>5、线程简单的原因 —— 内存</p>
<p>栈：主线程main函数、进行函数调用的参数和返回地址、局部变量等内容都会被压入栈内</p>
<p>PC（Program Couner）：程序计数器，PC的指针指向代码所在的内存地址。</p>
<p>TLS（Thread local storage）：分配内存，存放变量</p>
<p>6、进程困难的原因 —— 内存</p>
<p>进程与进程之间相对独立</p>
<p>进程可以包括几个或者上百个线程在运行</p>
<p>内存（逻辑内存）包括在进程里面，每个进程的内存都是互相独立的，但从一个更高的层次上看，不同的进程也共享着一个巨大的空间，这个空间就是整个计算机</p>
<p>进程共有文件/网络句柄（handle），这样可以打开同一个文件，抢同一个网络端口</p>
<p>进程在执行过程中拥有独立的内存单元，而多个线程共享内存，从而极大地提高了程序的运行效率。</p>
]]></content>
      <categories>
        <category>面经小知识</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>JS执行机制-同步与异步</title>
    <url>/2022/01/15/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<img src="/2022/01/15/JS%E6%89%A7%E8%A1%8C%E6%9C%BA%E5%88%B6-%E5%90%8C%E6%AD%A5%E4%B8%8E%E5%BC%82%E6%AD%A5/1.jpg" class="" title="This is an image">

<span id="more"></span>

<h1 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h1><h2 id="同步任务"><a href="#同步任务" class="headerlink" title="同步任务"></a>同步任务</h2><p>同步任务都在主线程上执行，形成一个执行栈</p>
<h2 id="异步任务"><a href="#异步任务" class="headerlink" title="异步任务"></a>异步任务</h2><p>JS的异步是通过回调函数实现的。<br>一般而言，异步任务有以下三种类型：<br>1、普通事件，如click，resize等<br>2、资源加载，如load，error等<br>3、定时器：包括setInterval，setTimeout等<br>异步任务相关回调函数添加到任务队列中（任务队列也称为消息队列）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//// 123</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">3</span>)</span><br><span class="line">&#125;,<span class="number">0</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>



<h2 id="JS执行机制"><a href="#JS执行机制" class="headerlink" title="JS执行机制"></a>JS执行机制</h2><p>1、先执行执行栈中的同步任务<br>2、异步任务（回调函数）放入任务队列中。<br>3、一旦执行栈中所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。</p>
<h2 id="事件循环"><a href="#事件循环" class="headerlink" title="事件循环"></a>事件循环</h2><p>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（event loop)</p>
]]></content>
      <categories>
        <category>前端学习</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
</search>
